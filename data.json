{
    "introduction": {
        "name": "Operating Systems (ECS 150)",
        "description": "Introduction aux systeme d'exploitation",
        "topics": {
            "introduction": { "name": "Introduction" },
            "concepts_os": { "name": "Concepts des Systèmes d'Exploitation" },
            "rôles_os": { "name": "Rôles des Systèmes d'Exploitation" },
            "processus": { "name": "Processus" },
            "gestion_mémoire": { "name": "Gestion de la Mémoire" },
            "fichiers_es": { "name": "Fichiers et E/S" },
            "évolution": { "name": "Évolution des Systèmes d'Exploitation" },
            "problèmes_os": { "name": "Problèmes des Systèmes d'Exploitation" },
            "services": { "name": "Services" },
            "communication": { "name": "Communication" }
        },
        "quizData": {
            "multiple-choice": [
                {
                    "id": 1,
                    "topic": "introduction",
                    "question": "Quel est l'un des principaux objectifs du cours ECS 150 sur les systèmes d'exploitation ?",
                    "options": [
                        "Apprendre les API spécifiques pour Linux et Windows",
                        "Comprendre les composants des systèmes d'exploitation modernes",
                        "Se concentrer sur la conception matérielle",
                        "Développer des applications utilisateur"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Le cours vise à fournir une compréhension générale des composants des systèmes d'exploitation modernes et des problèmes théoriques associés, et non des API spécifiques ou la conception matérielle."
                },
                {
                    "id": 2,
                    "topic": "concepts_os",
                    "question": "Lequel des éléments suivants décrit le mieux un système d'exploitation en tant que machine étendue ?",
                    "options": [
                        "Il gère directement les ressources matérielles",
                        "Il cache la complexité par l'abstraction",
                        "Il fournit uniquement la virtualisation",
                        "Il agit uniquement comme un gestionnaire de ressources"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Un système d'exploitation en tant que machine étendue utilise le principe d'abstraction pour cacher la complexité, offrant des opérations de haut niveau à partir d'opérations matérielles de bas niveau."
                },
                {
                    "id": 3,
                    "topic": "rôles_os",
                    "question": "Quel est un avantage clé pour l'utilisateur fourni par un système d'exploitation ?",
                    "options": [
                        "Accès direct au matériel",
                        "Simplicité de programmation",
                        "Allocation manuelle des ressources",
                        "Interfaces utilisateur complexes"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les systèmes d'exploitation offrent une simplicité de programmation grâce à des API de haut niveau et des utilitaires, bénéficiant aux utilisateurs."
                },
                {
                    "id": 4,
                    "topic": "processus",
                    "question": "Qu'est-ce qu'un processus dans le contexte des systèmes d'exploitation ?",
                    "options": [
                        "Un composant matériel",
                        "Une unité d'activité avec un fil d'exécution séquentiel",
                        "Un type de stockage mémoire",
                        "Une interface utilisateur"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Un processus est une unité d'activité caractérisée par un fil d'exécution séquentiel, un état actuel et un ensemble de ressources système associées."
                },
                {
                    "id": 5,
                    "topic": "gestion_mémoire",
                    "question": "Quelle est une fonction clé de la gestion de la mémoire dans un système d'exploitation ?",
                    "options": [
                        "Exécution des programmes utilisateur",
                        "Assurer l'isolation des processus",
                        "Gérer les connexions réseau",
                        "Fournir des interfaces utilisateur"
                    ],
                    "correctAnswer": 1,
                    "explanation": "La gestion de la mémoire garantit l'isolation des processus, la sécurité et l'allocation automatique, entre autres fonctions."
                },
                {
                    "id": 6,
                    "topic": "fichiers_es",
                    "question": "Quelle est une caractéristique des systèmes de fichiers et d'E/S dans les systèmes d'exploitation ?",
                    "options": [
                        "Stockage de données à court terme",
                        "Stockage d'archives à long terme",
                        "Contrôle direct du matériel",
                        "Exécution de programmes"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les systèmes de fichiers et d'E/S sont conçus pour le stockage d'archives à long terme et la gestion des données."
                },
                {
                    "id": 7,
                    "topic": "évolution",
                    "question": "Quelle était une caractéristique clé des systèmes de traitement par lots dans l'évolution des systèmes d'exploitation ?",
                    "options": [
                        "Interfaces utilisateur interactives",
                        "Moniteur résident en mémoire principale",
                        "Traitement en temps réel",
                        "Informatique distribuée"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les systèmes de traitement par lots utilisaient un moniteur résident en mémoire principale pour contrôler l'exécution des tâches."
                },
                {
                    "id": 8,
                    "topic": "problèmes_os",
                    "question": "Quel problème est associé à la gestion des ressources dans les systèmes d'exploitation ?",
                    "options": [
                        "Définir les interfaces utilisateur",
                        "Partager les ressources entre les processus",
                        "Écrire du code d'application",
                        "Concevoir des composants matériels"
                    ],
                    "correctAnswer": 1,
                    "explanation": "La gestion des ressources implique de partager efficacement des ressources comme le CPU et la mémoire entre les processus."
                },
                {
                    "id": 9,
                    "topic": "services",
                    "question": "Quel service un système d'exploitation fournit-il pour le développement de programmes ?",
                    "options": [
                        "Configuration réseau",
                        "Éditeurs et débogueurs",
                        "Fabrication de matériel",
                        "Authentification des utilisateurs"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les systèmes d'exploitation fournissent des éditeurs et des débogueurs pour soutenir le développement de programmes."
                },
                {
                    "id": 10,
                    "topic": "communication",
                    "question": "Quel mécanisme est utilisé pour la communication entre les processus dans un système d'exploitation ?",
                    "options": [
                        "Accès direct au matériel",
                        "Mémoire partagée",
                        "Interface utilisateur",
                        "Compilation de programmes"
                    ],
                    "correctAnswer": 1,
                    "explanation": "La mémoire partagée est l'un des mécanismes utilisés pour la communication entre les processus."
                },
                {
                    "id": 11,
                    "topic": "introduction",
                    "question": "Quel est le système d'exploitation principal utilisé comme exemple dans le cours ECS 150 ?",
                    "options": [
                        "Windows XP",
                        "Linux",
                        "BSD",
                        "MacOS"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Le cours utilise principalement BSD comme exemple pour illustrer les concepts des systèmes d'exploitation."
                },
                {
                    "id": 12,
                    "topic": "concepts_os",
                    "question": "Comment un système d'exploitation agit-il comme une machine virtuelle ?",
                    "options": [
                        "Il exécute directement les instructions matérielles",
                        "Il fournit un CPU virtuel, une mémoire et des périphériques",
                        "Il compile les programmes utilisateur",
                        "Il gère uniquement les fichiers"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Un système d'exploitation fournit des ressources virtualisées comme un CPU virtuel, une mémoire et des périphériques pour supporter le partage."
                },
                {
                    "id": 13,
                    "topic": "rôles_os",
                    "question": "Quel est un objectif principal des systèmes d'exploitation en termes de portabilité ?",
                    "options": [
                        "Restreindre les applications à une architecture spécifique",
                        "Permettre aux applications de fonctionner sur différentes architectures matérielles",
                        "Augmenter la complexité du code",
                        "Réduire la sécurité des applications"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les systèmes d'exploitation assurent la portabilité en permettant aux applications de fonctionner sur différentes architectures matérielles."
                },
                {
                    "id": 14,
                    "topic": "processus",
                    "question": "Quel composant d'un processus contient son contexte d'exécution ?",
                    "options": [
                        "Programme",
                        "Données associées",
                        "Contexte d'exécution",
                        "Ressources matérielles"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Le contexte d'exécution d'un processus inclut son état actuel, comme les registres et le compteur de programme."
                },
                {
                    "id": 15,
                    "topic": "gestion_mémoire",
                    "question": "Quel est l'un des coûts associés à la gestion de la mémoire ?",
                    "options": [
                        "Défauts de page",
                        "Connexions réseau",
                        "Compilation de programmes",
                        "Exécution d'applications"
                    ],
                    "correctAnswer": 0,
                    "explanation": "Les défauts de page sont un coût de la gestion de la mémoire, entraînant des interruptions pour charger les pages nécessaires."
                },
                {
                    "id": 16,
                    "topic": "fichiers_es",
                    "question": "Quel algorithme est utilisé dans les systèmes de fichiers pour améliorer les performances ?",
                    "options": [
                        "Mise en mémoire tampon",
                        "Compilation",
                        "Chiffrement",
                        "Synchronisation"
                    ],
                    "correctAnswer": 0,
                    "explanation": "La mise en mémoire tampon est un algorithme utilisé pour réduire la latence et améliorer les performances des systèmes de fichiers."
                },
                {
                    "id": 17,
                    "topic": "évolution",
                    "question": "Quel était un inconvénient du traitement sériel dans les premiers systèmes ?",
                    "options": [
                        "Interfaces utilisateur graphiques",
                        "Absence de système d'exploitation",
                        "Temps réel garanti",
                        "Multiprogrammation"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Le traitement sériel n'avait pas de système d'exploitation, obligeant les utilisateurs à configurer manuellement les machines."
                },
                {
                    "id": 18,
                    "topic": "problèmes_os",
                    "question": "Quel problème de sécurité un système d'exploitation doit-il résoudre ?",
                    "options": [
                        "Création d'interfaces utilisateur",
                        "Protection d'un programme contre un autre",
                        "Conception de matériel",
                        "Exécution de compilateurs"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les systèmes d'exploitation doivent protéger les programmes les uns des autres pour assurer la sécurité et l'intégrité."
                },
                {
                    "id": 19,
                    "topic": "services",
                    "question": "Quel service un système d'exploitation fournit-il pour la gestion des erreurs ?",
                    "options": [
                        "Détection et réponse aux erreurs matérielles et logicielles",
                        "Création de programmes utilisateur",
                        "Conception de matériel",
                        "Configuration réseau"
                    ],
                    "correctAnswer": 0,
                    "explanation": "Les systèmes d'exploitation détectent et répondent aux erreurs matérielles (comme les erreurs de mémoire) et logicielles (comme les débordements arithmétiques)."
                },
                {
                    "id": 20,
                    "topic": "communication",
                    "question": "Quel type de communication est pris en charge par les systèmes d'exploitation ?",
                    "options": [
                        "Communication de groupe",
                        "Conception matérielle",
                        "Compilation de programmes",
                        "Création d'interfaces utilisateur"
                    ],
                    "correctAnswer": 0,
                    "explanation": "Les systèmes d'exploitation prennent en charge la communication de groupe, comme les modèles un-à-plusieurs ou plusieurs-à-un."
                },
                {
                    "id": 21,
                    "topic": "introduction",
                    "question": "Quel est l'un des thèmes organisationnels du cours ECS 150 ?",
                    "options": [
                        "Conception de matériel",
                        "Composants et problèmes des systèmes d'exploitation",
                        "Développement d'applications utilisateur",
                        "Configuration réseau"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Le thème organisationnel du cours est les composants des systèmes d'exploitation et les problèmes liés à leur construction."
                },
                {
                    "id": 22,
                    "topic": "concepts_os",
                    "question": "Comment un système d'exploitation agit-il comme un gestionnaire de ressources ?",
                    "options": [
                        "Il exécute directement les programmes utilisateur",
                        "Il contrôle l'accès aux ressources matérielles",
                        "Il conçoit des interfaces utilisateur",
                        "Il compile les programmes"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Un système d'exploitation agit comme un gestionnaire de ressources en contrôlant l'accès aux ressources matérielles comme le CPU, la mémoire et le stockage."
                },
                {
                    "id": 23,
                    "topic": "rôles_os",
                    "question": "Quel avantage un système d'exploitation offre-t-il en termes de sécurité ?",
                    "options": [
                        "Accès direct au matériel",
                        "Exécution plus rapide des programmes",
                        "Protection des données et des programmes",
                        "Conception d'interfaces utilisateur"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Les systèmes d'exploitation offrent une protection des données et des programmes pour assurer la sécurité des utilisateurs."
                },
                {
                    "id": 24,
                    "topic": "processus",
                    "question": "Quel est un problème associé à la gestion des processus ?",
                    "options": [
                        "Coût de la commutation de contexte",
                        "Conception de matériel",
                        "Compilation de programmes",
                        "Configuration réseau"
                    ],
                    "correctAnswer": 0,
                    "explanation": "La commutation de contexte est un coût important dans la gestion des processus, affectant les performances."
                },
                {
                    "id": 25,
                    "topic": "gestion_mémoire",
                    "question": "Quelle technique est utilisée pour la gestion de la mémoire virtuelle ?",
                    "options": [
                        "Pagination",
                        "Compilation",
                        "Chiffrement",
                        "Synchronisation"
                    ],
                    "correctAnswer": 0,
                    "explanation": "La pagination est une technique clé utilisée dans la gestion de la mémoire virtuelle pour allouer et accéder à la mémoire."
                },
                {
                    "id": 26,
                    "topic": "fichiers_es",
                    "question": "Quel est un objectif des systèmes d'E/S dans les systèmes d'exploitation ?",
                    "options": [
                        "Création de programmes utilisateur",
                        "Réduction de la latence",
                        "Conception de matériel",
                        "Exécution de compilateurs"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les systèmes d'E/S visent à réduire la latence pour améliorer les performances des opérations d'entrée/sortie."
                },
                {
                    "id": 27,
                    "topic": "évolution",
                    "question": "Quelle caractéristique a introduit la multiprogrammation dans les systèmes d'exploitation ?",
                    "options": [
                        "Interfaces graphiques",
                        "Chevauchement CPU et E/S",
                        "Traitement sériel",
                        "Systèmes embarqués"
                    ],
                    "correctAnswer": 1,
                    "explanation": "La multiprogrammation a permis le chevauchement des opérations CPU et E/S, améliorant l'efficacité."
                },
                {
                    "id": 28,
                    "topic": "problèmes_os",
                    "question": "Quel problème concerne la synchronisation dans les systèmes d'exploitation ?",
                    "options": [
                        "Conception de matériel",
                        "Création d'interfaces utilisateur",
                        "Coordination des activités parallèles",
                        "Compilation de programmes"
                    ],
                    "correctAnswer": 2,
                    "explanation": "La synchronisation concerne la coordination des activités parallèles pour éviter les conflits et assurer la cohérence."
                },
                {
                    "id": 29,
                    "topic": "services",
                    "question": "Quel service un système d'exploitation fournit-il pour l'accès au système ?",
                    "options": [
                        "Conception de matériel",
                        "Contrôle d'accès aux ressources",
                        "Compilation de programmes",
                        "Création d'interfaces utilisateur"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les systèmes d'exploitation contrôlent l'accès aux ressources pour garantir une utilisation sécurisée et équitable."
                },
                {
                    "id": 30,
                    "topic": "communication",
                    "question": "Quel protocole est utilisé pour la communication dans les systèmes d'exploitation ?",
                    "options": [
                        "Compilateur",
                        "RPC (Appel de procédure à distance)",
                        "Interface graphique",
                        "Programme utilisateur"
                    ],
                    "correctAnswer": 1,
                    "explanation": "L'appel de procédure à distance (RPC) est un protocole utilisé pour la communication entre processus."
                },
                {
                    "id": 31,
                    "topic": "introduction",
                    "question": "Quel est le focus principal du cours ECS 150 ?",
                    "options": [
                        "Conception matérielle",
                        "Concepts et réalisation des systèmes d'exploitation",
                        "Développement d'applications",
                        "Configuration réseau"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Le cours se concentre sur les concepts des systèmes d'exploitation et leur réalisation, utilisant BSD comme exemple."
                },
                {
                    "id": 32,
                    "topic": "concepts_os",
                    "question": "Quel rôle un système d'exploitation joue-t-il en tant qu'interface ?",
                    "options": [
                        "Il exécute directement les instructions matérielles",
                        "Il agit entre les applications et le matériel",
                        "Il conçoit des programmes utilisateur",
                        "Il gère uniquement les fichiers"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Un système d'exploitation agit comme une interface entre les applications et le matériel, simplifiant l'accès aux ressources."
                },
                {
                    "id": 33,
                    "topic": "rôles_os",
                    "question": "Quel est un objectif des systèmes d'exploitation en termes d'efficacité ?",
                    "options": [
                        "Augmenter la complexité du code",
                        "Optimiser l'utilisation des ressources",
                        "Restreindre l'accès aux périphériques",
                        "Réduire la portabilité"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les systèmes d'exploitation optimisent l'utilisation des ressources pour améliorer l'efficacité globale."
                },
                {
                    "id": 34,
                    "topic": "processus",
                    "question": "Quel est un avantage des threads par rapport aux processus ?",
                    "options": [
                        "Ils nécessitent plus de mémoire",
                        "Ils partagent la même mémoire, réduisant les coûts",
                        "Ils sont plus lents",
                        "Ils ne permettent pas la concurrence"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les threads partagent la même mémoire, réduisant les coûts de gestion par rapport aux processus."
                },
                {
                    "id": 35,
                    "topic": "gestion_mémoire",
                    "question": "Quel mécanisme est utilisé pour la gestion de la mémoire ?",
                    "options": [
                        "Hiérarchie de mémoire",
                        "Compilation",
                        "Synchronisation",
                        "Chiffrement"
                    ],
                    "correctAnswer": 0,
                    "explanation": "La hiérarchie de mémoire est utilisée pour organiser et gérer efficacement la mémoire."
                },
                {
                    "id": 36,
                    "topic": "fichiers_es",
                    "question": "Quel est un défi des systèmes de fichiers dans les systèmes d exploitation ?",
                    "options": [
                        "Maintenir la cohérence",
                        "Compiler les programmes",
                        "Concevoir le matériel",
                        "Créer des interfaces utilisateur"
                    ],
                    "correctAnswer": 0,
                    "explanation": "Maintenir la cohérence est un défi clé pour les systèmes de fichiers, en particulier dans les environnements distribués."
                },
                {
                    "id": 37,
                    "topic": "évolution",
                    "question": "Quelle caractéristique les systèmes interactifs ont-ils introduite ?",
                    "options": [
                        "Temps de réponse garanti",
                        "Traitement sériel",
                        "Systèmes embarqués",
                        "Moniteurs résidents"
                    ],
                    "correctAnswer": 0,
                    "explanation": "Les systèmes interactifs ont introduit un temps de réponse garanti grâce au partage de temps."
                },
                {
                    "id": 38,
                    "topic": "problèmes_os",
                    "question": "Quel problème concerne la protection dans les systèmes d'exploitation ?",
                    "options": [
                        "Création de programmes utilisateur",
                        "Assurer l'intégrité du système d'exploitation",
                        "Conception de matériel",
                        "Compilation de programmes"
                    ],
                    "correctAnswer": 1,
                    "explanation": "La protection implique d'assurer l'intégrité du système d'exploitation et de ses ressources."
                },
                {
                    "id": 39,
                    "topic": "services",
                    "question": "Quel service un système d'exploitation fournit-il pour l'exécution des programmes ?",
                    "options": [
                        "Conception de matériel",
                        "Accès aux périphériques d'E/S",
                        "Compilation de programmes",
                        "Création d'interfaces utilisateur"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les systèmes d'exploitation fournissent un accès contrôlé aux périphériques d'E/S pour l'exécution des programmes."
                },
                {
                    "id": 40,
                    "topic": "communication",
                    "question": "Quel est un coût associé à la communication dans les systèmes d'exploitation ?",
                    "options": [
                        "Latence",
                        "Compilation",
                        "Conception de matériel",
                        "Création de programmes"
                    ],
                    "correctAnswer": 0,
                    "explanation": "La latence est un coût important dans la communication entre processus, affectant les performances."
                },
                {
                    "id": 41,
                    "topic": "introduction",
                    "question": "Quel est un objectif du cours ECS 150 concernant l'implémentation ?",
                    "options": [
                        "Conception de matériel",
                        "Implémentation de fragments de composants de systèmes d'exploitation",
                        "Développement d'applications utilisateur",
                        "Configuration réseau"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Le cours inclut l'implémentation de fragments de composants de systèmes d'exploitation pour comprendre leur fonctionnement."
                },
                {
                    "id": 42,
                    "topic": "concepts_os",
                    "question": "Pourquoi un système d'exploitation est-il comparé à une bibliothèque ?",
                    "options": [
                        "Il exécute directement le matériel",
                        "Il fournit des services sans être toujours explicitement appelé",
                        "Il conçoit des programmes utilisateur",
                        "Il gère uniquement les fichiers"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Un système d'exploitation fournit des services comme une bibliothèque, intervenant parfois sans appel explicite."
                },
                {
                    "id": 43,
                    "topic": "rôles_os",
                    "question": "Quel est un objectif des systèmes d'exploitation en termes d'évolutivité ?",
                    "options": [
                        "Restreindre les mises à jour",
                        "Permettre l'ajout de nouvelles fonctionnalités",
                        "Augmenter la complexité",
                        "Réduire la sécurité"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les systèmes d'exploitation doivent permettre l'ajout de nouvelles fonctionnalités pour évoluer avec le temps."
                },
                {
                    "id": 44,
                    "topic": "processus",
                    "question": "Quel est un problème de concurrence dans la gestion des processus ?",
                    "options": [
                        "Planification équitable",
                        "Conception de matériel",
                        "Compilation de programmes",
                        "Configuration réseau"
                    ],
                    "correctAnswer": 0,
                    "explanation": "La planification équitable est un problème de concurrence, garantissant que tous les processus reçoivent un accès juste au CPU."
                },
                {
                    "id": 45,
                    "topic": "gestion_mémoire",
                    "question": "Quel est un avantage de la mémoire virtuelle ?",
                    "options": [
                        "Augmenter la complexité",
                        "Permettre l'isolation des processus",
                        "Réduire la mémoire physique",
                        "Restreindre l'accès aux périphériques"
                    ],
                    "correctAnswer": 1,
                    "explanation": "La mémoire virtuelle permet l'isolation des processus, améliorant la sécurité et la gestion."
                },
                {
                    "id": 46,
                    "topic": "fichiers_es",
                    "question": "Quel est un aspect de performance des systèmes d'E/S ?",
                    "options": [
                        "Utilisation des ressources",
                        "Conception de matériel",
                        "Compilation de programmes",
                        "Création d'interfaces utilisateur"
                    ],
                    "correctAnswer": 0,
                    "explanation": "L'utilisation des ressources est un aspect clé des performances des systèmes d'E/S, affectant l'efficacité."
                },
                {
                    "id": 47,
                    "topic": "évolution",
                    "question": "Quel était un avantage des systèmes de partage de temps ?",
                    "options": [
                        "Traitement sériel",
                        "Temps de réponse garanti",
                        "Moniteurs résidents",
                        "Systèmes embarqués"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les systèmes de partage de temps offraient un temps de réponse garanti grâce à l'allocation de quanta."
                },
                {
                    "id": 48,
                    "topic": "problèmes_os",
                    "question": "Quel problème concerne la gestion des ressources à mesure que la demande augmente ?",
                    "options": [
                        "Conception de matériel",
                        "Mise à l'échelle des performances",
                        "Création d'interfaces utilisateur",
                        "Compilation de programmes"
                    ],
                    "correctAnswer": 1,
                    "explanation": "La mise à l'échelle des performances est un problème lorsque la demande de ressources augmente."
                },
                {
                    "id": 49,
                    "topic": "services",
                    "question": "Quel service un système d'exploitation fournit-il pour la comptabilité ?",
                    "options": [
                        "Conception de matériel",
                        "Collecte de statistiques sur les performances",
                        "Compilation de programmes",
                        "Création d'interfaces utilisateur"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les systèmes d'exploitation collectent des statistiques sur les performances pour surveiller et anticiper les améliorations."
                },
                {
                    "id": 50,
                    "topic": "communication",
                    "question": "Quel mécanisme de communication utilise des fichiers ?",
                    "options": [
                        "Compilateur",
                        "Tuyaux (pipes)",
                        "Interface graphique",
                        "Programme utilisateur"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les tuyaux (pipes) sont un mécanisme de communication utilisant des fichiers pour transférer des données entre processus."
                },
                {
                    "id": 51,
                    "topic": "introduction",
                    "question": "Quel est un objectif du cours ECS 150 concernant l'évaluation des approches ?",
                    "options": [
                        "Conception de matériel",
                        "Développer une intuition sur les approches système",
                        "Développement d'applications utilisateur",
                        "Configuration réseau"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Le cours vise à développer une intuition sur les approches système qui fonctionnent et celles qui ne fonctionnent pas."
                },
                {
                    "id": 52,
                    "topic": "concepts_os",
                    "question": "Quel est un rôle clé d'un système d'exploitation en tant que gestionnaire de ressources ?",
                    "options": [
                        "Compiler les programmes",
                        "Équilibrer les performances globales et les besoins individuels",
                        "Concevoir des interfaces utilisateur",
                        "Exécuter directement le matériel"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Un système d'exploitation équilibre les performances globales avec les besoins individuels, comme le temps de réponse."
                },
                {
                    "id": 53,
                    "topic": "rôles_os",
                    "question": "Quel est un avantage des systèmes d'exploitation en termes d'équité ?",
                    "options": [
                        "Rest et les périphériques",
                        "Allocation équitable des ressources entre les processus",
                        "Augmenter la complexité",
                        "Restreindre l'accès aux périphériques"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les systèmes d'exploitation assurent une allocation équitable des ressources entre les processus pour maintenir l'équité."
                },
                {
                    "id": 54,
                    "topic": "processus",
                    "question": "Quel est un mécanisme utilisé pour les processus légers ?",
                    "options": [
                        "Compilateur",
                        "Threads",
                        "Interface graphique",
                        "Programme utilisateur"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les threads sont un mécanisme utilisé pour les processus légers, partageant la même mémoire."
                },
                {
                    "id": 55,
                    "topic": "gestion_mémoire",
                    "question": "Quel est un problème associé à la gestion de la mémoire ?",
                    "options": [
                        "Récupération et persistance",
                        "Conception de matériel",
                        "Compilation de programmes",
                        "Création d'interfaces utilisateur"
                    ],
                    "correctAnswer": 0,
                    "explanation": "La récupération et la persistance sont des problèmes de gestion de la mémoire, concernant la sauvegarde et la restauration des données."
                },
                {
                    "id": 56,
                    "topic": "fichiers_es",
                    "question": "Quel est un objectif de la transparence dans les systèmes de fichiers ?",
                    "options": [
                        "Cacher les détails de l'implémentation",
                        "Compiler les programmes",
                        "Concevoir le matériel",
                        "Créer des interfaces utilisateur"
                    ],
                    "correctAnswer": 0,
                    "explanation": "La transparence dans les systèmes de fichiers vise à cacher les détails de l'implémentation pour simplifier l'accès."
                },
                {
                    "id": 57,
                    "topic": "évolution",
                    "question": "Quel était un objectif des systèmes d'exploitation pour PC et stations de travail ?",
                    "options": [
                        "Traitement sériel",
                        "Interfaces graphiques",
                        "Moniteurs résidents",
                        "Systèmes embarqués"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les systèmes d'exploitation pour PC et stations de travail ont introduit des interfaces graphiques pour améliorer l'interaction utilisateur."
                },
                {
                    "id": 58,
                    "topic": "problèmes_os",
                    "question": "Quel problème concerne la découverte des composants dans les systèmes d'exploitation ?",
                    "options": [
                        "Conception de matériel",
                        "Comment les composants se découvrent mutuellement",
                        "Création d'interfaces utilisateur",
                        "Compilation de programmes"
                    ],
                    "correctAnswer": 1,
                    "explanation": "La découverte concerne la manière dont les composants du système d'exploitation et des applications se trouvent et communiquent."
                },
                {
                    "id": 59,
                    "topic": "services",
                    "question": "Quel service un système d'exploitation fournit-il pour l'accès aux fichiers ?",
                    "options": [
                        "Conception de matériel",
                        "Accès contrôlé aux fichiers",
                        "Compilation de programmes",
                        "Création d'interfaces utilisateur"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les systèmes d'exploitation fournissent un accès contrôlé aux fichiers pour assurer la sécurité et l'intégrité."
                },
                {
                    "id": 60,
                    "topic": "communication",
                    "question": "Quel est un aspect de performance de la communication dans les systèmes d'exploitation ?",
                    "options": [
                        "Évolutivité",
                        "Conception de matériel",
                        "Compilation de programmes",
                        "Création de programmes"
                    ],
                    "correctAnswer": 0,
                    "explanation": "L'évolutivité est un aspect de performance clé dans la communication, affectant la capacité à gérer des charges accrues."
                }
            ],
            "true-false": [
                {
                    "id": 61,
                    "topic": "introduction",
                    "question": "Le cours ECS 150 se concentre sur les API spécifiques de Linux et Windows.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. Le cours se concentre sur les concepts généraux des systèmes d'exploitation, pas sur les API spécifiques."
                },
                {
                    "id": 62,
                    "topic": "concepts_os",
                    "question": "Un système d'exploitation agit uniquement comme un gestionnaire de ressources.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. Un système d'exploitation agit également comme une machine étendue, une machine virtuelle et une interface."
                },
                {
                    "id": 63,
                    "topic": "rôles_os",
                    "question": "Les systèmes d'exploitation réduisent la portabilité des applications.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. Les systèmes d'exploitation améliorent la portabilité en permettant aux applications de fonctionner sur différentes architectures."
                },
                {
                    "id": 64,
                    "topic": "processus",
                    "question": "Un processus inclut uniquement le programme en cours d'exécution.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. Un processus inclut le programme, les données associées et le contexte d'exécution."
                },
                {
                    "id": 65,
                    "topic": "gestion_mémoire",
                    "question": "La mémoire virtuelle augmente la mémoire physique disponible.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. La mémoire virtuelle utilise le stockage secondaire pour simuler plus de mémoire, mais n'augmente pas la mémoire physique."
                },
                {
                    "id": 66,
                    "topic": "fichiers_es",
                    "question": "Les systèmes de fichiers sont utilisés uniquement pour le stockage à court terme.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. Les systèmes de fichiers sont conçus pour le stockage d'archives à long terme."
                },
                {
                    "id": 67,
                    "topic": "évolution",
                    "question": "Le traitement sériel utilisait un moniteur résident en mémoire.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. Le traitement sériel n'avait pas de système d'exploitation ni de moniteur résident."
                },
                {
                    "id": 68,
                    "topic": "problèmes_os",
                    "question": "La synchronisation n'est pas nécessaire dans les systèmes d'exploitation.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. La synchronisation est essentielle pour coordonner les activités parallèles et éviter les conflits."
                },
                {
                    "id": 69,
                    "topic": "services",
                    "question": "Les systèmes d'exploitation ne gèrent pas les erreurs matérielles.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. Les systèmes d'exploitation détectent et répondent aux erreurs matérielles, comme les erreurs de mémoire."
                },
                {
                    "id": 70,
                    "topic": "communication",
                    "question": "La communication entre processus utilise toujours des sockets.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. La communication peut utiliser plusieurs mécanismes, comme la mémoire partagée, les tuyaux ou les sockets."
                },
                {
                    "id": 71,
                    "topic": "introduction",
                    "question": "Le cours ECS 150 utilise BSD comme exemple principal.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 0,
                    "explanation": "Vrai. Le cours utilise BSD comme exemple principal pour illustrer les concepts des systèmes d'exploitation."
                },
                {
                    "id": 72,
                    "topic": "concepts_os",
                    "question": "Un système d'exploitation n'intervient jamais sans être explicitement appelé.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. Un système d'exploitation peut intervenir sans appel explicite, par exemple pour gérer les interruptions."
                },
                {
                    "id": 73,
                    "topic": "rôles_os",
                    "question": "Les systèmes d'exploitation augmentent toujours la complexité de la programmation.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. Les systèmes d'exploitation simplifient la programmation grâce à des abstractions et des API de haut niveau."
                },
                {
                    "id": 74,
                    "topic": "processus",
                    "question": "Les threads nécessitent toujours un espace mémoire séparé.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. Les threads partagent le même espace mémoire, contrairement aux processus."
                },
                {
                    "id": 75,
                    "topic": "gestion_mémoire",
                    "question": "La gestion de la mémoire n'inclut pas la protection.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. La gestion de la mémoire inclut la protection et le contrôle d'accès pour assurer la sécurité."
                }
            ],
            "short-answer": [
                {
                    "id": 76,
                    "topic": "introduction",
                    "question": "Décrivez un objectif principal du cours ECS 150 sur les systèmes d'exploitation.",
                    "correctAnswer": ["comprendre", "composants", "systèmes d'exploitation", "théoriques"],
                    "explanation": "Un objectif principal est de comprendre les composants des systèmes d'exploitation modernes et les problèmes théoriques associés à leur construction."
                },
                {
                    "id": 77,
                    "topic": "concepts_os",
                    "question": "Expliquez comment un système d'exploitation agit comme une machine étendue.",
                    "correctAnswer": ["abstraction", "complexité", "opérations", "haut niveau"],
                    "explanation": "Un système d'exploitation agit comme une machine étendue en utilisant l'abstraction pour cacher la complexité, offrant des opérations de haut niveau à partir d'opérations matérielles de bas niveau."
                },
                {
                    "id": 78,
                    "topic": "rôles_os",
                    "question": "Nommez deux avantages utilisateur fournis par un système d'exploitation.",
                    "correctAnswer": ["simplicité", "sécurité", "portabilité", "efficacité"],
                    "explanation": "Les systèmes d'exploitation offrent la simplicité de programmation et la sécurité, entre autres avantages comme la portabilité et l'efficacité."
                },
                {
                    "id": 79,
                    "topic": "processus",
                    "question": "Décrivez les trois composants d'un processus.",
                    "correctAnswer": ["programme", "données", "contexte d'exécution"],
                    "explanation": "Un processus inclut le programme, les données associées nécessaires au programme et le contexte d'exécution, comme les registres et l'état."
                },
                {
                    "id": 80,
                    "topic": "gestion_mémoire",
                    "question": "Expliquez le rôle de la mémoire virtuelle dans la gestion de la mémoire.",
                    "correctAnswer": ["isolation", "pagination", "espace", "virtuel"],
                    "explanation": "La mémoire virtuelle utilise la pagination pour créer un espace d'adressage virtuel, permettant l'isolation des processus et une gestion efficace de la mémoire."
                },
                {
                    "id": 81,
                    "topic": "fichiers_es",
                    "question": "Pourquoi la mise en mémoire tampon est-elle utilisée dans les systèmes d'E/S ?",
                    "correctAnswer": ["réduire", "latence", "performances", "E/S"],
                    "explanation": "La mise en mémoire tampon réduit la latence et améliore les performances des opérations d'entrée/sortie en stockant temporairement les données."
                },
                {
                    "id": 82,
                    "topic": "évolution",
                    "question": "Décrivez une caractéristique des systèmes de traitement par lots.",
                    "correctAnswer": ["moniteur", "résident", "mémoire", "tâches"],
                    "explanation": "Les systèmes de traitement par lots utilisaient un moniteur résident en mémoire principale pour contrôler l'exécution des tâches."
                },
                {
                    "id": 83,
                    "topic": "problèmes_os",
                    "question": "Pourquoi la synchronisation est-elle importante dans les systèmes d'exploitation ?",
                    "correctAnswer": ["coordination", "parallèle", "conflits", "cohérence"],
                    "explanation": "La synchronisation est importante pour coordonner les activités parallèles, éviter les conflits et assurer la cohérence des données."
                },
                {
                    "id": 84,
                    "topic": "services",
                    "question": "Comment un système d'exploitation gère-t-il les erreurs matérielles ?",
                    "correctAnswer": ["détection", "réponse", "erreurs", "matériel"],
                    "explanation": "Un système d'exploitation détecte les erreurs matérielles, comme les erreurs de mémoire, et y répond pour maintenir la stabilité."
                },
                {
                    "id": 85,
                    "topic": "communication",
                    "question": "Décrivez un mécanisme de communication entre processus.",
                    "correctAnswer": ["mémoire", "partagée", "données", "processus"],
                    "explanation": "La mémoire partagée permet aux processus d'échanger des données en accédant à un espace mémoire commun."
                },
                {
                    "id": 86,
                    "topic": "introduction",
                    "question": "Pourquoi le cours ECS 150 utilise-t-il BSD comme exemple ?",
                    "correctAnswer": ["illustrer", "concepts", "BSD", "systèmes"],
                    "explanation": "BSD est utilisé pour illustrer les concepts des systèmes d'exploitation en raison de sa structure claire et de son utilisation académique."
                },
                {
                    "id": 87,
                    "topic": "concepts_os",
                    "question": "Expliquez le rôle d'un système d'exploitation comme interface.",
                    "correctAnswer": ["interface", "applications", "matériel", "services"],
                    "explanation": "Un système d'exploitation agit comme une interface entre les applications et le matériel, fournissant des services simplifiés."
                },
                {
                    "id": 88,
                    "topic": "rôles_os",
                    "question": "Comment un système d'exploitation assure-t-il l'équité ?",
                    "correctAnswer": ["allocation", "ressources", "équitable", "processus"],
                    "explanation": "Un système d'exploitation assure l'équité en allouant les ressources de manière équitable entre les processus."
                },
                {
                    "id": 89,
                    "topic": "processus",
                    "question": "Pourquoi la commutation de contexte est-elle coûteuse ?",
                    "correctAnswer": ["sauvegarde", "restauration", "état", "processus"],
                    "explanation": "La commutation de contexte est coûteuse car elle nécessite la sauvegarde et la restauration de l'état d'un processus, y compris les registres."
                },
                {
                    "id": 90,
                    "topic": "gestion_mémoire",
                    "question": "Décrivez un problème de gestion de la mémoire lié aux défauts de page.",
                    "correctAnswer": ["défauts", "page", "latence", "performances"],
                    "explanation": "Les défauts de page augmentent la latence, car les pages doivent être chargées depuis le stockage, affectant les performances."
                },
                {
                    "id": 91,
                    "topic": "fichiers_es",
                    "question": "Pourquoi la cohérence est-elle un défi dans les systèmes de fichiers ?",
                    "correctAnswer": ["cohérence", "distribué", "accès", "données"],
                    "explanation": "La cohérence est un défi dans les systèmes de fichiers distribués en raison des accès concurrents aux données par plusieurs processus."
                },
                {
                    "id": 92,
                    "topic": "évolution",
                    "question": "Comment les systèmes de partage de temps ont-ils amélioré l'interaction utilisateur ?",
                    "correctAnswer": ["temps", "réponse", "quanta", "partage"],
                    "explanation": "Les systèmes de partage de temps ont amélioré l'interaction utilisateur en garantissant un temps de réponse via l'allocation de quanta."
                },
                {
                    "id": 93,
                    "topic": "problèmes_os",
                    "question": "Comment un système d'exploitation protège-t-il un programme contre un autre ?",
                    "correctAnswer": ["isolation", "mémoire", "accès", "contrôle"],
                    "explanation": "Un système d'exploitation protège les programmes en isolant leur espace mémoire et en contrôlant l'accès aux ressources."
                },
                {
                    "id": 94,
                    "topic": "services",
                    "question": "Quel est le rôle de la comptabilité dans un système d'exploitation ?",
                    "correctAnswer": ["statistiques", "performances", "surveillance", "améliorations"],
                    "explanation": "La comptabilité consiste à collecter des statistiques sur les performances pour surveiller et anticiper les améliorations."
                },
                {
                    "id": 95,
                    "topic": "communication",
                    "question": "Pourquoi la latence est-elle un problème dans la communication entre processus ?",
                    "correctAnswer": ["latence", "délai", "performances", "communication"],
                    "explanation": "La latence introduit des délais dans la communication entre processus, affectant les performances globales."
                },
                {
                    "id": 96,
                    "topic": "introduction",
                    "question": "Quel est un objectif du cours ECS 150 concernant l'intuition ?",
                    "correctAnswer": ["intuition", "approches", "système", "efficacité"],
                    "explanation": "Le cours vise à développer une intuition sur les approches système qui fonctionnent efficacement et celles qui ne fonctionnent pas."
                },
                {
                    "id": 97,
                    "topic": "concepts_os",
                    "question": "Décrivez le concept de virtualisation dans les systèmes d'exploitation.",
                    "correctAnswer": ["virtualisation", "ressources", "CPU", "partage"],
                    "explanation": "La virtualisation permet de fournir des ressources virtuelles, comme un CPU ou une mémoire, pour supporter le partage entre processus."
                },
                {
                    "id": 98,
                    "topic": "rôles_os",
                    "question": "Pourquoi la simplicité de programmation est-elle un objectif des systèmes d'exploitation ?",
                    "correctAnswer": ["simplicité", "API", "développement", "efficace"],
                    "explanation": "La simplicité de programmation, via des API de haut niveau, rend le développement de programmes plus efficace."
                },
                {
                    "id": 99,
                    "topic": "processus",
                    "question": "Comment les systèmes d'exploitation gèrent-ils les processus concurrents ?",
                    "correctAnswer": ["planification", "concurrence", "ressources", "équitable"],
                    "explanation": "Les systèmes d'exploitation gèrent les processus concurrents par une planification équitable des ressources."
                },
                {
                    "id": 100,
                    "topic": "gestion_mémoire",
                    "question": "Pourquoi la hiérarchie de mémoire est-elle utilisée dans la gestion de la mémoire ?",
                    "correctAnswer": ["hiérarchie", "mémoire", "efficacité", "accès"],
                    "explanation": "La hiérarchie de mémoire organise les niveaux de stockage pour optimiser l'efficacité et la vitesse d'accès."
                }
            ]
        },
        "flashcardData": [
            {
                "id": 1,
                "topic": "introduction",
                "front": "Quel est l'objectif principal du cours ECS 150 ?",
                "back": "Comprendre les composants des systèmes d'exploitation modernes et les problèmes théoriques associés."
            },
            {
                "id": 2,
                "topic": "concepts_os",
                "front": "Qu'est-ce qu'une machine étendue dans le contexte des systèmes d'exploitation ?",
                "back": "Un système qui utilise l'abstraction pour cacher la complexité, offrant des opérations de haut niveau."
            },
            {
                "id": 3,
                "topic": "rôles_os",
                "front": "Nommez deux avantages utilisateur des systèmes d'exploitation.",
                "back": "Simplicité de programmation et sécurité."
            },
            {
                "id": 4,
                "topic": "processus",
                "front": "Quels sont les trois composants d'un processus ?",
                "back": "Programme, données associées et contexte d'exécution."
            },
            {
                "id": 5,
                "topic": "gestion_mémoire",
                "front": "Quel est le rôle de la mémoire virtuelle ?",
                "back": "Fournir un espace d'adressage virtuel pour isoler les processus et gérer la mémoire."
            },
            {
                "id": 6,
                "topic": "fichiers_es",
                "front": "Pourquoi utilise-t-on la mise en mémoire tampon dans les systèmes d'E/S ?",
                "back": "Pour réduire la latence et améliorer les performances des opérations d'E/S."
            },
            {
                "id": 7,
                "topic": "évolution",
                "front": "Qu'est-ce qu'un moniteur résident dans les systèmes de traitement par lots ?",
                "back": "Un logiciel en mémoire principale qui contrôle l'exécution des tâches."
            },
            {
                "id": 8,
                "topic": "problèmes_os",
                "front": "Pourquoi la synchronisation est-elle nécessaire dans les systèmes d'exploitation ?",
                "back": "Pour coordonner les activités parallèles et éviter les conflits."
            },
            {
                "id": 9,
                "topic": "services",
                "front": "Quel service un système d'exploitation fournit-il pour les erreurs matérielles ?",
                "back": "Détection et réponse aux erreurs matérielles pour maintenir la stabilité."
            },
            {
                "id": 10,
                "topic": "communication",
                "front": "Qu'est-ce que la mémoire partagée dans la communication entre processus ?",
                "back": "Un espace mémoire commun permettant aux processus d'échanger des données."
            },
            {
                "id": 11,
                "topic": "introduction",
                "front": "Quel système d'exploitation est utilisé comme exemple dans le cours ECS 150 ?",
                "back": "BSD."
            },
            {
                "id": 12,
                "topic": "concepts_os",
                "front": "Quel est le rôle d'un système d'exploitation comme interface ?",
                "back": "Faciliter l'accès aux ressources matérielles pour les applications."
            },
            {
                "id": 13,
                "topic": "rôles_os",
                "front": "Comment un système d'exploitation assure-t-il l'équité ?",
                "back": "En allouant les ressources de manière équitable entre les processus."
            },
            {
                "id": 14,
                "topic": "processus",
                "front": "Pourquoi la commutation de contexte est-elle coûteuse ?",
                "back": "Elle nécessite la sauvegarde et la restauration de l'état d'un processus."
            },
            {
                "id": 15,
                "topic": "gestion_mémoire",
                "front": "Qu'est-ce qu'un défaut de page ?",
                "back": "Une interruption lorsque la page nécessaire n'est pas en mémoire physique."
            },
            {
                "id": 16,
                "topic": "fichiers_es",
                "front": "Qu'est-ce que la transparence dans les systèmes de fichiers ?",
                "back": "Cacher les détails de l'implémentation pour simplifier l'accès."
            },
            {
                "id": 17,
                "topic": "évolution",
                "front": "Quelle était une limitation du traitement sériel ?",
                "back": "Absence de système d'exploitation, nécessitant une configuration manuelle."
            },
            {
                "id": 18,
                "topic": "problèmes_os",
                "front": "Comment un système d'exploitation protège-t-il les programmes ?",
                "back": "En isolant leur espace mémoire et en contrôlant l'accès aux ressources."
            },
            {
                "id": 19,
                "topic": "services",
                "front": "Quel est le rôle de la comptabilité dans un système d'exploitation ?",
                "back": "Collecter des statistiques sur les performances pour surveiller et améliorer."
            },
            {
                "id": 20,
                "topic": "communication",
                "front": "Qu'est-ce que la latence dans la communication entre processus ?",
                "back": "Un délai affectant les performances de la communication."
            },
            {
                "id": 21,
                "topic": "introduction",
                "front": "Quel est un objectif du cours ECS 150 concernant l'implémentation ?",
                "back": "Implémenter des fragments de composants de systèmes d'exploitation."
            },
            {
                "id": 22,
                "topic": "concepts_os",
                "front": "Qu'est-ce que la virtualisation dans les systèmes d'exploitation ?",
                "back": "Fournir des ressources virtuelles comme un CPU ou une mémoire pour le partage."
            },
            {
                "id": 23,
                "topic": "rôles_os",
                "front": "Pourquoi la simplicité de programmation est-elle importante ?",
                "back": "Elle facilite le développement de programmes grâce à des API de haut niveau."
            },
            {
                "id": 24,
                "topic": "processus",
                "front": "Qu'est-ce qu'un thread dans un processus ?",
                "back": "Un fil d'exécution léger partageant la même mémoire que le processus."
            },
            {
                "id": 25,
                "topic": "gestion_mémoire",
                "front": "Qu'est-ce que la hiérarchie de mémoire ?",
                "back": "Une organisation des niveaux de stockage pour optimiser l'accès."
            },
            {
                "id": 26,
                "topic": "fichiers_es",
                "front": "Pourquoi la cohérence est-elle importante dans les systèmes de fichiers ?",
                "back": "Pour éviter les conflits lors d'accès concurrents dans les systèmes distribués."
            },
            {
                "id": 27,
                "topic": "évolution",
                "front": "Qu'est-ce que le partage de temps dans les systèmes d'exploitation ?",
                "back": "Une allocation de quanta pour garantir un temps de réponse aux utilisateurs."
            },
            {
                "id": 28,
                "topic": "problèmes_os",
                "front": "Qu'est-ce que la découverte des composants dans un système d'exploitation ?",
                "back": "Le processus par lequel les composants se trouvent et communiquent."
            },
            {
                "id": 29,
                "topic": "services",
                "front": "Quel service un système d'exploitation fournit-il pour l'accès aux fichiers ?",
                "back": "Un accès contrôlé pour assurer la sécurité et l'intégrité."
            },
            {
                "id": 30,
                "topic": "communication",
                "front": "Qu'est-ce qu'un tuyau (pipe) dans la communication ?",
                "back": "Un mécanisme utilisant des fichiers pour transférer des données entre processus."
            },
            {
                "id": 31,
                "topic": "introduction",
                "front": "Quel est un thème organisationnel du cours ECS 150 ?",
                "back": "Les composants des systèmes d'exploitation et leurs problèmes."
            },
            {
                "id": 32,
                "topic": "concepts_os",
                "front": "Pourquoi un système d'exploitation est-il comparé à une bibliothèque ?",
                "back": "Il fournit des services, parfois sans appel explicite."
            },
            {
                "id": 33,
                "topic": "rôles_os",
                "front": "Comment un système d'exploitation améliore-t-il l'efficacité ?",
                "back": "En optimisant l'utilisation des ressources comme le CPU et la mémoire."
            },
            {
                "id": 34,
                "topic": "processus",
                "front": "Qu'est-ce que la planification équitable dans la gestion des processus ?",
                "back": "Une allocation juste des ressources pour tous les processus."
            },
            {
                "id": 35,
                "topic": "gestion_mémoire",
                "front": "Qu'est-ce que la pagination dans la mémoire virtuelle ?",
                "back": "Une technique divisant la mémoire en pages pour une gestion efficace."
            },
            {
                "id": 36,
                "topic": "fichiers_es",
                "front": "Qu'est-ce que la mise en mémoire tampon dans les systèmes d'E/S ?",
                "back": "Un stockage temporaire des données pour réduire la latence."
            },
            {
                "id": 37,
                "topic": "évolution",
                "front": "Qu'est-ce que la multiprogrammation dans les systèmes d'exploitation ?",
                "back": "Le chevauchement des opérations CPU et E/S pour améliorer l'efficacité."
            },
            {
                "id": 38,
                "topic": "problèmes_os",
                "front": "Pourquoi la protection est-elle importante dans les systèmes d'exploitation ?",
                "back": "Pour assurer l'intégrité du système et des ressources."
            },
            {
                "id": 39,
                "topic": "services",
                "front": "Quel service un système d'exploitation fournit-il pour l'exécution des programmes ?",
                "back": "Un accès contrôlé aux périphériques d'E/S."
            },
            {
                "id": 40,
                "topic": "communication",
                "front": "Qu'est-ce que l'appel de procédure à distance (RPC) ?",
                "back": "Un protocole permettant à un processus d'appeler une procédure sur un autre nœud."
            },
            {
                "id": 41,
                "topic": "introduction",
                "front": "Pourquoi le cours ECS 150 met-il l'accent sur les concepts ?",
                "back": "Pour comprendre la conception et la mise en œuvre des systèmes d'exploitation."
            },
            {
                "id": 42,
                "topic": "concepts_os",
                "front": "Qu'est-ce qu'un gestionnaire de ressources dans un système d'exploitation ?",
                "back": "Un système contrôlant l'accès aux ressources comme le CPU et la mémoire."
            },
            {
                "id": 43,
                "topic": "rôles_os",
                "front": "Comment un système d'exploitation assure-t-il la portabilité ?",
                "back": "En permettant aux applications de fonctionner sur différentes architectures."
            },
            {
                "id": 44,
                "topic": "processus",
                "front": "Qu'est-ce qu'un événement dans le contexte des processus ?",
                "back": "Une action déclenchant une réponse dans un processus."
            },
            {
                "id": 45,
                "topic": "gestion_mémoire",
                "front": "Qu'est-ce que le remplacement de cache dans la gestion de la mémoire ?",
                "back": "Le processus de remplacement des données en cache pour optimiser l'accès."
            },
            {
                "id": 46,
                "topic": "fichiers_es",
                "front": "Qu'est-ce que la partition des données dans les systèmes de fichiers ?",
                "back": "La division des données pour optimiser le stockage et l'accès."
            },
            {
                "id": 47,
                "topic": "évolution",
                "front": "Qu'est-ce qu'un système d'exploitation en temps réel ?",
                "back": "Un système garantissant des réponses dans des délais stricts."
            },
            {
                "id": 48,
                "topic": "problèmes_os",
                "front": "Qu'est-ce que la mise à l'échelle dans la gestion des ressources ?",
                "back": "La capacité à gérer des demandes accrues de ressources."
            },
            {
                "id": 49,
                "topic": "services",
                "front": "Quel service un système d'exploitation fournit-il pour le contrôle d'accès ?",
                "back": "Un contrôle pour garantir une utilisation sécurisée et équitable des ressources."
            },
            {
                "id": 50,
                "topic": "communication",
                "front": "Qu'est-ce que la communication de groupe dans les systèmes d'exploitation ?",
                "back": "Un modèle comme un-à-plusieurs ou plusieurs-à-un pour l'échange de données."
            }
        ]
    },
    "processus": {
        "name": "Processus (ECS 150)",
        "description": "Introduction aux concepts fondamentaux des systèmes d'exploitation, avec un focus sur la gestion des processus",
        "topics": {
            "introduction": { "name": "Introduction aux Processus" },
            "representation_processus": { "name": "Représentation des Processus" },
            "etats_processus": { "name": "États des Processus" },
            "creation_processus": { "name": "Création des Processus" },
            "gestion_processus": { "name": "Gestion des Processus" },
            "signaux": { "name": "Signaux et Communication" },
            "virtualisation_cpu": { "name": "Virtualisation du Processeur" },
            "optimisation_creation": { "name": "Optimisation de la Création de Processus" },
            "suspension_processus": { "name": "Suspension et Réactivation des Processus" },
            "terminaison_processus": { "name": "Terminaison des Processus" }
        },
        "quizData": {
            "multiple-choice": [
            {
                "id": 1,
                "topic": "basics",
                "question": "Quel est le rôle principal d'un processus dans un système d'exploitation ?",
                "options": [
                "Gérer les périphériques matériels directement",
                "Servir d'abstraction pour la virtualisation, l'exécution et la planification",
                "Stocker les données utilisateur de manière permanente",
                "Contrôler l'interface graphique du système"
                ],
                "correctAnswer": 1,
                "explanation": "Un processus est une abstraction fondamentale du système d'exploitation pour la virtualisation, servant d'unité d'exécution, de planification et d'allocation des ressources."
            },
            {
                "id": 2,
                "topic": "representation",
                "question": "Quel composant n'est PAS typiquement inclus dans l'espace d'adressage d'un processus ?",
                "options": [
                "Segment de code (texte)",
                "Segment de données",
                "Pile",
                "Bande passante réseau"
                ],
                "correctAnswer": 3,
                "explanation": "L'espace d'adressage inclut le code, les données et la pile, mais la bande passante réseau est une ressource externe gérée par le système d'exploitation."
            },
            {
                "id": 3,
                "topic": "management",
                "question": "Quel est le rôle du Bloc de Contrôle de Processus (PCB) ?",
                "options": [
                "Stocker les paramètres d'interface utilisateur",
                "Maintenir l'état d'exécution et les métadonnées d'un processus",
                "Allouer la mémoire aux périphériques",
                "Gérer la hiérarchie des fichiers"
                ],
                "correctAnswer": 1,
                "explanation": "Le PCB stocke des informations comme le compteur de programme, les registres et l'état du processus pour permettre sa gestion."
            },
            {
                "id": 4,
                "topic": "states",
                "question": "Dans le modèle à cinq états, quel état indique qu'un processus attend un événement comme une opération d'E/S ?",
                "options": [
                "En cours",
                "Prêt",
                "Bloqué",
                "Nouveau"
                ],
                "correctAnswer": 2,
                "explanation": "L'état Bloqué indique qu'un processus attend un événement, comme la fin d'une opération d'E/S, et ne peut progresser tant que l'événement n'a pas lieu."
            },
            {
                "id": 5,
                "topic": "management",
                "question": "Qu'est-ce qu'un changement de contexte (context switch) ?",
                "options": [
                "Création d'un nouveau processus avec un PID unique",
                "Passage du CPU d'un processus à un autre avec sauvegarde et restauration des états",
                "Termination d'un processus et libération de son PCB",
                "Copie de l'espace d'adressage d'un processus sur le disque"
                ],
                "correctAnswer": 1,
                "explanation": "Un changement de contexte sauvegarde l'état du processus courant dans son PCB et charge l'état d'un autre processus dans le CPU."
            },
            {
                "id": 6,
                "topic": "creation",
                "question": "Comment fonctionne l'appel système fork() dans UNIX ?",
                "options": [
                "Il charge un nouveau programme dans l'espace d'adressage",
                "Il crée un processus en copiant l'espace d'adressage du parent",
                "Il termine le processus parent",
                "Il suspend le processus jusqu'à la fin du fils"
                ],
                "correctAnswer": 1,
                "explanation": "Fork() crée un processus fils avec une copie de l'espace d'adressage du parent, retournant le PID du fils au parent et 0 au fils."
            },
            {
                "id": 7,
                "topic": "creation",
                "question": "Quelle est la différence principale entre fork() et exec() dans UNIX ?",
                "options": [
                "Fork() charge un programme, exec() crée un processus",
                "Fork() crée un processus, exec() remplace l'espace d'adressage",
                "Fork() termine un processus, exec() le suspend",
                "Fork() et exec() créent des processus avec des PID différents"
                ],
                "correctAnswer": 1,
                "explanation": "Fork() duplique le processus parent, tandis que exec() remplace l'image du processus courant par un nouveau programme."
            },
            {
                "id": 8,
                "topic": "creation",
                "question": "Quel est l'objectif de la copie sur écriture (copy-on-write) ?",
                "options": [
                "Copier immédiatement tout l'espace d'adressage",
                "Partager l'espace d'adressage, copier les pages modifiées",
                "Suspendre le processus fils",
                "Allouer une nouvelle mémoire physique"
                ],
                "correctAnswer": 1,
                "explanation": "La copie sur écriture optimise fork() en partageant l'espace d'adressage et en copiant uniquement les pages modifiées."
            },
            {
                "id": 9,
                "topic": "management",
                "question": "Pourquoi un processus peut-il être suspendu ?",
                "options": [
                "Pour allouer plus de temps CPU",
                "Pour libérer la mémoire en l'échangeant sur le disque",
                "Pour le terminer définitivement",
                "Pour augmenter sa priorité"
                ],
                "correctAnswer": 1,
                "explanation": "La suspension libère la mémoire principale en déplaçant le processus sur le disque."
            },
            {
                "id": 10,
                "topic": "signals",
                "question": "Quel signal est envoyé lors d'un accès mémoire invalide ?",
                "options": [
                "SIGKILL",
                "SIGSEGV",
                "SIGFPE",
                "SIGTERM"
                ],
                "correctAnswer": 1,
                "explanation": "SIGSEGV (segmentation violation) est déclenché lorsqu'un processus accède à une mémoire non autorisée."
            },
            {
                "id": 11,
                "topic": "states",
                "question": "Quel est l'état d'un processus prêt à s'exécuter mais attendant le CPU ?",
                "options": [
                "En cours",
                "Prêt",
                "Bloqué",
                "Terminé"
                ],
                "correctAnswer": 1,
                "explanation": "Un processus dans l'état Prêt est prêt à s'exécuter mais attend l'attribution du CPU."
            },
            {
                "id": 12,
                "topic": "representation",
                "question": "Qu'est-ce qu'un identifiant de processus (PID) ?",
                "options": [
                "Un nom pour un fichier",
                "Un entier unique attribué à chaque processus",
                "Une adresse mémoire pour le PCB",
                "Un signal de terminaison"
                ],
                "correctAnswer": 1,
                "explanation": "Le PID est un identifiant unique pour gérer et référencer les processus."
            },
            {
                "id": 13,
                "topic": "management",
                "question": "Quel est l'effet de l'appel système kill() ?",
                "options": [
                "Suspendre un processus",
                "Envoyer un signal au processus",
                "Créer un nouveau processus",
                "Copier l'espace d'adressage"
                ],
                "correctAnswer": 1,
                "explanation": "Kill() envoie un signal, comme SIGTERM ou SIGKILL, pour influencer le comportement du processus."
            },
            {
                "id": 14,
                "topic": "signals",
                "question": "Comment les signaux synchrones diffèrent-ils des asynchrones ?",
                "options": [
                "Synchrones envoyés par le système, asynchrones par les utilisateurs",
                "Synchrones dus aux actions du programme, asynchrones par des événements externes",
                "Synchrones terminent le processus, asynchrones non",
                "Synchrones gérés par le noyau, asynchrones par l'utilisateur"
                ],
                "correctAnswer": 1,
                "explanation": "Les signaux synchrones, comme SIGFPE, sont dus à des erreurs internes, tandis que les asynchrones, comme SIGINT, viennent de l'extérieur."
            },
            {
                "id": 15,
                "topic": "creation",
                "question": "Pourquoi utilise-t-on vfork() au lieu de fork() ?",
                "options": [
                "Vfork() est plus lent mais plus sûr",
                "Vfork() évite de copier l'espace d'adressage",
                "Vfork() termine le processus parent",
                "Vfork() alloue plus de mémoire"
                ],
                "correctAnswer": 1,
                "explanation": "Vfork() partage l'espace d'adressage du parent, évitant la copie jusqu'à un appel exec()."
            },
            {
                "id": 16,
                "topic": "management",
                "question": "Qu'est-ce qu'une file d'état ?",
                "options": [
                "Un répertoire pour les fichiers",
                "Une structure pour organiser les PCB par état",
                "Une liste de périphériques d'E/S",
                "Un mécanisme de copie d'adressage"
                ],
                "correctAnswer": 1,
                "explanation": "Les files d'état organisent les PCB selon l'état des processus (prêt, bloqué, etc.)."
            },
            {
                "id": 17,
                "topic": "basics",
                "question": "Quel est l'objectif de la virtualisation du processeur ?",
                "options": [
                "Allouer plus de mémoire physique",
                "Intercaler l'exécution de processus pour maximiser l'utilisation du CPU",
                "Créer des copies physiques du CPU",
                "Limiter l'accès aux périphériques"
                ],
                "correctAnswer": 1,
                "explanation": "La virtualisation permet à plusieurs processus de partager le CPU efficacement."
            },
            {
                "id": 18,
                "topic": "creation",
                "question": "Que se passe-t-il lorsqu'un processus est créé via fork() ?",
                "options": [
                "Le processus parent est terminé",
                "Un nouveau PCB est alloué et placé dans la file Prêt",
                "L'espace d'adressage est effacé",
                "Le processus est suspendu"
                ],
                "correctAnswer": 1,
                "explanation": "Fork() alloue un nouveau PCB, copie l'espace d'adressage, et place le PCB dans la file Prêt."
            },
            {
                "id": 19,
                "topic": "states",
                "question": "Quand un processus passe-t-il de En cours à Bloqué ?",
                "options": [
                "Lorsqu'il termine son exécution",
                "Lorsqu'il attend un événement comme une E/S",
                "Lorsqu'il est prêt à s'exécuter",
                "Lorsqu'il est suspendu"
                ],
                "correctAnswer": 1,
                "explanation": "Un processus passe à Bloqué lorsqu'il attend un événement externe, comme une opération d'E/S."
            },
            {
                "id": 20,
                "topic": "representation",
                "question": "Quel élément du PCB stocke l'état actuel du processeur ?",
                "options": [
                "Identifiant de processus",
                "Compteur de programme",
                "Tableau des descripteurs de fichiers",
                "Priorité de planification"
                ],
                "correctAnswer": 1,
                "explanation": "Le compteur de programme et les registres dans le PCB stockent l'état du processeur."
            },
            {
                "id": 21,
                "topic": "signals",
                "question": "Quel signal force la terminaison d'un processus sans possibilité de gestion ?",
                "options": [
                "SIGTERM",
                "SIGKILL",
                "SIGINT",
                "SIGSEGV"
                ],
                "correctAnswer": 1,
                "explanation": "SIGKILL termine immédiatement un processus sans permettre de gestion par celui-ci."
            },
            {
                "id": 22,
                "topic": "management",
                "question": "Quel mécanisme permet de gérer plusieurs processus bloqués ?",
                "options": [
                "Files d'attente multiples",
                "Espace d'adressage partagé",
                "Signaux synchrones",
                "Copie sur écriture"
                ],
                "correctAnswer": 0,
                "explanation": "Les files d'attente multiples organisent les processus bloqués par type d'événement."
            },
            {
                "id": 23,
                "topic": "creation",
                "question": "Quel appel système remplace l'image d'un processus par un nouveau programme ?",
                "options": [
                "Fork()",
                "Exec()",
                "Wait()",
                "Kill()"
                ],
                "correctAnswer": 1,
                "explanation": "Exec() remplace l'espace d'adressage du processus courant par un nouveau programme."
            },
            {
                "id": 24,
                "topic": "states",
                "question": "Quel état suit la terminaison d'un processus ?",
                "options": [
                "Prêt",
                "Bloqué",
                "Terminé",
                "Suspendu"
                ],
                "correctAnswer": 2,
                "explanation": "L'état Terminé indique que le processus a fini son exécution et attend la libération de ses ressources."
            },
            {
                "id": 25,
                "topic": "management",
                "question": "Quel est l'effet de l'échange (swapping) d'un processus ?",
                "options": [
                "Augmenter sa priorité",
                "Libérer la mémoire principale",
                "Créer un nouveau processus",
                "Terminer le processus"
                ],
                "correctAnswer": 1,
                "explanation": "L'échange déplace un processus vers le disque pour libérer la mémoire principale."
            },
            {
                "id": 26,
                "topic": "representation",
                "question": "Quel élément du PCB contient les informations sur les fichiers ouverts ?",
                "options": [
                "Compteur de programme",
                "Tableau des descripteurs de fichiers",
                "Registre d'état",
                "Identifiant de processus"
                ],
                "correctAnswer": 1,
                "explanation": "Le tableau des descripteurs de fichiers dans le PCB gère les fichiers ouverts par le processus."
            },
            {
                "id": 27,
                "topic": "signals",
                "question": "Quel signal est envoyé lors d'une erreur arithmétique comme une division par zéro ?",
                "options": [
                "SIGFPE",
                "SIGSEGV",
                "SIGTERM",
                "SIGKILL"
                ],
                "correctAnswer": 0,
                "explanation": "SIGFPE (Floating Point Exception) est déclenché pour des erreurs arithmétiques."
            },
            {
                "id": 28,
                "topic": "creation",
                "question": "Quel appel système permet à un parent d'attendre la fin de son processus fils ?",
                "options": [
                "Fork()",
                "Exec()",
                "Wait()",
                "Kill()"
                ],
                "correctAnswer": 2,
                "explanation": "Wait() permet au processus parent de se bloquer jusqu'à ce que le processus fils termine."
            },
            {
                "id": 29,
                "topic": "states",
                "question": "Quel état précède l'exécution d'un processus ?",
                "options": [
                "Bloqué",
                "Prêt",
                "Terminé",
                "Suspendu"
                ],
                "correctAnswer": 1,
                "explanation": "Un processus doit être dans l'état Prêt avant de passer à l'état En cours pour s'exécuter."
            },
            {
                "id": 30,
                "topic": "management",
                "question": "Quel mécanisme optimise la création de processus en UNIX ?",
                "options": [
                "Signaux asynchrones",
                "Copie sur écriture",
                "Files d'attente uniques",
                "Changement de contexte"
                ],
                "correctAnswer": 1,
                "explanation": "La copie sur écriture réduit les coûts de création en partageant l'espace d'adressage."
            },
            {
                "id": 31,
                "topic": "representation",
                "question": "Quel élément du PCB détermine l'ordre d'exécution des processus ?",
                "options": [
                "Priorité de planification",
                "Compteur de programme",
                "Identifiant de processus",
                "Tableau des fichiers"
                ],
                "correctAnswer": 0,
                "explanation": "La priorité de planification dans le PCB influence l'ordre d'exécution des processus."
            },
            {
                "id": 32,
                "topic": "signals",
                "question": "Quel signal permet une terminaison gracieuse d'un processus ?",
                "options": [
                "SIGKILL",
                "SIGTERM",
                "SIGSEGV",
                "SIGFPE"
                ],
                "correctAnswer": 1,
                "explanation": "SIGTERM demande une terminaison gracieuse, permettant au processus de nettoyer ses ressources."
            },
            {
                "id": 33,
                "topic": "creation",
                "question": "Quel appel système est souvent utilisé après fork() pour charger un programme ?",
                "options": [
                "Wait()",
                "Kill()",
                "Exec()",
                "Fork()"
                ],
                "correctAnswer": 2,
                "explanation": "Exec() est souvent appelé après fork() pour remplacer l'image du processus fils."
            },
            {
                "id": 34,
                "topic": "states",
                "question": "Quel état indique qu'un processus n'a pas encore été admis par le système ?",
                "options": [
                "Nouveau",
                "Prêt",
                "Bloqué",
                "En cours"
                ],
                "correctAnswer": 0,
                "explanation": "L'état Nouveau indique qu'un processus est créé mais pas encore admis."
            },
            {
                "id": 35,
                "topic": "management",
                "question": "Quel est l'effet de la préemption d'un processus ?",
                "options": [
                "Il est terminé",
                "Il passe de En cours à Prêt",
                "Il est suspendu sur le disque",
                "Il est bloqué pour une E/S"
                ],
                "correctAnswer": 1,
                "explanation": "La préemption ramène un processus de En cours à Prêt pour permettre à un autre de s'exécuter."
            },
            {
                "id": 36,
                "topic": "representation",
                "question": "Quel élément du PCB contient l'adresse de la prochaine instruction ?",
                "options": [
                "Identifiant de processus",
                "Compteur de programme",
                "Priorité de planification",
                "Tableau des fichiers"
                ],
                "correctAnswer": 1,
                "explanation": "Le compteur de programme indique l'adresse de la prochaine instruction à exécuter."
            },
            {
                "id": 37,
                "topic": "signals",
                "question": "Quel signal est déclenché par une interruption clavier (Ctrl+C) ?",
                "options": [
                "SIGKILL",
                "SIGTERM",
                "SIGINT",
                "SIGSEGV"
                ],
                "correctAnswer": 2,
                "explanation": "SIGINT est envoyé lorsqu'un utilisateur interrompt un processus via Ctrl+C."
            },
            {
                "id": 38,
                "topic": "creation",
                "question": "Quel appel système crée un processus sans copier l'espace d'adressage ?",
                "options": [
                "Fork()",
                "Vfork()",
                "Exec()",
                "Wait()"
                ],
                "correctAnswer": 1,
                "explanation": "Vfork() crée un processus en partageant l'espace d'adressage du parent."
            },
            {
                "id": 39,
                "topic": "states",
                "question": "Quel état suit l'admission d'un processus par le système ?",
                "options": [
                "En cours",
                "Prêt",
                "Bloqué",
                "Nouveau"
                ],
                "correctAnswer": 1,
                "explanation": "Un processus admis passe de Nouveau à Prêt, attendant l'allocation du CPU."
            },
            {
                "id": 40,
                "topic": "management",
                "question": "Quel mécanisme gère les processus en attente d'événements différents ?",
                "options": [
                "File d'attente unique",
                "Files d'attente multiples",
                "Copie sur écriture",
                "Signaux synchrones"
                ],
                "correctAnswer": 1,
                "explanation": "Les files d'attente multiples organisent les processus par type d'événement attendu."
            },
            {
                "id": 41,
                "topic": "representation",
                "question": "Quel élément du PCB stocke les informations de sécurité ?",
                "options": [
                "Identifiant d'utilisateur",
                "Compteur de programme",
                "Registre d'état",
                "Priorité de planification"
                ],
                "correctAnswer": 0,
                "explanation": "L'identifiant d'utilisateur dans le PCB gère les permissions et la sécurité."
            },
            {
                "id": 42,
                "topic": "signals",
                "question": "Quel signal est utilisé pour demander une suspension temporaire ?",
                "options": [
                "SIGSTOP",
                "SIGKILL",
                "SIGTERM",
                "SIGSEGV"
                ],
                "correctAnswer": 0,
                "explanation": "SIGSTOP suspend temporairement un processus sans le terminer."
            },
            {
                "id": 43,
                "topic": "creation",
                "question": "Quel appel système récupère le PID d'un processus ?",
                "options": [
                "Getpid()",
                "Fork()",
                "Exec()",
                "Wait()"
                ],
                "correctAnswer": 0,
                "explanation": "Getpid() retourne l'identifiant de processus du processus courant."
            },
            {
                "id": 44,
                "topic": "states",
                "question": "Quel état indique qu'un processus est en mémoire secondaire ?",
                "options": [
                "Prêt",
                "Bloqué",
                "Suspendu",
                "En cours"
                ],
                "correctAnswer": 2,
                "explanation": "L'état Suspendu indique qu'un processus a été déplacé vers la mémoire secondaire."
            },
            {
                "id": 45,
                "topic": "management",
                "question": "Quel mécanisme permet de reprendre un processus suspendu ?",
                "options": [
                "Réactivation",
                "Préemption",
                "Terminaison",
                "Blocage"
                ],
                "correctAnswer": 0,
                "explanation": "La réactivation ramène un processus suspendu en mémoire principale."
            },
            {
                "id": 46,
                "topic": "representation",
                "question": "Quel élément du PCB suit l'utilisation des ressources ?",
                "options": [
                "Compteur de programme",
                "Statistiques d'exécution",
                "Identifiant de processus",
                "Tableau des fichiers"
                ],
                "correctAnswer": 1,
                "explanation": "Les statistiques d'exécution dans le PCB suivent l'utilisation des ressources."
            },
            {
                "id": 47,
                "topic": "signals",
                "question": "Quel signal reprend un processus suspendu ?",
                "options": [
                "SIGCONT",
                "SIGSTOP",
                "SIGKILL",
                "SIGTERM"
                ],
                "correctAnswer": 0,
                "explanation": "SIGCONT reprend l'exécution d'un processus suspendu."
            },
            {
                "id": 48,
                "topic": "creation",
                "question": "Quel appel système retourne le PID du parent ?",
                "options": [
                "Getpid()",
                "Getppid()",
                "Fork()",
                "Exec()"
                ],
                "correctAnswer": 1,
                "explanation": "Getppid() retourne l'identifiant du processus parent."
            },
            {
                "id": 49,
                "topic": "states",
                "question": "Quel état précède la suspension d'un processus ?",
                "options": [
                "Prêt ou Bloqué",
                "En cours uniquement",
                "Terminé",
                "Nouveau"
                ],
                "correctAnswer": 0,
                "explanation": "Un processus peut être suspendu depuis les états Prêt ou Bloqué."
            },
            {
                "id": 50,
                "topic": "management",
                "question": "Quel mécanisme libère les ressources d'un processus terminé ?",
                "options": [
                "Changement de contexte",
                "Réactivation",
                "Nettoyage",
                "Préemption"
                ],
                "correctAnswer": 2,
                "explanation": "Le nettoyage libère les ressources, comme le PCB, d'un processus terminé."
            }
            ],
            "true-false": [
            {
                "id": 51,
                "topic": "basics",
                "question": "Un processus est une instance statique d'un programme.",
                "options": ["Vrai", "Faux"],
                "correctAnswer": 1,
                "explanation": "Faux. Un processus est une instance dynamique d'un programme en exécution, incluant son état et ses ressources."
            },
            {
                "id": 52,
                "topic": "representation",
                "question": "L'espace d'adressage d'un processus inclut les périphériques d'E/S.",
                "options": ["Vrai", "Faux"],
                "correctAnswer": 1,
                "explanation": "Faux. L'espace d'adressage inclut le code, les données, la pile et le tas, mais pas les périphériques d'E/S."
            },
            {
                "id": 53,
                "topic": "management",
                "question": "Le PCB est mis à jour à chaque changement d'état d'un processus.",
                "options": ["Vrai", "Faux"],
                "correctAnswer": 0,
                "explanation": "Vrai. Le PCB est mis à jour pour refléter l'état actuel, comme En cours, Prêt ou Bloqué."
            },
            {
                "id": 54,
                "topic": "states",
                "question": "Un processus peut passer directement de Nouveau à En cours.",
                "options": ["Vrai", "Faux"],
                "correctAnswer": 1,
                "explanation": "Faux. Un processus passe d'abord par l'état Prêt avant d'être exécuté."
            },
            {
                "id": 55,
                "topic": "creation",
                "question": "Fork() crée un processus identique au parent.",
                "options": ["Vrai", "Faux"],
                "correctAnswer": 0,
                "explanation": "Vrai. Fork() crée un processus fils avec une copie de l'espace d'adressage du parent."
            },
            {
                "id": 56,
                "topic": "creation",
                "question": "Exec() modifie le PID du processus.",
                "options": ["Vrai", "Faux"],
                "correctAnswer": 1,
                "explanation": "Faux. Exec() remplace l'image du processus mais conserve son PID."
            },
            {
                "id": 57,
                "topic": "management",
                "question": "Un changement de contexte est toujours déclenché par une interruption.",
                "options": ["Vrai", "Faux"],
                "correctAnswer": 1,
                "explanation": "Faux. Un changement de contexte peut être déclenché par une interruption ou une décision du planificateur."
            },
            {
                "id": 58,
                "topic": "signals",
                "question": "Tous les signaux terminent un processus.",
                "options": ["Vrai", "Faux"],
                "correctAnswer": 1,
                "explanation": "Faux. Certains signaux, comme SIGSTOP, suspendent un processus, tandis que d'autres peuvent être gérés."
            },
            {
                "id": 59,
                "topic": "states",
                "question": "Un processus bloqué peut passer directement à En cours.",
                "options": ["Vrai", "Faux"],
                "correctAnswer": 1,
                "explanation": "Faux. Un processus bloqué passe d'abord à Prêt après que l'événement attendu a lieu."
            },
            {
                "id": 60,
                "topic": "representation",
                "question": "Le PCB est stocké dans la mémoire utilisateur.",
                "options": ["Vrai", "Faux"],
                "correctAnswer": 1,
                "explanation": "Faux. Le PCB est stocké dans la mémoire du noyau pour des raisons de sécurité."
            },
            {
                "id": 61,
                "topic": "creation",
                "question": "Vfork() est plus sûr que fork() pour la création de processus.",
                "options": ["Vrai", "Faux"],
                "correctAnswer": 1,
                "explanation": "Faux. Vfork() est plus rapide mais moins sûr car le fils partage l'espace d'adressage du parent."
            },
            {
                "id": 62,
                "topic": "management",
                "question": "La suspension d'un processus libère toujours la mémoire principale.",
                "options": ["Vrai", "Faux"],
                "correctAnswer": 0,
                "explanation": "Vrai. La suspension déplace le processus vers le disque, libérant la mémoire principale."
            },
            {
                "id": 63,
                "topic": "signals",
                "question": "SIGKILL peut être géré par un processus.",
                "options": ["Vrai", "Faux"],
                "correctAnswer": 1,
                "explanation": "Faux. SIGKILL termine un processus immédiatement sans possibilité de gestion."
            },
            {
                "id": 64,
                "topic": "states",
                "question": "Un processus peut être suspendu depuis l'état Terminé.",
                "options": ["Vrai", "Faux"],
                "correctAnswer": 1,
                "explanation": "Faux. Un processus terminé ne peut pas être suspendu, car il a fini son exécution."
            },
            {
                "id": 65,
                "topic": "representation",
                "question": "Le PID est unique dans tout le système.",
                "options": ["Vrai", "Faux"],
                "correctAnswer": 0,
                "explanation": "Vrai. Chaque processus a un PID unique dans l'espace de noms global."
            },
            {
                "id": 66,
                "topic": "creation",
                "question": "Fork() copie toujours immédiatement l'espace d'adressage.",
                "options": ["Vrai", "Faux"],
                "correctAnswer": 1,
                "explanation": "Faux. Avec la copie sur écriture, les pages ne sont copiées que lorsqu'elles sont modifiées."
            },
            {
                "id": 67,
                "topic": "management",
                "question": "Les files d'attente multiples sont utilisées pour tous les processus.",
                "options": ["Vrai", "Faux"],
                "correctAnswer": 1,
                "explanation": "Faux. Les files d'attente multiples sont principalement utilisées pour les processus bloqués."
            },
            {
                "id": 68,
                "topic": "signals",
                "question": "Les signaux synchrones sont toujours déclenchés par le noyau.",
                "options": ["Vrai", "Faux"],
                "correctAnswer": 0,
                "explanation": "Vrai. Les signaux synchrones, comme SIGSEGV, sont générés par le noyau en réponse aux actions du programme."
            },
            {
                "id": 69,
                "topic": "states",
                "question": "Un processus peut rester indéfiniment dans l'état Prêt.",
                "options": ["Vrai", "Faux"],
                "correctAnswer": 0,
                "explanation": "Vrai. Un processus peut rester dans l'état Prêt si le CPU n'est pas attribué."
            },
            {
                "id": 70,
                "topic": "representation",
                "question": "Le PCB contient des informations sur les threads du processus.",
                "options": ["Vrai", "Faux"],
                "correctAnswer": 0,
                "explanation": "Vrai. Dans certains systèmes, le PCB inclut des informations sur les threads associés."
            }
            ],
            "short-answer": [
            {
                "id": 71,
                "topic": "representation",
                "question": "Quels sont les principaux éléments de l'espace d'adressage d'un processus ?",
                "correctAnswer": ["code", "données", "pile", "tas"],
                "explanation": "L'espace d'adressage inclut le segment de code (texte), les données, la pile pour les appels de fonctions, et le tas pour l'allocation dynamique."
            },
            {
                "id": 72,
                "topic": "management",
                "question": "Décrivez le rôle du PCB dans la gestion des processus.",
                "correctAnswer": ["état", "métadonnées", "gestion", "ressources"],
                "explanation": "Le PCB stocke l'état d'exécution, les registres, le PID, et d'autres métadonnées pour gérer les processus et leurs ressources."
            },
            {
                "id": 73,
                "topic": "states",
                "question": "Quand un processus passe-t-il de l'état En cours à Bloqué ?",
                "correctAnswer": ["attente", "événement", "E/S"],
                "explanation": "Un processus passe à l'état Bloqué lorsqu'il attend un événement externe, comme la fin d'une opération d'E/S."
            },
            {
                "id": 74,
                "topic": "creation",
                "question": "Expliquez comment fork() crée un processus.",
                "correctAnswer": ["copie", "espace d'adressage", "PCB", "Prêt"],
                "explanation": "Fork() crée un nouveau PCB, copie l'espace d'adressage du parent, initialise les ressources du fils, et place le PCB dans la file Prêt."
            },
            {
                "id": 75,
                "topic": "creation",
                "question": "Quel est l'effet de l'appel exec() sur un processus ?",
                "correctAnswer": ["remplace", "programme", "espace d'adressage"],
                "explanation": "Exec() remplace l'espace d'adressage du processus courant par celui d'un nouveau programme."
            },
            {
                "id": 76,
                "topic": "management",
                "question": "Décrivez les étapes d'un changement de contexte.",
                "correctAnswer": ["sauvegarde", "restauration", "PCB", "CPU"],
                "explanation": "Le contexte est sauvegardé dans le PCB, un nouveau processus est sélectionné, et son contexte est restauré dans le CPU."
            },
            {
                "id": 77,
                "topic": "signals",
                "question": "Qu'est-ce qu'un signal dans UNIX ?",
                "correctAnswer": ["notification", "événement", "processus"],
                "explanation": "Un signal est une notification d'événement envoyée à un processus, pouvant être synchrone (exception) ou asynchrone (interruption)."
            },
            {
                "id": 78,
                "topic": "creation",
                "question": "Pourquoi utilise-t-on la copie sur écriture dans fork() ?",
                "correctAnswer": ["optimisation", "partage", "modification"],
                "explanation": "La copie sur écriture partage l'espace d'adressage et ne copie les pages que lorsqu'elles sont modifiées, optimisant la création."
            },
            {
                "id": 79,
                "topic": "states",
                "question": "Comment un processus passe-t-il de Nouveau à Prêt ?",
                "correctAnswer": ["admission", "système", "file"],
                "explanation": "Un processus est admis par le système, son PCB est initialisé, et il est placé dans la file Prêt."
            },
            {
                "id": 80,
                "topic": "management",
                "question": "Pourquoi un processus peut-il être suspendu ?",
                "correctAnswer": ["mémoire", "échange", "disque"],
                "explanation": "Un processus est suspendu pour libérer la mémoire principale en l'échangeant sur le disque."
            },
            {
                "id": 81,
                "topic": "representation",
                "question": "Quelles informations sont stockées dans le PCB ?",
                "correctAnswer": ["état", "registres", "PID", "ressources"],
                "explanation": "Le PCB contient le PID, l'état, les registres, l'espace d'adressage, les priorités, et les ressources utilisées."
            },
            {
                "id": 82,
                "topic": "signals",
                "question": "Comment les signaux synchrones sont-ils générés ?",
                "correctAnswer": ["actions", "programme", "erreurs"],
                "explanation": "Les signaux synchrones sont générés par les actions du programme, comme des erreurs (SIGSEGV, SIGFPE)."
            },
            {
                "id": 83,
                "topic": "creation",
                "question": "Quelle est la différence entre fork() et vfork() ?",
                "correctAnswer": ["copie", "partage", "espace d'adressage"],
                "explanation": "Fork() copie l'espace d'adressage, tandis que vfork() le partage jusqu'à un appel exec()."
            },
            {
                "id": 84,
                "topic": "states",
                "question": "Qu'est-ce qui déclenche le passage de Bloqué à Prêt ?",
                "correctAnswer": ["événement", "complétion", "E/S"],
                "explanation": "La complétion de l'événement attendu, comme une opération d'E/S, fait passer un processus de Bloqué à Prêt."
            },
            {
                "id": 85,
                "topic": "management",
                "question": "Quel est le rôle des files d'attente multiples ?",
                "correctAnswer": ["organisation", "bloqués", "événements"],
                "explanation": "Les files d'attente multiples organisent les processus bloqués par type d'événement, comme les périphériques ou les minuteries."
            },
            {
                "id": 86,
                "topic": "representation",
                "question": "Pourquoi le PID est-il important ?",
                "correctAnswer": ["identification", "gestion", "processus"],
                "explanation": "Le PID identifie de manière unique chaque processus pour la gestion par le système d'exploitation."
            },
            {
                "id": 87,
                "topic": "signals",
                "question": "Quel est l'effet de SIGSTOP sur un processus ?",
                "correctAnswer": ["suspension", "temporaire", "exécution"],
                "explanation": "SIGSTOP suspend temporairement l'exécution d'un processus."
            },
            {
                "id": 88,
                "topic": "creation",
                "question": "Comment wait() est-il utilisé dans UNIX ?",
                "correctAnswer": ["attente", "fils", "terminaison"],
                "explanation": "Wait() permet au parent d'attendre la terminaison de son processus fils."
            },
            {
                "id": 89,
                "topic": "states",
                "question": "Quelles sont les raisons de la terminaison d'un processus ?",
                "correctAnswer": ["fin", "erreur", "signal"],
                "explanation": "Un processus peut se terminer par une fin normale, une erreur (comme SIGSEGV), ou un signal (comme SIGKILL)."
            },
            {
                "id": 90,
                "topic": "management",
                "question": "Comment la préemption affecte-t-elle un processus ?",
                "correctAnswer": ["interruption", "Prêt", "CPU"],
                "explanation": "La préemption interrompt un processus en cours, le ramenant à Prêt pour allouer le CPU à un autre."
            },
            {
                "id": 91,
                "topic": "representation",
                "question": "Quel rôle joue le compteur de programme dans le PCB ?",
                "correctAnswer": ["instruction", "suivante", "exécution"],
                "explanation": "Le compteur de programme indique l'adresse de la prochaine instruction à exécuter."
            },
            {
                "id": 92,
                "topic": "signals",
                "question": "Quel est l'effet de SIGCONT ?",
                "correctAnswer": ["reprise", "suspendu", "exécution"],
                "explanation": "SIGCONT reprend l'exécution d'un processus suspendu."
            },
            {
                "id": 93,
                "topic": "creation",
                "question": "Pourquoi vfork() est-il plus rapide que fork() ?",
                "correctAnswer": ["partage", "espace d'adressage", "copie"],
                "explanation": "Vfork() ne copie pas l'espace d'adressage, le partageant avec le parent jusqu'à exec()."
            },
            {
                "id": 94,
                "topic": "states",
                "question": "Qu'est-ce qui cause le passage de Prêt à En cours ?",
                "correctAnswer": ["planificateur", "CPU", "attribution"],
                "explanation": "Le planificateur attribue le CPU à un processus prêt, le faisant passer à En cours."
            },
            {
                "id": 95,
                "topic": "management",
                "question": "Comment les processus suspendus sont-ils gérés ?",
                "correctAnswer": ["disque", "mémoire", "réactivation"],
                "explanation": "Les processus suspendus sont déplacés sur le disque et réactivés en mémoire lorsque nécessaire."
            },
            {
                "id": 96,
                "topic": "representation",
                "question": "Quel élément du PCB gère les permissions ?",
                "correctAnswer": ["utilisateur", "identifiant", "sécurité"],
                "explanation": "L'identifiant d'utilisateur dans le PCB détermine les permissions et la sécurité."
            },
            {
                "id": 97,
                "topic": "signals",
                "question": "Qu'est-ce qu'un signal asynchrone ?",
                "correctAnswer": ["externe", "événement", "interruption"],
                "explanation": "Un signal asynchrone est déclenché par un événement externe, comme SIGINT ou SIGTERM."
            },
            {
                "id": 98,
                "topic": "creation",
                "question": "Quel est l'effet de getpid() ?",
                "correctAnswer": ["retourne", "PID", "courant"],
                "explanation": "Getpid() retourne l'identifiant du processus courant."
            },
            {
                "id": 99,
                "topic": "states",
                "question": "Quand un processus passe-t-il à l'état Suspendu ?",
                "correctAnswer": ["échange", "disque", "mémoire"],
                "explanation": "Un processus passe à Suspendu lorsqu'il est échangé sur le disque pour libérer la mémoire."
            },
            {
                "id": 100,
                "topic": "management",
                "question": "Quel est le rôle du nettoyage après la terminaison ?",
                "correctAnswer": ["libération", "ressources", "PCB"],
                "explanation": "Le nettoyage libère les ressources du processus, comme son PCB, après sa terminaison."
            }
            ]
        },
        "flashcardData": [
            {
            "id": 1,
            "topic": "basics",
            "front": "Qu'est-ce qu'un processus ?",
            "back": "Un processus est une instance d'un programme en exécution, servant d'unité d'exécution, de planification et d'allocation des ressources."
            },
            {
            "id": 2,
            "topic": "representation",
            "front": "Quels sont les composants de l'espace d'adressage d'un processus ?",
            "back": "L'espace d'adressage inclut le segment de code (texte), les données, la pile et le tas."
            },
            {
            "id": 3,
            "topic": "management",
            "front": "Quel est le rôle du Bloc de Contrôle de Processus (PCB) ?",
            "back": "Le PCB stocke l'état d'exécution, les registres, le PID, et d'autres métadonnées pour gérer un processus."
            },
            {
            "id": 4,
            "topic": "states",
            "front": "Quels sont les cinq états d'un processus ?",
            "back": "Nouveau, Prêt, En cours, Bloqué, Terminé."
            },
            {
            "id": 5,
            "topic": "management",
            "front": "Qu'est-ce qu'un changement de contexte ?",
            "back": "Un changement de contexte sauvegarde l'état d'un processus et restaure celui d'un autre pour partager le CPU."
            },
            {
            "id": 6,
            "topic": "creation",
            "front": "Comment fonctionne l'appel système fork() ?",
            "back": "Fork() crée un processus fils en copiant l'espace d'adressage du parent, retournant le PID du fils au parent et 0 au fils."
            },
            {
            "id": 7,
            "topic": "creation",
            "front": "Quelle est la différence entre fork() et exec() ?",
            "back": "Fork() crée un nouveau processus, tandis que exec() remplace l'espace d'adressage du processus courant par un nouveau programme."
            },
            {
            "id": 8,
            "topic": "creation",
            "front": "Qu'est-ce que la copie sur écriture ?",
            "back": "La copie sur écriture partage l'espace d'adressage du parent avec le fils, copiant les pages uniquement lorsqu'elles sont modifiées."
            },
            {
            "id": 9,
            "topic": "management",
            "front": "Pourquoi un processus peut-il être suspendu ?",
            "back": "Un processus est suspendu pour libérer la mémoire principale en l'échangeant sur le disque."
            },
            {
            "id": 10,
            "topic": "signals",
            "front": "Qu'est-ce qu'un signal dans UNIX ?",
            "back": "Un signal est une notification d'événement, synchrone (comme une exception) ou asynchrone (comme une interruption)."
            },
            {
            "id": 11,
            "topic": "states",
            "front": "Que signifie l'état Prêt ?",
            "back": "L'état Prêt indique qu'un processus est prêt à s'exécuter mais attend l'attribution du CPU."
            },
            {
            "id": 12,
            "topic": "representation",
            "front": "Qu'est-ce qu'un PID ?",
            "back": "Un PID est un entier unique attribué à chaque processus pour l'identifier dans le système."
            },
            {
            "id": 13,
            "topic": "management",
            "front": "Quel est l'effet de l'appel kill() ?",
            "back": "Kill() envoie un signal à un processus, pouvant le terminer ou déclencher un gestionnaire d'événements."
            },
            {
            "id": 14,
            "topic": "signals",
            "front": "Quelle est la différence entre signaux synchrones et asynchrones ?",
            "back": "Les signaux synchrones résultent des actions du programme, les asynchrones sont déclenchés par des événements externes."
            },
            {
            "id": 15,
            "topic": "creation",
            "front": "Pourquoi utilise-t-on vfork() ?",
            "back": "Vfork() évite de copier l'espace d'adressage du parent, le partageant jusqu'à un appel exec()."
            },
            {
            "id": 16,
            "topic": "management",
            "front": "Qu'est-ce qu'une file d'état ?",
            "back": "Une file d'état organise les PCB selon l'état des processus (Prêt, Bloqué, etc.)."
            },
            {
            "id": 17,
            "topic": "basics",
            "front": "Quel est l'objectif de la virtualisation du processeur ?",
            "back": "Intercaler l'exécution de plusieurs processus pour maximiser l'utilisation du CPU."
            },
            {
            "id": 18,
            "topic": "creation",
            "front": "Que se passe-t-il lors de la création via fork() ?",
            "back": "Un nouveau PCB est alloué, l'espace d'adressage est copié, et le PCB est placé dans la file Prêt."
            },
            {
            "id": 19,
            "topic": "states",
            "front": "Quand un processus est-il dans l'état Bloqué ?",
            "back": "Un processus est Bloqué lorsqu'il attend un événement, comme une opération d'E/S."
            },
            {
            "id": 20,
            "topic": "representation",
            "front": "Quel élément du PCB stocke l'état du processeur ?",
            "back": "Le compteur de programme et les registres stockent l'état du processeur."
            },
            {
            "id": 21,
            "topic": "signals",
            "front": "Quel est l'effet de SIGKILL ?",
            "back": "SIGKILL termine immédiatement un processus sans possibilité de gestion."
            },
            {
            "id": 22,
            "topic": "management",
            "front": "Quel est le rôle des files d'attente multiples ?",
            "back": "Elles organisent les processus bloqués par type d'événement, comme les périphériques ou minuteries."
            },
            {
            "id": 23,
            "topic": "creation",
            "front": "Quel est l'effet de exec() ?",
            "back": "Exec() remplace l'espace d'adressage du processus courant par un nouveau programme."
            },
            {
            "id": 24,
            "topic": "states",
            "front": "Que signifie l'état Terminé ?",
            "back": "L'état Terminé indique que le processus a fini et attend la libération de ses ressources."
            },
            {
            "id": 25,
            "topic": "management",
            "front": "Qu'est-ce que l'échange (swapping) ?",
            "back": "L'échange déplace un processus vers le disque pour libérer la mémoire principale."
            },
            {
            "id": 26,
            "topic": "representation",
            "front": "Quel élément du PCB gère les fichiers ouverts ?",
            "back": "Le tableau des descripteurs de fichiers gère les fichiers ouverts par le processus."
            },
            {
            "id": 27,
            "topic": "signals",
            "front": "Quel est l'effet de SIGFPE ?",
            "back": "SIGFPE est déclenché pour des erreurs arithmétiques, comme une division par zéro."
            },
            {
            "id": 28,
            "topic": "creation",
            "front": "Quel est le rôle de wait() ?",
            "back": "Wait() permet au parent d'attendre la terminaison de son processus fils."
            },
            {
            "id": 29,
            "topic": "states",
            "front": "Que signifie l'état En cours ?",
            "back": "L'état En cours indique que le processus est actuellement exécuté par le CPU."
            },
            {
            "id": 30,
            "topic": "management",
            "front": "Qu'est-ce que la préemption ?",
            "back": "La préemption interrompt un processus en cours pour allouer le CPU à un autre."
            },
            {
            "id": 31,
            "topic": "representation",
            "front": "Quel élément du PCB détermine l'ordre d'exécution ?",
            "back": "La priorité de planification influence l'ordre d'exécution des processus."
            },
            {
            "id": 32,
            "topic": "signals",
            "front": "Quel est l'effet de SIGTERM ?",
            "back": "SIGTERM demande une terminaison gracieuse, permettant au processus de nettoyer."
            },
            {
            "id": 33,
            "topic": "creation",
            "front": "Pourquoi exec() est-il utilisé après fork() ?",
            "back": "Exec() remplace l'image du processus fils par un nouveau programme."
            },
            {
            "id": 34,
            "topic": "states",
            "front": "Que signifie l'état Nouveau ?",
            "back": "L'état Nouveau indique qu'un processus est créé mais pas encore admis."
            },
            {
            "id": 35,
            "topic": "management",
            "front": "Qu'est-ce que la réactivation ?",
            "back": "La réactivation ramène un processus suspendu en mémoire principale."
            },
            {
            "id": 36,
            "topic": "representation",
            "front": "Quel est le rôle du compteur de programme ?",
            "back": "Il indique l'adresse de la prochaine instruction à exécuter."
            },
            {
            "id": 37,
            "topic": "signals",
            "front": "Quel est l'effet de SIGINT ?",
            "back": "SIGINT est déclenché par une interruption clavier, comme Ctrl+C."
            },
            {
            "id": 38,
            "topic": "creation",
            "front": "Pourquoi vfork() est-il plus rapide ?",
            "back": "Vfork() ne copie pas l'espace d'adressage, le partageant avec le parent."
            },
            {
            "id": 39,
            "topic": "states",
            "front": "Que signifie l'état Suspendu ?",
            "back": "L'état Suspendu indique qu'un processus est déplacé vers la mémoire secondaire."
            },
            {
            "id": 40,
            "topic": "management",
            "front": "Qu'est-ce que le nettoyage ?",
            "back": "Le nettoyage libère les ressources d'un processus terminé, comme son PCB."
            },
            {
            "id": 41,
            "topic": "representation",
            "front": "Quel élément du PCB gère la sécurité ?",
            "back": "L'identifiant d'utilisateur détermine les permissions et la sécurité."
            },
            {
            "id": 42,
            "topic": "signals",
            "front": "Quel est l'effet de SIGSTOP ?",
            "back": "SIGSTOP suspend temporairement l'exécution d'un processus."
            },
            {
            "id": 43,
            "topic": "creation",
            "front": "Quel est le rôle de getpid() ?",
            "back": "Getpid() retourne l'identifiant du processus courant."
            },
            {
            "id": 44,
            "topic": "states",
            "front": "Quand un processus passe-t-il à Prêt ?",
            "back": "Un processus passe à Prêt après admission ou complétion d'un événement."
            },
            {
            "id": 45,
            "topic": "management",
            "front": "Pourquoi utilise-t-on des files d'attente multiples ?",
            "back": "Elles organisent les processus bloqués par type d'événement."
            },
            {
            "id": 46,
            "topic": "representation",
            "front": "Quel élément du PCB suit l'utilisation des ressources ?",
            "back": "Les statistiques d'exécution suivent l'utilisation des ressources."
            },
            {
            "id": 47,
            "topic": "signals",
            "front": "Quel est l'effet de SIGCONT ?",
            "back": "SIGCONT reprend l'exécution d'un processus suspendu."
            },
            {
            "id": 48,
            "topic": "creation",
            "front": "Quel est le rôle de getppid() ?",
            "back": "Getppid() retourne l'identifiant du processus parent."
            },
            {
            "id": 49,
            "topic": "states",
            "front": "Quand un processus est-il terminé ?",
            "back": "Un processus est terminé après une fin normale, une erreur, ou un signal."
            },
            {
            "id": 50,
            "topic": "management",
            "front": "Qu'est-ce que la préemption ?",
            "back": "La préemption interrompt un processus pour allouer le CPU à un autre."
            }
        ]
    },
    "computer-io": {
        "name": "Entrées/Sorties Informatiques",
        "description": "Concepts fondamentaux des entrées/sorties dans les systèmes informatiques",
        "topics": {
            "basics": { "name": "Concepts de Base" },
            "peripherals": { "name": "Périphériques" },
            "mechanisms": { "name": "Mécanismes d'E/S" },
            "synchronization": { "name": "Synchronisation" },
            "pc": { "name": "E/S sur PC" }
        },
        "quizData": {
            "multiple-choice": [
                {
                    "id": 1,
                    "topic": "basics",
                    "question": "Quel est le rôle principal des périphériques d'entrée/sortie dans un système informatique?",
                    "options": [
                        "Effectuer des calculs complexes",
                        "Permettre la communication entre l'ordinateur et l'extérieur",
                        "Stocker des données temporairement",
                        "Gérer l'exécution des programmes"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les périphériques d'entrée/sortie permettent la communication entre l'ordinateur et l'extérieur, en transmettant ou recevant des informations."
                },
                {
                    "id": 2,
                    "topic": "peripherals",
                    "question": "Lequel de ces périphériques est considéré comme un périphérique de sortie?",
                    "options": [
                        "Clavier",
                        "Souris",
                        "Imprimante",
                        "Scanner"
                    ],
                    "correctAnswer": 2,
                    "explanation": "L'imprimante est un périphérique de sortie car elle reçoit des informations de l'ordinateur pour produire un résultat."
                },
                {
                    "id": 3,
                    "topic": "mechanisms",
                    "question": "Quelle est la fonction principale d’un port d’E/S dans un système informatique?",
                    "options": [
                        "Stocker des données temporairement",
                        "Permettre à l’UCT de communiquer avec un périphérique via une interface",
                        "Gérer les interruptions des périphériques",
                        "Mapper les registres dans l’espace mémoire"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Un port d’E/S est une adresse spécifique qui permet à l’UCT de communiquer avec un périphérique particulier via une interface, en utilisant des instructions comme IN et OUT."
                },
                {
                    "id": 4,
                    "topic": "synchronization",
                    "question": "Quel est l’avantage principal de la synchronisation asynchrone par rapport à la synchronisation synchrone?",
                    "options": [
                        "Elle est plus simple à implémenter",
                        "Elle permet à l’UCT de continuer d’autres tâches pendant l’opération E/S",
                        "Elle consomme moins de mémoire",
                        "Elle ne nécessite pas de bus d’adresses"
                    ],
                    "correctAnswer": 1,
                    "explanation": "La synchronisation asynchrone utilise des interruptions, permettant à l’UCT de continuer d’autres tâches en attendant que le périphérique soit prêt."
                },
                {
                    "id": 5,
                    "topic": "pc",
                    "question": "Quelle fonction de la bibliothèque dos.h est utilisée pour lire un octet depuis un port d’E/S?",
                    "options": [
                        "outport()",
                        "inportb()",
                        "outportb()",
                        "inport()"
                    ],
                    "correctAnswer": 1,
                    "explanation": "La fonction inportb() est utilisée pour lire un octet (8 bits) depuis un port d’E/S spécifié."
                },
                {
                    "id": 6,
                    "topic": "basics",
                    "question": "Quel composant relie l’UCT et la mémoire aux périphériques dans un système d’E/S?",
                    "options": [
                        "Contrôleur",
                        "Bus",
                        "Interface",
                        "Registre"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Le bus est le canal de communication qui relie l’UCT, la mémoire et les périphériques, transportant les données, adresses et signaux de contrôle."
                },
                {
                    "id": 7,
                    "topic": "mechanisms",
                    "question": "Quel est l’inconvénient principal de la projection en mémoire par rapport aux ports d’E/S?",
                    "options": [
                        "Elle nécessite des instructions spéciales",
                        "Elle consomme plus de temps CPU",
                        "Elle réduit l’espace d’adresses mémoire disponible",
                        "Elle est incompatible avec les périphériques modernes"
                    ],
                    "correctAnswer": 2,
                    "explanation": "La projection en mémoire réduit l’espace d’adresses mémoire disponible, car une partie est réservée pour les registres des périphériques."
                },
                {
                    "id": 8,
                    "topic": "synchronization",
                    "question": "Pourquoi l’interrogation de bits d’état (synchronisation synchrone) est-elle considérée comme coûteuse en temps?",
                    "options": [
                        "Elle nécessite des interruptions fréquentes",
                        "L’UCT doit attendre activement que le périphérique soit prêt",
                        "Elle utilise trop de mémoire",
                        "Elle est complexe à programmer"
                    ],
                    "correctAnswer": 1,
                    "explanation": "L’interrogation de bits d’état est coûteuse en temps car l’UCT doit continuellement vérifier l’état du périphérique, ce qui entraîne une attente active."
                },
                {
                    "id": 9,
                    "topic": "basics",
                    "question": "Quel composant exécute les instructions dans un système informatique?",
                    "options": [
                        "Mémoire",
                        "Bus",
                        "UCT",
                        "Contrôleur"
                    ],
                    "correctAnswer": 2,
                    "explanation": "L’UCT (Unité Centrale de Traitement) exécute les instructions et gère les opérations dans un système informatique."
                },
                {
                    "id": 10,
                    "topic": "peripherals",
                    "question": "Lequel de ces périphériques peut être à la fois d’entrée et de sortie?",
                    "options": [
                        "Écran",
                        "Disque dur",
                        "Clavier",
                        "Haut-parleur"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Le disque dur peut être à la fois un périphérique d’entrée (lecture de données) et de sortie (écriture de données)."
                },
                {
                    "id": 11,
                    "topic": "mechanisms",
                    "question": "Quel type d’instruction est utilisé pour écrire des données via un port d’E/S?",
                    "options": [
                        "MOV",
                        "OUT",
                        "IN",
                        "LOAD"
                    ],
                    "correctAnswer": 1,
                    "explanation": "L’instruction OUT est utilisée pour écrire des données vers un port d’E/S."
                },
                {
                    "id": 12,
                    "topic": "synchronization",
                    "question": "Quel mécanisme permet à l’interface de signaler à l’UCT qu’un périphérique est prêt?",
                    "options": [
                        "Interrogation de bits d’état",
                        "Instructions IN/OUT",
                        "Interruptions",
                        "Projection en mémoire"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Les interruptions permettent à l’interface de signaler à l’UCT qu’un périphérique est prêt ou qu’une opération est terminée."
                },
                {
                    "id": 13,
                    "topic": "pc",
                    "question": "Quel signal indique une opération de lecture dans un port d’E/S?",
                    "options": [
                        "IOW",
                        "MEMR",
                        "IOR",
                        "MEMW"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Le signal IOR (Input/Output Read) indique une opération de lecture dans un port d’E/S."
                },
                {
                    "id": 14,
                    "topic": "basics",
                    "question": "Quel est le rôle du contrôleur dans un système d’E/S?",
                    "options": [
                        "Exécuter les instructions de l’UCT",
                        "Gérer le fonctionnement physique du périphérique",
                        "Stocker les données temporairement",
                        "Traduire les commandes de l’UCT"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Le contrôleur gère le fonctionnement physique du périphérique, comme déplacer une tête d’impression ou activer un moteur de disque."
                },
                {
                    "id": 15,
                    "topic": "mechanisms",
                    "question": "Qu’est-ce qui distingue un port d’E/S d’une adresse mémoire dans la projection en mémoire?",
                    "options": [
                        "Un port d’E/S utilise des instructions mémoire standard",
                        "Un port d’E/S a un espace d’adresses distinct",
                        "Un port d’E/S est plus lent",
                        "Un port d’E/S ne peut pas être mappé"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Un port d’E/S a un espace d’adresses distinct et utilise des instructions spécifiques comme IN et OUT, contrairement à la projection en mémoire."
                },
                {
                    "id": 16,
                    "topic": "synchronization",
                    "question": "Quel type de synchronisation est plus adapté à un environnement multi-usagers?",
                    "options": [
                        "Synchrone",
                        "Asynchrone",
                        "Interrogation active",
                        "Synchronisation par ports"
                    ],
                    "correctAnswer": 1,
                    "explanation": "La synchronisation asynchrone est plus adaptée aux environnements multi-usagers car elle utilise des interruptions, évitant l’attente active."
                },
                {
                    "id": 17,
                    "topic": "pc",
                    "question": "Quelle fonction de dos.h écrit un mot (16 bits) à un port d’E/S?",
                    "options": [
                        "outportb()",
                        "inport()",
                        "outport()",
                        "inportb()"
                    ],
                    "correctAnswer": 2,
                    "explanation": "La fonction outport() écrit un mot (16 bits) à un port d’E/S spécifié."
                },
                {
                    "id": 18,
                    "topic": "basics",
                    "question": "Quel composant stocke temporairement les données échangées avec les périphériques?",
                    "options": [
                        "Bus",
                        "Mémoire",
                        "Contrôleur",
                        "Interface"
                    ],
                    "correctAnswer": 1,
                    "explanation": "La mémoire stocke temporairement les données à envoyer ou à recevoir des périphériques."
                },
                {
                    "id": 19,
                    "topic": "peripherals",
                    "question": "Lequel de ces périphériques est principalement un périphérique d’entrée?",
                    "options": [
                        "Microphone",
                        "Écran",
                        "Imprimante",
                        "Haut-parleur"
                    ],
                    "correctAnswer": 0,
                    "explanation": "Le microphone est un périphérique d’entrée car il transmet des données audio à l’ordinateur."
                },
                {
                    "id": 20,
                    "topic": "mechanisms",
                    "question": "Quel est l’avantage des ports d’E/S par rapport à la projection en mémoire?",
                    "options": [
                        "Ils consomment moins de mémoire",
                        "Ils ne réduisent pas l’espace d’adresses mémoire",
                        "Ils sont plus rapides",
                        "Ils nécessitent moins de signaux de contrôle"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les ports d’E/S ne réduisent pas l’espace d’adresses mémoire, contrairement à la projection en mémoire."
                },
                {
                    "id": 21,
                    "topic": "synchronization",
                    "question": "Quel est l’inconvénient principal des interruptions dans la synchronisation asynchrone?",
                    "options": [
                        "Elles consomment trop de mémoire",
                        "Elles sont complexes à gérer",
                        "Elles ralentissent l’UCT",
                        "Elles ne fonctionnent pas avec plusieurs périphériques"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les interruptions sont complexes à gérer, nécessitant une programmation plus élaborée pour traiter les signaux."
                },
                {
                    "id": 22,
                    "topic": "pc",
                    "question": "Quel signal indique une opération d’écriture en mémoire?",
                    "options": [
                        "IOR",
                        "IOW",
                        "MEMW",
                        "MEMR"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Le signal MEMW (Memory Write) indique une opération d’écriture en mémoire."
                },
                {
                    "id": 23,
                    "topic": "basics",
                    "question": "Quel est le rôle principal de l’interface dans un système d’E/S?",
                    "options": [
                        "Exécuter les instructions",
                        "Traduire les commandes de l’UCT pour le contrôleur",
                        "Stocker les données",
                        "Gérer les interruptions"
                    ],
                    "correctAnswer": 1,
                    "explanation": "L’interface traduit les commandes de l’UCT en instructions compréhensibles par le contrôleur."
                },
                {
                    "id": 24,
                    "topic": "peripherals",
                    "question": "Quel périphérique nécessite un contrôleur pour activer un moteur?",
                    "options": [
                        "Clavier",
                        "Disque dur",
                        "Écran",
                        "Souris"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Le disque dur nécessite un contrôleur pour activer un moteur afin de lire ou écrire des données."
                },
                {
                    "id": 25,
                    "topic": "mechanisms",
                    "question": "Comment l’UCT accède-t-il aux registres dans la projection en mémoire?",
                    "options": [
                        "Via des instructions IN/OUT",
                        "Via des adresses mémoire spécifiques",
                        "Via des interruptions",
                        "Via des ports d’E/S"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Dans la projection en mémoire, l’UCT accède aux registres via des adresses mémoire spécifiques, comme s’il accédait à la mémoire."
                },
                {
                    "id": 26,
                    "topic": "synchronization",
                    "question": "Quel type de registre indique l’état d’une interface?",
                    "options": [
                        "Registre d’index",
                        "Registre de données",
                        "Registre d’état",
                        "Registre de commande"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Le registre d’état indique l’état de l’interface, comme inactif, en attente, en traitement ou en erreur."
                },
                {
                    "id": 27,
                    "topic": "pc",
                    "question": "Quel est l’espace d’adresses utilisé par les processeurs Intel 8086 pour les ports d’E/S?",
                    "options": [
                        "8 bits",
                        "16 bits",
                        "32 bits",
                        "64 bits"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les processeurs Intel 8086 utilisent un espace d’adresses de 16 bits, permettant d’adresser 64K ports d’E/S."
                },
                {
                    "id": 28,
                    "topic": "basics",
                    "question": "Quel composant transporte les signaux de contrôle dans un système d’E/S?",
                    "options": [
                        "Mémoire",
                        "Bus",
                        "Contrôleur",
                        "Interface"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Le bus transporte les signaux de contrôle, ainsi que les données et les adresses, entre l’UCT, la mémoire et les périphériques."
                },
                {
                    "id": 29,
                    "topic": "peripherals",
                    "question": "Quel périphérique est connecté au contrôleur via un câble?",
                    "options": [
                        "Mémoire",
                        "Bus",
                        "Périphérique",
                        "UCT"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Le périphérique (comme une imprimante ou un clavier) est connecté au contrôleur via un câble."
                },
                {
                    "id": 30,
                    "topic": "mechanisms",
                    "question": "Quel est le rôle du registre d’index dans une interface?",
                    "options": [
                        "Stocker des données",
                        "Sélectionner un registre spécifique",
                        "Gérer les interruptions",
                        "Traduire les adresses"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Le registre d’index permet de sélectionner un registre spécifique parmi plusieurs dans une interface."
                },
                {
                    "id": 31,
                    "topic": "synchronization",
                    "question": "Quel type de synchronisation est utilisé lorsqu’un bit d’état est interrogé?",
                    "options": [
                        "Asynchrone",
                        "Synchrone",
                        "Par interruption",
                        "Par projection"
                    ],
                    "correctAnswer": 1,
                    "explanation": "L’interrogation d’un bit d’état est une méthode de synchronisation synchrone."
                },
                {
                    "id": 32,
                    "topic": "pc",
                    "question": "Quelle fonction de dos.h lit un mot (16 bits) depuis un port d’E/S?",
                    "options": [
                        "inportb()",
                        "outport()",
                        "inport()",
                        "outportb()"
                    ],
                    "correctAnswer": 2,
                    "explanation": "La fonction inport() lit un mot (16 bits) depuis un port d’E/S spécifié."
                },
                {
                    "id": 33,
                    "topic": "basics",
                    "question": "Pourquoi l’UCT ne contrôle-t-elle pas directement les périphériques?",
                    "options": [
                        "Cela serait trop complexe et inefficace",
                        "Elle n’a pas assez de mémoire",
                        "Elle ne peut pas gérer les interruptions",
                        "Elle n’est pas connectée aux périphériques"
                    ],
                    "correctAnswer": 0,
                    "explanation": "L’UCT ne contrôle pas directement les périphériques car cela serait trop complexe et inefficace, nécessitant une gestion directe des détails matériels."
                },
                {
                    "id": 34,
                    "topic": "peripherals",
                    "question": "Quel périphérique est utilisé pour déplacer une tête d’impression?",
                    "options": [
                        "Clavier",
                        "Imprimante",
                        "Disque dur",
                        "Souris"
                    ],
                    "correctAnswer": 1,
                    "explanation": "L’imprimante utilise un contrôleur pour déplacer une tête d’impression afin d’imprimer des caractères."
                },
                {
                    "id": 35,
                    "topic": "mechanisms",
                    "question": "Quel type d’instruction est utilisé pour lire des données depuis un port d’E/S?",
                    "options": [
                        "OUT",
                        "MOV",
                        "IN",
                        "STORE"
                    ],
                    "correctAnswer": 2,
                    "explanation": "L’instruction IN est utilisée pour lire des données depuis un port d’E/S."
                },
                {
                    "id": 36,
                    "topic": "synchronization",
                    "question": "Quel est l’avantage de l’utilisation d’interruptions dans la synchronisation asynchrone?",
                    "options": [
                        "Elles simplifient la programmation",
                        "Elles réduisent l’utilisation de la mémoire",
                        "Elles permettent à l’UCT de faire d’autres tâches",
                        "Elles éliminent le besoin de bus"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Les interruptions permettent à l’UCT de faire d’autres tâches en attendant que le périphérique soit prêt."
                },
                {
                    "id": 37,
                    "topic": "pc",
                    "question": "Quel composant sur une carte contrôleur vérifie l’adresse envoyée par l’UCT?",
                    "options": [
                        "Registre",
                        "Comparateur",
                        "Interface",
                        "Bus"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Un comparateur sur la carte contrôleur vérifie si l’adresse envoyée par l’UCT correspond à celle de la carte."
                },
                {
                    "id": 38,
                    "topic": "basics",
                    "question": "Quel composant est chargé de stocker les instructions utilisées par l’UCT?",
                    "options": [
                        "Bus",
                        "Mémoire",
                        "Contrôleur",
                        "Périphérique"
                    ],
                    "correctAnswer": 1,
                    "explanation": "La mémoire stocke les instructions et les données utilisées par l’UCT."
                },
                {
                    "id": 39,
                    "topic": "peripherals",
                    "question": "Quel périphérique est utilisé pour transmettre des données audio à l’ordinateur?",
                    "options": [
                        "Haut-parleur",
                        "Microphone",
                        "Écran",
                        "Imprimante"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Le microphone transmet des données audio à l’ordinateur, en tant que périphérique d’entrée."
                },
                {
                    "id": 40,
                    "topic": "mechanisms",
                    "question": "Quel est l’avantage principal de la projection en mémoire pour l’UCT?",
                    "options": [
                        "Elle utilise des ports dédiés",
                        "Elle simplifie l’accès en utilisant des instructions mémoire standard",
                        "Elle consomme moins d’énergie",
                        "Elle augmente l’espace d’adresses mémoire"
                    ],
                    "correctAnswer": 1,
                    "explanation": "La projection en mémoire simplifie l’accès aux registres en utilisant des instructions mémoire standard, sans besoin d’instructions spécifiques comme IN/OUT."
                },
                {
                    "id": 41,
                    "topic": "synchronization",
                    "question": "Quel type de registre est utilisé pour stocker temporairement des données dans une interface?",
                    "options": [
                        "Registre d’état",
                        "Registre d’index",
                        "Registre de données",
                        "Registre de contrôle"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Le registre de données est utilisé pour stocker temporairement des données dans une interface avant leur transmission."
                },
                {
                    "id": 42,
                    "topic": "pc",
                    "question": "Quel signal indique une opération de lecture en mémoire?",
                    "options": [
                        "IOW",
                        "MEMR",
                        "IOR",
                        "MEMW"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Le signal MEMR (Memory Read) indique une opération de lecture en mémoire."
                },
                {
                    "id": 43,
                    "topic": "basics",
                    "question": "Quel composant est responsable de la gestion physique d’un périphérique?",
                    "options": [
                        "Bus",
                        "Mémoire",
                        "Contrôleur",
                        "UCT"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Le contrôleur est responsable de la gestion physique du périphérique, comme activer un moteur ou déplacer une tête d’impression."
                },
                {
                    "id": 44,
                    "topic": "peripherals",
                    "question": "Quel périphérique est utilisé pour afficher des informations visuelles?",
                    "options": [
                        "Clavier",
                        "Écran",
                        "Microphone",
                        "Disque dur"
                    ],
                    "correctAnswer": 1,
                    "explanation": "L’écran est un périphérique de sortie utilisé pour afficher des informations visuelles."
                },
                {
                    "id": 45,
                    "topic": "mechanisms",
                    "question": "Quel est le rôle d’un registre de commande dans une interface?",
                    "options": [
                        "Stocker des données temporairement",
                        "Indiquer l’état de l’interface",
                        "Recevoir des instructions de l’UCT",
                        "Sélectionner un registre"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Un registre de commande reçoit des instructions de l’UCT pour contrôler le fonctionnement de l’interface ou du périphérique."
                },
                {
                    "id": 46,
                    "topic": "synchronization",
                    "question": "Pourquoi l’interrogation de bits d’état est-elle inefficace dans un environnement multi-usagers?",
                    "options": [
                        "Elle consomme trop de mémoire",
                        "Elle nécessite des interruptions",
                        "Elle monopolise l’UCT en attente active",
                        "Elle est incompatible avec les périphériques modernes"
                    ],
                    "correctAnswer": 2,
                    "explanation": "L’interrogation de bits d’état monopolise l’UCT en attente active, ce qui est inefficace dans un environnement multi-usagers."
                },
                {
                    "id": 47,
                    "topic": "pc",
                    "question": "Quel est le rôle du bus d’adresses dans les opérations d’E/S?",
                    "options": [
                        "Transporter les données",
                        "Identifier la destination des informations",
                        "Gérer les interruptions",
                        "Stocker les instructions"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Le bus d’adresses transporte l’adresse spécifiant la destination des informations, comme une carte contrôleur ou un registre."
                },
                {
                    "id": 48,
                    "topic": "basics",
                    "question": "Quel composant agit comme un canal de communication entre l’UCT et les périphériques?",
                    "options": [
                        "Mémoire",
                        "Bus",
                        "Contrôleur",
                        "Registre"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Le bus agit comme un canal de communication entre l’UCT, la mémoire et les périphériques."
                },
                {
                    "id": 49,
                    "topic": "peripherals",
                    "question": "Quel périphérique est utilisé pour entrer des commandes textuelles?",
                    "options": [
                        "Clavier",
                        "Imprimante",
                        "Écran",
                        "Haut-parleur"
                    ],
                    "correctAnswer": 0,
                    "explanation": "Le clavier est un périphérique d’entrée utilisé pour entrer des commandes textuelles."
                },
                {
                    "id": 50,
                    "topic": "mechanisms",
                    "question": "Quel est l’objectif principal de l’utilisation d’un registre d’index?",
                    "options": [
                        "Réduire le nombre de ports nécessaires",
                        "Stocker des données temporairement",
                        "Gérer les interruptions",
                        "Augmenter la vitesse de transmission"
                    ],
                    "correctAnswer": 0,
                    "explanation": "Le registre d’index réduit le nombre de ports nécessaires en permettant de sélectionner un registre spécifique via une seule adresse."
                },
                {
                    "id": 51,
                    "topic": "synchronization",
                    "question": "Quel mécanisme permet à l’UCT de suspendre ses tâches pour traiter une opération E/S?",
                    "options": [
                        "Interrogation de bits d’état",
                        "Instructions IN/OUT",
                        "Interruptions",
                        "Projection en mémoire"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Les interruptions permettent à l’UCT de suspendre ses tâches actuelles pour traiter une opération E/S."
                },
                {
                    "id": 52,
                    "topic": "pc",
                    "question": "Quelle fonction de dos.h est utilisée pour écrire un octet à un port d’E/S?",
                    "options": [
                        "inport()",
                        "outportb()",
                        "inportb()",
                        "outport()"
                    ],
                    "correctAnswer": 1,
                    "explanation": "La fonction outportb() est utilisée pour écrire un octet (8 bits) à un port d’E/S spécifié."
                },
                {
                    "id": 53,
                    "topic": "basics",
                    "question": "Quel composant est responsable de l’exécution des opérations physiques sur un périphérique?",
                    "options": [
                        "UCT",
                        "Mémoire",
                        "Contrôleur",
                        "Bus"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Le contrôleur est responsable de l’exécution des opérations physiques sur un périphérique, comme activer un moteur ou déplacer une tête d’impression."
                },
                {
                    "id": 54,
                    "topic": "peripherals",
                    "question": "Quel périphérique est utilisé pour produire du son?",
                    "options": [
                        "Clavier",
                        "Haut-parleur",
                        "Souris",
                        "Disque dur"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Le haut-parleur est un périphérique de sortie utilisé pour produire du son."
                },
                {
                    "id": 55,
                    "topic": "mechanisms",
                    "question": "Quel type d’instruction est utilisé dans la projection en mémoire pour accéder aux registres?",
                    "options": [
                        "IN",
                        "OUT",
                        "MOV",
                        "LOAD"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Dans la projection en mémoire, des instructions mémoire standard comme MOV sont utilisées pour accéder aux registres."
                },
                {
                    "id": 56,
                    "topic": "synchronization",
                    "question": "Quel est l’objectif principal de la synchronisation des E/S?",
                    "options": [
                        "Augmenter la vitesse des périphériques",
                        "Réduire la consommation d’énergie",
                        "Compenser les différences de vitesse entre l’UCT et les périphériques",
                        "Éliminer les interruptions"
                    ],
                    "correctAnswer": 2,
                    "explanation": "La synchronisation des E/S compense les différences de vitesse entre l’UCT, qui est rapide, et les périphériques, qui sont plus lents."
                },
                {
                    "id": 57,
                    "topic": "pc",
                    "question": "Quel est le rôle du comparateur dans une carte contrôleur?",
                    "options": [
                        "Stocker des données",
                        "Vérifier l’adresse envoyée par l’UCT",
                        "Gérer les interruptions",
                        "Traduire les commandes"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Le comparateur vérifie si l’adresse envoyée par l’UCT correspond à celle de la carte contrôleur."
                },
                {
                    "id": 58,
                    "topic": "basics",
                    "question": "Quel composant est responsable de la traduction des commandes pour le contrôleur?",
                    "options": [
                        "Bus",
                        "Mémoire",
                        "Interface",
                        "UCT"
                    ],
                    "correctAnswer": 2,
                    "explanation": "L’interface traduit les commandes de l’UCT en instructions compréhensibles par le contrôleur."
                },
                {
                    "id": 59,
                    "topic": "peripherals",
                    "question": "Quel périphérique peut lire des données stockées sur un support magnétique?",
                    "options": [
                        "Clavier",
                        "Disque dur",
                        "Écran",
                        "Haut-parleur"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Le disque dur peut lire des données stockées sur un support magnétique, en tant que périphérique d’entrée."
                },
                {
                    "id": 60,
                    "topic": "mechanisms",
                    "question": "Quel est l’inconvénient des ports d’E/S par rapport à la projection en mémoire?",
                    "options": [
                        "Ils réduisent l’espace d’adresses mémoire",
                        "Ils nécessitent des instructions spécifiques comme IN/OUT",
                        "Ils sont plus lents",
                        "Ils ne peuvent pas gérer plusieurs registres"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les ports d’E/S nécessitent des instructions spécifiques comme IN et OUT, contrairement à la projection en mémoire qui utilise des instructions mémoire standard."
                }
            ],
            "true-false": [
                {
                    "id": 61,
                    "topic": "basics",
                    "question": "L’UCT contrôle directement les périphériques d’entrée/sortie.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. L’UCT ne contrôle pas directement les périphériques, mais communique avec eux via le bus et l’interface."
                },
                {
                    "id": 62,
                    "topic": "peripherals",
                    "question": "Un disque dur est uniquement un périphérique de sortie.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. Un disque dur est à la fois un périphérique d’entrée (lecture de données) et de sortie (écriture de données)."
                },
                {
                    "id": 63,
                    "topic": "mechanisms",
                    "question": "La projection en mémoire élimine complètement l’utilisation des ports d’E/S dans un système.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. La projection en mémoire et les ports d’E/S peuvent coexister dans un même système."
                },
                {
                    "id": 64,
                    "topic": "synchronization",
                    "question": "La synchronisation asynchrone est toujours plus simple à implémenter que la synchrone.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. La synchronisation asynchrone est plus complexe à implémenter en raison de la gestion des interruptions."
                },
                {
                    "id": 65,
                    "topic": "pc",
                    "question": "Les processeurs Intel 8086 utilisent un espace d’adresses de 16 bits pour adresser jusqu’à 64K ports d’E/S.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 0,
                    "explanation": "Vrai. Les processeurs Intel 8086 utilisent un espace d’adresses de 16 bits, permettant d’adresser jusqu’à 64K ports d’E/S."
                },
                {
                    "id": 66,
                    "topic": "basics",
                    "question": "Le bus transporte uniquement les données entre l’UCT et les périphériques.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. Le bus transporte les données, les adresses et les signaux de contrôle."
                },
                {
                    "id": 67,
                    "topic": "peripherals",
                    "question": "Un clavier est un périphérique de sortie.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. Un clavier est un périphérique d’entrée car il transmet des données à l’ordinateur."
                },
                {
                    "id": 68,
                    "topic": "mechanisms",
                    "question": "Un registre d’index nécessite un port distinct pour chaque registre de l’interface.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. Un registre d’index permet de sélectionner un registre spécifique via un seul port, réduisant le nombre de ports nécessaires."
                },
                {
                    "id": 69,
                    "topic": "synchronization",
                    "question": "L’interrogation de bits d’état est une méthode de synchronisation asynchrone.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. L’interrogation de bits d’état est une méthode de synchronisation synchrone."
                },
                {
                    "id": 70,
                    "topic": "pc",
                    "question": "Le signal IOW est utilisé pour les opérations de lecture dans un port d’E/S.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. Le signal IOW (Input/Output Write) est utilisé pour les opérations d’écriture, tandis que IOR est utilisé pour la lecture."
                },
                {
                    "id": 71,
                    "topic": "basics",
                    "question": "La mémoire est utilisée pour stocker temporairement les données échangées avec les périphériques.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 0,
                    "explanation": "Vrai. La mémoire stocke temporairement les données à envoyer ou à recevoir des périphériques."
                },
                {
                    "id": 72,
                    "topic": "peripherals",
                    "question": "Un haut-parleur est un périphérique d’entrée.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. Un haut-parleur est un périphérique de sortie car il reçoit des données de l’ordinateur pour produire du son."
                },
                {
                    "id": 73,
                    "topic": "mechanisms",
                    "question": "La projection en mémoire utilise des instructions spécifiques comme IN et OUT.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. La projection en mémoire utilise des instructions mémoire standard, comme MOV, et non des instructions spécifiques comme IN et OUT."
                },
                {
                    "id": 74,
                    "topic": "synchronization",
                    "question": "Les interruptions permettent à l’UCT de continuer ses tâches sans attendre le périphérique.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 0,
                    "explanation": "Vrai. Les interruptions permettent à l’UCT de faire d’autres tâches en attendant que le périphérique soit prêt."
                },
                {
                    "id": 75,
                    "topic": "pc",
                    "question": "Le bus d’adresses transporte les données entre l’UCT et les périphériques.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. Le bus d’adresses transporte les adresses pour identifier la destination, tandis que le bus de données transporte les données."
                }
            ],
            "short-answer": [
                {
                    "id": 76,
                    "topic": "basics",
                    "question": "Décrivez le rôle de l’interface dans un système d’E/S.",
                    "correctAnswer": ["interface", "traduire", "commandes", "contrôleur"],
                    "explanation": "L’interface fait le lien entre le bus et le contrôleur, traduisant les commandes de l’UCT en instructions compréhensibles par le contrôleur."
                },
                {
                    "id": 77,
                    "topic": "peripherals",
                    "question": "Nommez deux périphériques qui peuvent être à la fois d’entrée et de sortie.",
                    "correctAnswer": ["disque dur", "périphérique", "entrée", "sortie"],
                    "explanation": "Le disque dur et les clés USB sont des périphériques qui peuvent être à la fois d’entrée (lecture) et de sortie (écriture)."
                },
                {
                    "id": 78,
                    "topic": "mechanisms",
                    "question": "Expliquez comment un registre d’index simplifie la gestion des interfaces à plusieurs registres.",
                    "correctAnswer": ["registre d’index", "sélectionner", "registre", "port"],
                    "explanation": "Un registre d’index permet de sélectionner un registre spécifique parmi plusieurs dans une interface en écrivant une valeur dans ce registre via un port, réduisant le nombre de ports nécessaires."
                },
                {
                    "id": 79,
                    "topic": "synchronization",
                    "question": "Pourquoi la synchronisation des E/S est-elle nécessaire dans les systèmes informatiques?",
                    "correctAnswer": ["vitesse", "UCT", "périphérique", "synchronisation"],
                    "explanation": "La synchronisation des E/S est nécessaire pour compenser les différences de vitesse entre l’UCT, qui est rapide, et les périphériques, qui sont plus lents, afin d’éviter des erreurs."
                },
                {
                    "id": 80,
                    "topic": "pc",
                    "question": "Comment les signaux de contrôle comme IOR et IOW aident-ils les cartes contrôleurs?",
                    "correctAnswer": ["signaux", "contrôle", "type", "opération"],
                    "explanation": "Les signaux comme IOR (lecture) et IOW (écriture) indiquent le type d’opération à effectuer, permettant à la carte contrôleur d’accepter ou d’ignorer les données."
                },
                {
                    "id": 81,
                    "topic": "basics",
                    "question": "Quel est le rôle du bus dans un système d’E/S?",
                    "correctAnswer": ["bus", "communication", "données", "signaux"],
                    "explanation": "Le bus est le canal de communication qui transporte les données, les adresses et les signaux de contrôle entre l’UCT, la mémoire et les périphériques."
                },
                {
                    "id": 82,
                    "topic": "peripherals",
                    "question": "Donnez un exemple de périphérique d’entrée et expliquez son rôle.",
                    "correctAnswer": ["clavier", "transmettre", "données", "ordinateur"],
                    "explanation": "Le clavier est un périphérique d’entrée qui transmet des données, comme des commandes textuelles, à l’ordinateur."
                },
                {
                    "id": 83,
                    "topic": "mechanisms",
                    "question": "Décrivez le processus d’écriture de données dans un registre via un port d’E/S.",
                    "correctAnswer": ["port", "OUT", "registre", "données"],
                    "explanation": "L’UCT envoie une instruction OUT avec la donnée et l’adresse du port, l’interface stocke la donnée dans le registre correspondant."
                },
                {
                    "id": 84,
                    "topic": "synchronization",
                    "question": "Expliquez la différence entre la synchronisation synchrone et asynchrone.",
                    "correctAnswer": ["synchrone", "interrogation", "asynchrone", "interruption"],
                    "explanation": "La synchronisation synchrone utilise l’interrogation active de l’état du périphérique, tandis que l’asynchrone utilise des interruptions pour signaler à l’UCT que le périphérique est prêt."
                },
                {
                    "id": 85,
                    "topic": "pc",
                    "question": "Comment une carte contrôleur détermine-t-elle si une information lui est destinée?",
                    "correctAnswer": ["adresse", "comparateur", "signaux", "contrôle"],
                    "explanation": "Un comparateur vérifie si l’adresse envoyée sur le bus correspond à celle de la carte, et les signaux de contrôle comme IOR ou IOW indiquent l’opération."
                },
                {
                    "id": 86,
                    "topic": "basics",
                    "question": "Pourquoi l’UCT ne stocke-t-elle pas directement les données des périphériques?",
                    "correctAnswer": ["UCT", "complexe", "mémoire", "temporaire"],
                    "explanation": "L’UCT ne stocke pas directement les données car cela serait complexe; la mémoire est utilisée pour stocker temporairement les données des périphériques."
                },
                {
                    "id": 87,
                    "topic": "peripherals",
                    "question": "Quel est le rôle d’un contrôleur pour une imprimante?",
                    "correctAnswer": ["contrôleur", "tête d’impression", "déplacer", "imprimer"],
                    "explanation": "Le contrôleur d’une imprimante déplace la tête d’impression pour imprimer des caractères ou des images."
                },
                {
                    "id": 88,
                    "topic": "mechanisms",
                    "question": "Pourquoi la projection en mémoire simplifie-t-elle le travail de l’UCT?",
                    "correctAnswer": ["mémoire", "instructions", "standard", "accès"],
                    "explanation": "La projection en mémoire permet à l’UCT d’accéder aux registres des périphériques avec des instructions mémoire standard, simplifiant la gestion."
                },
                {
                    "id": 89,
                    "topic": "synchronization",
                    "question": "Pourquoi les interruptions sont-elles plus efficaces dans un environnement multi-usagers?",
                    "correctAnswer": ["interruptions", "attente", "efficace", "tâches"],
                    "explanation": "Les interruptions permettent à l’UCT de continuer d’autres tâches au lieu d’attendre activement, ce qui est plus efficace dans un environnement multi-usagers."
                },
                {
                    "id": 90,
                    "topic": "pc",
                    "question": "Quel est le rôle du bus de données dans les opérations d’E/S?",
                    "correctAnswer": ["bus de données", "transporter", "données", "périphériques"],
                    "explanation": "Le bus de données transporte les données entre l’UCT, la mémoire et les périphériques lors des opérations d’E/S."
                },
                {
                    "id": 91,
                    "topic": "basics",
                    "question": "Quel est le rôle de la mémoire dans un système d’E/S?",
                    "correctAnswer": ["mémoire", "stocker", "données", "temporaire"],
                    "explanation": "La mémoire stocke temporairement les données et les instructions échangées entre l’UCT et les périphériques."
                },
                {
                    "id": 92,
                    "topic": "peripherals",
                    "question": "Quel est le rôle d’un contrôleur pour un disque dur?",
                    "correctAnswer": ["contrôleur", "moteur", "activer", "données"],
                    "explanation": "Le contrôleur d’un disque dur active le moteur pour lire ou écrire des données sur le disque."
                },
                {
                    "id": 93,
                    "topic": "mechanisms",
                    "question": "Décrivez l’utilisation d’un registre de données dans une interface.",
                    "correctAnswer": ["registre de données", "stocker", "temporaire", "transmission"],
                    "explanation": "Un registre de données stocke temporairement les données avant leur transmission au périphérique ou à l’UCT."
                },
                {
                    "id": 94,
                    "topic": "synchronization",
                    "question": "Pourquoi l’interrogation de bits d’état consomme-t-elle beaucoup de temps CPU?",
                    "correctAnswer": ["interrogation", "attente active", "CPU", "temps"],
                    "explanation": "L’interrogation de bits d’état consomme du temps CPU car l’UCT doit attendre activement en vérifiant constamment l’état du périphérique."
                },
                {
                    "id": 95,
                    "topic": "pc",
                    "question": "Comment les fonctions de dos.h permettent-elles d’interagir avec les ports d’E/S?",
                    "correctAnswer": ["dos.h", "inport", "outport", "ports"],
                    "explanation": "Les fonctions de dos.h, comme inport(), inportb(), outport() et outportb(), permettent de lire ou écrire des données dans les ports d’E/S."
                },
                {
                    "id": 96,
                    "topic": "basics",
                    "question": "Pourquoi le contrôleur est-il essentiel pour les périphériques?",
                    "correctAnswer": ["contrôleur", "physique", "opérations", "périphérique"],
                    "explanation": "Le contrôleur est essentiel car il gère les opérations physiques du périphérique, comme déplacer une tête d’impression ou activer un moteur."
                },
                {
                    "id": 97,
                    "topic": "peripherals",
                    "question": "Quel est le rôle d’un écran dans un système informatique?",
                    "correctAnswer": ["écran", "afficher", "informations", "sortie"],
                    "explanation": "L’écran est un périphérique de sortie qui affiche des informations visuelles générées par l’ordinateur."
                },
                {
                    "id": 98,
                    "topic": "mechanisms",
                    "question": "Expliquez pourquoi un port d’E/S est associé à une interface.",
                    "correctAnswer": ["port", "interface", "adresse", "communication"],
                    "explanation": "Un port d’E/S est une adresse spécifique associée à une interface, permettant à l’UCT de communiquer avec un périphérique via cette interface."
                },
                {
                    "id": 99,
                    "topic": "synchronization",
                    "question": "Quel est l’avantage des interruptions par rapport à l’interrogation de bits d’état?",
                    "correctAnswer": ["interruptions", "efficace", "attente", "tâches"],
                    "explanation": "Les interruptions sont plus efficaces car elles permettent à l’UCT de faire d’autres tâches au lieu d’attendre activement l’état du périphérique."
                },
                {
                    "id": 100,
                    "topic": "pc",
                    "question": "Quel est l’objectif des signaux comme MEMR et MEMW dans les opérations d’E/S?",
                    "correctAnswer": ["signaux", "mémoire", "lecture", "écriture"],
                    "explanation": "Les signaux MEMR (lecture mémoire) et MEMW (écriture mémoire) indiquent le type d’opération mémoire effectnée, comme lire ou écrire des données."
                }
            ]
        },
        "flashcardData": [
            {
                "id": 1,
                "topic": "basics",
                "front": "Quel est le rôle des périphériques d’entrée/sortie?",
                "back": "Ils permettent la communication entre l’ordinateur et l’extérieur, en transmettant (entrée) ou recevant (sortie) des informations."
            },
            {
                "id": 2,
                "topic": "basics",
                "front": "Quels sont les composants clés d’un système d’E/S?",
                "back": "UCT, mémoire, bus, interface, contrôleur et périphérique."
            },
            {
                "id": 3,
                "topic": "peripherals",
                "front": "Nommez trois périphériques d’entrée.",
                "back": "Clavier, souris, microphone."
            },
            {
                "id": 4,
                "topic": "peripherals",
                "front": "Nommez trois périphériques de sortie.",
                "back": "Imprimante, écran, haut-parleur."
            },
            {
                "id": 5,
                "topic": "mechanisms",
                "front": "Qu’est-ce qu’un port d’E/S?",
                "back": "Une adresse spécifique associée à une interface, permettant à l’UCT de communiquer avec un périphérique via des instructions comme IN et OUT."
            },
            {
                "id": 6,
                "topic": "mechanisms",
                "front": "Définissez la projection en mémoire.",
                "back": "Une technique où les registres des périphériques sont mappés dans l’espace d’adresses mémoire, permettant un accès via des instructions mémoire standard."
            },
            {
                "id": 7,
                "topic": "synchronization",
                "front": "Qu’est-ce que la synchronisation synchrone?",
                "back": "Une méthode où l’UCT interroge activement l’état du périphérique via des bits d’état, attendant qu’il soit prêt."
            },
            {
                "id": 8,
                "topic": "synchronization",
                "front": "Qu’est-ce que la synchronisation asynchrone?",
                "back": "Une méthode où l’interface utilise des interruptions pour signaler à l’UCT qu’un périphérique est prêt ou qu’une opération est terminée."
            },
            {
                "id": 9,
                "topic": "pc",
                "front": "Quels sont les signaux de contrôle utilisés pour les opérations E/S?",
                "back": "IOR (lecture E/S), IOW (écriture E/S), MEMR (lecture mémoire), MEMW (écriture mémoire)."
            },
            {
                "id": 10,
                "topic": "pc",
                "front": "Quelles fonctions de dos.h permettent de manipuler les ports d’E/S?",
                "back": "outport() (écrire 16 bits), outportb() (écrire 8 bits), inport() (lire 16 bits), inportb() (lire 8 bits)."
            },
            {
                "id": 11,
                "topic": "basics",
                "front": "Quel est le rôle de l’UCT dans un système d’E/S?",
                "back": "L’UCT exécute les instructions et communique avec les périphériques via le bus et l’interface."
            },
            {
                "id": 12,
                "topic": "basics",
                "front": "Pourquoi l’UCT ne contrôle-t-elle pas directement les périphériques?",
                "back": "Cela serait trop complexe et inefficace, nécessitant une gestion directe des détails matériels."
            },
            {
                "id": 13,
                "topic": "peripherals",
                "front": "Quel est le rôle d’un disque dur dans un système informatique?",
                "back": "Il lit (entrée) et écrit (sortie) des données sur un support magnétique ou électronique."
            },
            {
                "id": 14,
                "topic": "peripherals",
                "front": "Quel est le rôle d’un contrôleur pour une imprimante?",
                "back": "Il déplace la tête d’impression pour imprimer des caractères ou des images."
            },
            {
                "id": 15,
                "topic": "mechanisms",
                "front": "Quel est l’avantage des ports d’E/S?",
                "back": "Ils ne réduisent pas l’espace d’adresses mémoire, contrairement à la projection en mémoire."
            },
            {
                "id": 16,
                "topic": "mechanisms",
                "front": "Quel est l’inconvénient de la projection en mémoire?",
                "back": "Elle réduit l’espace d’adresses mémoire disponible en réservant des adresses pour les registres."
            },
            {
                "id": 17,
                "topic": "synchronization",
                "front": "Pourquoi les interruptions sont-elles utilisées dans la synchronisation asynchrone?",
                "back": "Elles permettent à l’UCT de continuer d’autres tâches en attendant que le périphérique soit prêt."
            },
            {
                "id": 18,
                "topic": "synchronization",
                "front": "Quel est l’inconvénient de l’interrogation de bits d’état?",
                "back": "Elle consomme du temps CPU en attendant activement l’état du périphérique."
            },
            {
                "id": 19,
                "topic": "pc",
                "front": "Quel est le rôle du bus d’adresses?",
                "back": "Il transporte l’adresse spécifiant la destination des informations, comme une carte contrôleur."
            },
            {
                "id": 20,
                "topic": "pc",
                "front": "Quel est le rôle du comparateur dans une carte contrôleur?",
                "back": "Il vérifie si l’adresse envoyée par l’UCT correspond à celle de la carte."
            },
            {
                "id": 21,
                "topic": "basics",
                "front": "Quel est le rôle de la mémoire dans un système d’E/S?",
                "back": "Elle stocke temporairement les données et les instructions échangées avec les périphériques."
            },
            {
                "id": 22,
                "topic": "basics",
                "front": "Qu’est-ce que le bus dans un système d’E/S?",
                "back": "Un canal de communication transportant les données, adresses et signaux de contrôle."
            },
            {
                "id": 23,
                "topic": "peripherals",
                "front": "Quel est le rôle d’un microphone?",
                "back": "Il transmet des données audio à l’ordinateur en tant que périphérique d’entrée."
            },
            {
                "id": 24,
                "topic": "peripherals",
                "front": "Quel est le rôle d’un haut-parleur?",
                "back": "Il produit du son à partir des données reçues de l’ordinateur, en tant que périphérique de sortie."
            },
            {
                "id": 25,
                "topic": "mechanisms",
                "front": "Qu’est-ce qu’un registre d’index?",
                "back": "Un registre permettant de sélectionner un registre spécifique dans une interface via un port."
            },
            {
                "id": 26,
                "topic": "mechanisms",
                "front": "Quel type d’instruction est utilisé dans la projection en mémoire?",
                "back": "Des instructions mémoire standard, comme MOV."
            },
            {
                "id": 27,
                "topic": "synchronization",
                "front": "Qu’est-ce qu’un registre d’état?",
                "back": "Un registre indiquant l’état de l’interface, comme inactif, en attente ou en erreur."
            },
            {
                "id": 28,
                "topic": "synchronization",
                "front": "Pourquoi la synchronisation est-elle nécessaire pour les E/S?",
                "back": "Pour compenser les différences de vitesse entre l’UCT et les périphériques."
            },
            {
                "id": 29,
                "topic": "pc",
                "front": "Quel est l’espace d’adresses des ports d’E/S pour un Intel 8086?",
                "back": "16 bits, permettant d’adresser 64K ports."
            },
            {
                "id": 30,
                "topic": "pc",
                "front": "Quel est le rôle du bus de données?",
                "back": "Il transporte les données entre l’UCT, la mémoire et les périphériques."
            },
            {
                "id": 31,
                "topic": "basics",
                "front": "Quel est le rôle du contrôleur dans un système d’E/S?",
                "back": "Il gère les opérations physiques du périphérique, comme activer un moteur."
            },
            {
                "id": 32,
                "topic": "basics",
                "front": "Pourquoi l’interface est-elle nécessaire dans un système d’E/S?",
                "back": "Elle traduit les commandes de l’UCT en instructions pour le contrôleur."
            },
            {
                "id": 33,
                "topic": "peripherals",
                "front": "Quel est le rôle d’un écran?",
                "back": "Il affiche des informations visuelles en tant que périphérique de sortie."
            },
            {
                "id": 34,
                "topic": "peripherals",
                "front": "Quel est le rôle d’un clavier?",
                "back": "Il transmet des commandes textuelles à l’ordinateur en tant que périphérique d’entrée."
            },
            {
                "id": 35,
                "topic": "mechanisms",
                "front": "Quel est le rôle d’un registre de données?",
                "back": "Il stocke temporairement des données avant leur transmission au périphérique ou à l’UCT."
            },
            {
                "id": 36,
                "topic": "mechanisms",
                "front": "Pourquoi les ports d’E/S simplifient-ils la gestion des périphériques?",
                "back": "Ils isolent l’UCT des détails matériels, gérés par l’interface."
            },
            {
                "id": 37,
                "topic": "synchronization",
                "front": "Qu’est-ce qu’une interruption dans la synchronisation asynchrone?",
                "back": "Un signal envoyé par l’interface pour indiquer que le périphérique est prêt."
            },
            {
                "id": 38,
                "topic": "synchronization",
                "front": "Quel est l’inconvénient des interruptions?",
                "back": "Elles sont complexes à gérer, nécessitant une programmation élaborée."
            },
            {
                "id": 39,
                "topic": "pc",
                "front": "Quel est le rôle du signal IOR?",
                "back": "Il indique une opération de lecture dans un port d’E/S."
            },
            {
                "id": 40,
                "topic": "pc",
                "front": "Quel est le rôle du signal IOW?",
                "back": "Il indique une opération d’écriture dans un port d’E/S."
            },
            {
                "id": 41,
                "topic": "basics",
                "front": "Qu’est-ce que l’UCT dans un système informatique?",
                "back": "L’Unité Centrale de Traitement qui exécute les instructions et gère les opérations."
            },
            {
                "id": 42,
                "topic": "basics",
                "front": "Quel est le rôle du bus dans les opérations d’E/S?",
                "back": "Il transporte les données, adresses et signaux de contrôle entre les composants."
            },
            {
                "id": 43,
                "topic": "peripherals",
                "front": "Quel est le rôle d’un disque dur comme périphérique d’entrée?",
                "back": "Il lit des données stockées sur un support magnétique ou électronique."
            },
            {
                "id": 44,
                "topic": "peripherals",
                "front": "Quel est le rôle d’un disque dur comme périphérique de sortie?",
                "back": "Il écrit des données sur un support magnétique ou électronique."
            },
            {
                "id": 45,
                "topic": "mechanisms",
                "front": "Qu’est-ce qu’un registre de commande?",
                "back": "Un registre recevant des instructions de l’UCT pour contrôler l’interface ou le périphérique."
            },
            {
                "id": 46,
                "topic": "mechanisms",
                "front": "Pourquoi un registre d’index réduit-il le nombre de ports?",
                "back": "Il permet de sélectionner un registre spécifique via une seule adresse de port."
            },
            {
                "id": 47,
                "topic": "synchronization",
                "front": "Qu’est-ce que l’interrogation de bits d’état?",
                "back": "Une méthode où l’UCT vérifie activement l’état du périphérique via un registre."
            },
            {
                "id": 48,
                "topic": "synchronization",
                "front": "Pourquoi les interruptions sont-elles plus efficaces?",
                "back": "Elles permettent à l’UCT de ne pas attendre activement, libérant du temps pour d’autres tâches."
            },
            {
                "id": 49,
                "topic": "pc",
                "front": "Quel est le rôle du signal MEMR?",
                "back": "Il indique une opération de lecture en mémoire."
            },
            {
                "id": 50,
                "topic": "pc",
                "front": "Quel est le rôle du signal MEMW?",
                "back": "Il indique une opération d’écriture en mémoire."
            }
        ]
    },
    "ch-2": {
        "name": "Organisation des Systèmes d'Exploitation (ECS 150)",
        "description": "Introduction à l'organisation et au fonctionnement des systèmes d'exploitation",
        "topics": {
            "introduction": { "name": "Introduction" },
            "composants_système": { "name": "Composants du Système" },
            "interrupts": { "name": "Interruptions" },
            "structure_os": { "name": "Structure des Systèmes d'Exploitation" },
            "microkernel": { "name": "Microkernel" },
            "services_os": { "name": "Services des Systèmes d'Exploitation" },
            "couches_os": { "name": "Systèmes en Couches" },
            "modules": { "name": "Modules du Noyau" },
            "interaction_os": { "name": "Interaction avec le Système d'Exploitation" },
            "évolution_os": { "name": "Évolution des Systèmes d'Exploitation" }
        },
        "quizData": {
            "multiple-choice": [
                {
                    "id": 1,
                    "topic": "composants_système",
                    "question": "Quel est le rôle principal du compteur de programme (PC) dans un CPU ?",
                    "options": [
                        "Stocker l'instruction en cours d'exécution",
                        "Contenir l'adresse de la prochaine instruction à récupérer",
                        "Gérer l'allocation de mémoire pour les programmes",
                        "Contrôler les opérations d'entrée/sortie"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Le compteur de programme (PC) contient l'adresse de la prochaine instruction à récupérer, guidant la séquence d'exécution du CPU."
                },
                {
                    "id": 2,
                    "topic": "interrupts",
                    "question": "Quel type d'interruption est généré par une défaillance matérielle ?",
                    "options": [
                        "Interruption de programme",
                        "Interruption de temporisation",
                        "Interruption d'E/S",
                        "Interruption de défaillance matérielle"
                    ],
                    "correctAnswer": 3,
                    "explanation": "Une interruption de défaillance matérielle est déclenchée par des événements comme une panne de courant ou une erreur de parité mémoire."
                },
                {
                    "id": 3,
                    "topic": "structure_os",
                    "question": "Quelle est une caractéristique clé d'un système d'exploitation monolithique ?",
                    "options": [
                        "Divisé en couches indépendantes",
                        "Noyau minimal avec processus au niveau utilisateur",
                        "Noyau volumineux gérant la plupart des fonctions",
                        "Utilise des modules orientés objet"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Un OS monolithique possède un noyau volumineux qui gère la plupart des fonctions, comme UNIX."
                },
                {
                    "id": 4,
                    "topic": "microkernel",
                    "question": "Quel est un avantage principal de l'architecture microkernel ?",
                    "options": [
                        "Performance élevée grâce à moins de changements de contexte",
                        "Meilleure fiabilité grâce à l'isolation des composants",
                        "Mise en œuvre plus simple que les noyaux monolithiques",
                        "Accès direct au matériel pour tous les processus"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les microkernels améliorent la fiabilité en isolant les composants, limitant l'impact d'une défaillance."
                },
                {
                    "id": 5,
                    "topic": "services_os",
                    "question": "Quel service du système d'exploitation garantit un accès contrôlé aux ressources ?",
                    "options": [
                        "Exécution de programme",
                        "Manipulation du système de fichiers",
                        "Protection et sécurité",
                        "Interface utilisateur"
                    ],
                    "correctAnswer": 2,
                    "explanation": "La protection et la sécurité garantissent un accès contrôlé aux ressources, évitant les utilisations non autorisées."
                },
                {
                    "id": 6,
                    "topic": "couches_os",
                    "question": "Quel est un inconvénient majeur d'un système d'exploitation strictement en couches ?",
                    "options": [
                        "Inflexible en raison de la structure hiérarchique",
                        "Fiabilité élevée grâce à la conception modulaire",
                        "Performance rapide entre les couches",
                        "Processus de débogage simplifié"
                    ],
                    "correctAnswer": 0,
                    "explanation": "Une structure strictement hiérarchique est inflexible car les systèmes réels nécessitent souvent des dépendances bidirectionnelles."
                },
                {
                    "id": 7,
                    "topic": "modules",
                    "question": "Comment les modules du noyau améliorent-ils la flexibilité du système d'exploitation ?",
                    "options": [
                        "En exécutant tous les composants en mode utilisateur",
                        "En permettant le chargement des composants selon les besoins",
                        "En imposant un système strictement en couches",
                        "En réduisant la taille du noyau"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les modules du noyau permettent un chargement dynamique des composants, offrant une flexibilité accrue."
                },
                {
                    "id": 8,
                    "topic": "interaction_os",
                    "question": "Quelle interface a été inventée au Xerox PARC et est couramment utilisée dans les OS modernes ?",
                    "options": [
                        "Interface en ligne de commande (CLI)",
                        "Interface graphique utilisateur (GUI)",
                        "Interface par lots",
                        "Shell textuel"
                    ],
                    "correctAnswer": 1,
                    "explanation": "L'interface graphique (GUI), avec icônes et interactions par souris, a été inventée au Xerox PARC."
                },
                {
                    "id": 9,
                    "topic": "composants_système",
                    "question": "Quel registre contient l'instruction récemment récupérée ?",
                    "options": [
                        "Compteur de programme (PC)",
                        "Registre d'instruction (IR)",
                        "Registre d'adresse mémoire",
                        "Registre d'état de programme (PSW)"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Le registre d'instruction (IR) contient l'instruction récemment récupérée pour le décodage et l'exécution."
                },
                {
                    "id": 10,
                    "topic": "interrupts",
                    "question": "Quel type d'interruption permet à l'OS d'effectuer des tâches régulières ?",
                    "options": [
                        "Interruption de programme",
                        "Interruption de temporisation",
                        "Interruption d'E/S",
                        "Interruption matérielle"
                    ],
                    "correctAnswer": 1,
                    "explanation": "L'interruption de temporisation, générée par un minuteur, permet des tâches régulières comme la planification."
                },
                {
                    "id": 11,
                    "topic": "structure_os",
                    "question": "Quel système d'exploitation est un exemple de structure monolithique ?",
                    "options": [
                        "Minix",
                        "Mac OS X",
                        "UNIX",
                        "Windows NT"
                    ],
                    "correctAnswer": 2,
                    "explanation": "UNIX utilise une structure monolithique avec un noyau gérant la plupart des fonctions."
                },
                {
                    "id": 12,
                    "topic": "microkernel",
                    "question": "Quel est un inconvénient des microkernels ?",
                    "options": [
                        "Faible fiabilité",
                        "Performance réduite due aux changements de contexte",
                        "Complexité de mise en œuvre réduite",
                        "Manque de modularité"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les microkernels ont une performance réduite en raison des fréquents passages utilisateur/noyau."
                },
                {
                    "id": 13,
                    "topic": "services_os",
                    "question": "Quel service OS gère la communication entre processus ?",
                    "options": [
                        "Exécution de programme",
                        "Manipulation du système de fichiers",
                        "Communication",
                        "Détection d'erreurs"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Le service de communication permet l'échange d'informations entre processus via mémoire partagée ou messages."
                },
                {
                    "id": 14,
                    "topic": "couches_os",
                    "question": "Quel système a introduit l'approche en couches pour les OS ?",
                    "options": [
                        "UNIX",
                        "THE system",
                        "Minix",
                        "Linux"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Le système THE de Dijkstra a introduit l'approche en couches pour les systèmes d'exploitation."
                },
                {
                    "id": 15,
                    "topic": "modules",
                    "question": "Quel OS utilise une approche modulaire pour son noyau ?",
                    "options": [
                        "Solaris",
                        "Minix",
                        "Mac OS X",
                        "UNIX"
                    ],
                    "correctAnswer": 0,
                    "explanation": "Solaris utilise une approche modulaire, permettant un chargement dynamique des composants du noyau."
                },
                {
                    "id": 16,
                    "topic": "interaction_os",
                    "question": "Quel type d'interface est souvent implémenté sous forme de shell ?",
                    "options": [
                        "Interface graphique (GUI)",
                        "Interface en ligne de commande (CLI)",
                        "Interface par lots",
                        "Interface utilisateur native"
                    ],
                    "correctAnswer": 1,
                    "explanation": "La CLI est souvent implémentée sous forme de shell, permettant l'exécution de commandes utilisateur."
                },
                {
                    "id": 17,
                    "topic": "composants_système",
                    "question": "Quel composant relie les processeurs, la mémoire et les modules E/S ?",
                    "options": [
                        "Bus système",
                        "Mémoire principale",
                        "Registre de contrôle",
                        "Unité de gestion de mémoire"
                    ],
                    "correctAnswer": 0,
                    "explanation": "Le bus système assure la communication entre les processeurs, la mémoire et les modules E/S."
                },
                {
                    "id": 18,
                    "topic": "interrupts",
                    "question": "Quelle condition peut déclencher une interruption de programme ?",
                    "options": [
                        "Panne de courant",
                        "Surcharge arithmétique",
                        "Achèvement d'une opération E/S",
                        "Expiration d'un minuteur"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Une surcharge arithmétique est une condition qui déclenche une interruption de programme."
                },
                {
                    "id": 19,
                    "topic": "structure_os",
                    "question": "Quel OS combine un microkernel avec des services utilisateur ?",
                    "options": [
                        "UNIX",
                        "Linux",
                        "Mac OS X",
                        "Solaris"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Mac OS X utilise un microkernel avec des services exécutés en mode utilisateur."
                },
                {
                    "id": 20,
                    "topic": "microkernel",
                    "question": "Quel système a été le premier à utiliser une architecture microkernel ?",
                    "options": [
                        "Mach",
                        "Hydra",
                        "Chorus",
                        "Minix"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Hydra, développé en 1970 par CMU, a été le premier système microkernel."
                },
                {
                    "id": 21,
                    "topic": "services_os",
                    "question": "Quel service OS permet la gestion des erreurs matérielles ?",
                    "options": [
                        "Exécution de programme",
                        "Détection d'erreurs",
                        "Allocation de ressources",
                        "Protection"
                    ],
                    "correctAnswer": 1,
                    "explanation": "La détection d'erreurs surveille les erreurs matérielles et logicielles pour assurer une exécution correcte."
                },
                {
                    "id": 22,
                    "topic": "couches_os",
                    "question": "Quel est un problème de performance dans un OS en couches ?",
                    "options": [
                        "Complexité réduite",
                        "Surcharge due au passage entre couches",
                        "Fiabilité accrue",
                        "Portabilité améliorée"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Le passage entre couches entraîne une surcharge, réduisant les performances."
                },
                {
                    "id": 23,
                    "topic": "modules",
                    "question": "Quelle caractéristique des modules du noyau est similaire aux couches ?",
                    "options": [
                        "Exécution en mode utilisateur",
                        "Interfaces connues entre composants",
                        "Structure hiérarchique stricte",
                        "Taille minimale du noyau"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les modules communiquent via des interfaces connues, comme dans une structure en couches."
                },
                {
                    "id": 24,
                    "topic": "interaction_os",
                    "question": "Quel OS combine une interface GUI Aqua avec un noyau UNIX ?",
                    "options": [
                        "Windows",
                        "Mac OS X",
                        "Solaris",
                        "Linux"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Mac OS X utilise l'interface GUI Aqua avec un noyau basé sur UNIX."
                },
                {
                    "id": 25,
                    "topic": "composants_système",
                    "question": "Quel registre contient les codes de condition ?",
                    "options": [
                        "Compteur de programme (PC)",
                        "Registre d'instruction (IR)",
                        "Mot d'état de programme (PSW)",
                        "Registre d'adresse mémoire"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Le mot d'état de programme (PSW) contient les codes de condition, comme les résultats positifs ou négatifs."
                },
                {
                    "id": 26,
                    "topic": "interrupts",
                    "question": "Quel type d'interruption est généré par un contrôleur E/S ?",
                    "options": [
                        "Interruption de programme",
                        "Interruption de temporisation",
                        "Interruption d'E/S",
                        "Interruption matérielle"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Les interruptions d'E/S sont générées par des contrôleurs E/S pour signaler l'achèvement ou des erreurs."
                },
                {
                    "id": 27,
                    "topic": "structure_os",
                    "question": "Quel OS est structuré avec un noyau minimal et des serveurs utilisateur ?",
                    "options": [
                        "UNIX",
                        "Linux",
                        "Minix",
                        "Windows"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Minix utilise un noyau minimal avec des services comme la gestion de fichiers en mode utilisateur."
                },
                {
                    "id": 28,
                    "topic": "microkernel",
                    "question": "Quel OS utilise un microkernel pour une meilleure portabilité ?",
                    "options": [
                        "Linux",
                        "Windows NT",
                        "Chorus",
                        "UNIX"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Chorus, un OS de type UNIX, utilise un microkernel pour une meilleure portabilité."
                },
                {
                    "id": 29,
                    "topic": "services_os",
                    "question": "Quel service OS gère l'exécution des programmes utilisateur ?",
                    "options": [
                        "Interface utilisateur",
                        "Exécution de programme",
                        "Manipulation de fichiers",
                        "Communication"
                    ],
                    "correctAnswer": 1,
                    "explanation": "L'exécution de programme charge et exécute les programmes utilisateur en mémoire."
                },
                {
                    "id": 30,
                    "topic": "couches_os",
                    "question": "Quel niveau du système THE gère les consoles virtuelles ?",
                    "options": [
                        "Niveau 1",
                        "Niveau 2",
                        "Niveau 3",
                        "Niveau 4"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Le niveau 3 (Console Manager) gère les consoles virtuelles dans le système THE."
                },
                {
                    "id": 31,
                    "topic": "modules",
                    "question": "Quel OS utilise des modules pour une flexibilité accrue ?",
                    "options": [
                        "Minix",
                        "Linux",
                        "UNIX",
                        "Mac OS X"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Linux utilise des modules du noyau pour une flexibilité et une modularité accrues."
                },
                {
                    "id": 32,
                    "topic": "interaction_os",
                    "question": "Quel type de commande est souvent intégré dans un shell CLI ?",
                    "options": [
                        "Commandes graphiques",
                        "Commandes intégrées",
                        "Commandes réseau",
                        "Commandes matérielles"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les shells CLI exécutent souvent des commandes intégrées ou des noms de programmes."
                },
                {
                    "id": 33,
                    "topic": "composants_système",
                    "question": "Quel type de mémoire est volatile ?",
                    "options": [
                        "Mémoire principale",
                        "Mémoire secondaire",
                        "Mémoire cache",
                        "Mémoire ROM"
                    ],
                    "correctAnswer": 0,
                    "explanation": "La mémoire principale est volatile, perdant ses données sans alimentation."
                },
                {
                    "id": 34,
                    "topic": "interrupts",
                    "question": "Quel mécanisme suspend l'exécution normale du processeur ?",
                    "options": [
                        "Appel système",
                        "Interruption",
                        "Allocation de mémoire",
                        "Planification"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Une interruption suspend l'exécution normale pour traiter un événement spécifique."
                },
                {
                    "id": 35,
                    "topic": "structure_os",
                    "question": "Quel OS a une structure en deux parties : programmes système et noyau ?",
                    "options": [
                        "Linux",
                        "UNIX",
                        "Minix",
                        "Windows"
                    ],
                    "correctAnswer": 1,
                    "explanation": "UNIX est structuré en programmes système et un noyau gérant les fonctions principales."
                },
                {
                    "id": 36,
                    "topic": "microkernel",
                    "question": "Quel OS utilise un microkernel pour une meilleure sécurité ?",
                    "options": [
                        "Linux",
                        "Mac OS X",
                        "UNIX",
                        "Solaris"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Mac OS X utilise un microkernel pour isoler les composants, améliorant la sécurité."
                },
                {
                    "id": 37,
                    "topic": "services_os",
                    "question": "Quel service OS gère les permissions des fichiers ?",
                    "options": [
                        "Exécution de programme",
                        "Manipulation du système de fichiers",
                        "Communication",
                        "Allocation de ressources"
                    ],
                    "correctAnswer": 1,
                    "explanation": "La manipulation du système de fichiers gère les permissions, la création et la suppression de fichiers."
                },
                {
                    "id": 38,
                    "topic": "couches_os",
                    "question": "Quel niveau du système THE gère les processeurs virtuels ?",
                    "options": [
                        "Niveau 0",
                        "Niveau 1",
                        "Niveau 2",
                        "Niveau 3"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Le niveau 1 (Kernel) gère les processeurs virtuels dans le système THE."
                },
                {
                    "id": 39,
                    "topic": "modules",
                    "question": "Quel OS utilise une approche orientée objet pour les modules ?",
                    "options": [
                        "UNIX",
                        "Linux",
                        "Minix",
                        "Windows"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Linux utilise une approche orientée objet pour ses modules, avec des interfaces définies."
                },
                {
                    "id": 40,
                    "topic": "interaction_os",
                    "question": "Quel OS utilise une interface CLI avec un GUI optionnel ?",
                    "options": [
                        "Windows",
                        "Mac OS X",
                        "Solaris",
                        "Linux"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Solaris utilise une CLI avec des interfaces GUI optionnelles comme Java Desktop."
                },
                {
                    "id": 41,
                    "topic": "composants_système",
                    "question": "Quel registre est utilisé pour minimiser les références à la mémoire principale ?",
                    "options": [
                        "Registre utilisateur",
                        "Registre de contrôle",
                        "Registre d'état",
                        "Registre d'E/S"
                    ],
                    "correctAnswer": 0,
                    "explanation": "Les registres utilisateur (données, adresses) minimisent les accès à la mémoire principale."
                },
                {
                    "id": 42,
                    "topic": "interrupts",
                    "question": "Quel type d'interruption signale l'achèvement d'une opération E/S ?",
                    "options": [
                        "Interruption de programme",
                        "Interruption de temporisation",
                        "Interruption d'E/S",
                        "Interruption matérielle"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Les interruptions d'E/S signalent l'achèvement ou les erreurs des opérations E/S."
                },
                {
                    "id": 43,
                    "topic": "structure_os",
                    "question": "Quel OS utilise une structure modulaire pour son noyau ?",
                    "options": [
                        "UNIX",
                        "Windows",
                        "Solaris",
                        "Minix"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Solaris utilise une structure modulaire pour une flexibilité accrue du noyau."
                },
                {
                    "id": 44,
                    "topic": "microkernel",
                    "question": "Quel OS a été influencé par l'architecture microkernel de Mach ?",
                    "options": [
                        "Linux",
                        "Windows NT",
                        "Mac OS X",
                        "Solaris"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Mac OS X utilise une architecture microkernel influencée par Mach."
                },
                {
                    "id": 45,
                    "topic": "services_os",
                    "question": "Quel service OS surveille l'utilisation des ressources par les utilisateurs ?",
                    "options": [
                        "Comptabilité",
                        "Protection",
                        "Exécution de programme",
                        "Communication"
                    ],
                    "correctAnswer": 0,
                    "explanation": "La comptabilité suit l'utilisation des ressources par les utilisateurs."
                },
                {
                    "id": 46,
                    "topic": "couches_os",
                    "question": "Quel niveau du système THE gère les périphériques ?",
                    "options": [
                        "Niveau 2",
                        "Niveau 3",
                        "Niveau 4",
                        "Niveau 5"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Le niveau 4 (Device Managers) gère les périphériques dans le système THE."
                },
                {
                    "id": 47,
                    "topic": "modules",
                    "question": "Quel OS permet le chargement dynamique des modules du noyau ?",
                    "options": [
                        "UNIX",
                        "Minix",
                        "Windows",
                        "Linux"
                    ],
                    "correctAnswer": 3,
                    "explanation": "Linux permet le chargement dynamique des modules du noyau pour une flexibilité accrue."
                },
                {
                    "id": 48,
                    "topic": "interaction_os",
                    "question": "Quel type d'interface utilise des icônes et une souris ?",
                    "options": [
                        "Interface en ligne de commande",
                        "Interface graphique",
                        "Interface par lots",
                        "Interface textuelle"
                    ],
                    "correctAnswer": 1,
                    "explanation": "L'interface graphique (GUI) utilise des icônes et une souris pour l'interaction."
                },
                {
                    "id": 49,
                    "topic": "composants_système",
                    "question": "Quel composant est appelé mémoire réelle ou primaire ?",
                    "options": [
                        "Mémoire secondaire",
                        "Mémoire principale",
                        "Mémoire cache",
                        "Mémoire ROM"
                    ],
                    "correctAnswer": 1,
                    "explanation": "La mémoire principale est appelée mémoire réelle ou primaire."
                },
                {
                    "id": 50,
                    "topic": "interrupts",
                    "question": "Quel mécanisme exécute un gestionnaire d'interruption ?",
                    "options": [
                        "Cycle d'instruction",
                        "Cycle d'interruption",
                        "Appel système",
                        "Planification"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Le cycle d'interruption vérifie les interruptions et exécute le gestionnaire approprié."
                },
                {
                    "id": 51,
                    "topic": "structure_os",
                    "question": "Quel OS a une structure en deux parties avec un noyau volumineux ?",
                    "options": [
                        "Minix",
                        "Linux",
                        "UNIX",
                        "Mac OS X"
                    ],
                    "correctAnswer": 2,
                    "explanation": "UNIX a une structure en deux parties : programmes système et un noyau volumineux."
                },
                {
                    "id": 52,
                    "topic": "microkernel",
                    "question": "Quel OS utilise un microkernel pour une meilleure extensibilité ?",
                    "options": [
                        "Linux",
                        "Windows NT",
                        "Chorus",
                        "UNIX"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Chorus utilise un microkernel pour une meilleure extensibilité."
                },
                {
                    "id": 53,
                    "topic": "services_os",
                    "question": "Quel service OS gère les erreurs logicielles ?",
                    "options": [
                        "Exécution de programme",
                        "Détection d'erreurs",
                        "Allocation de ressources",
                        "Protection"
                    ],
                    "correctAnswer": 1,
                    "explanation": "La détection d'erreurs gère les erreurs logicielles pour assurer une exécution correcte."
                },
                {
                    "id": 54,
                    "topic": "couches_os",
                    "question": "Quel niveau du système THE gère les programmes utilisateur ?",
                    "options": [
                        "Niveau 3",
                        "Niveau 4",
                        "Niveau 5",
                        "Niveau 6"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Le niveau 5 (Job Managers) gère les programmes utilisateur dans le système THE."
                },
                {
                    "id": 55,
                    "topic": "modules",
                    "question": "Quel OS utilise des modules pour une meilleure portabilité ?",
                    "options": [
                        "UNIX",
                        "Linux",
                        "Minix",
                        "Windows"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Linux utilise des modules pour améliorer la portabilité et la modularité."
                },
                {
                    "id": 56,
                    "topic": "interaction_os",
                    "question": "Quel OS utilise une interface GUI avec une CLI en option ?",
                    "options": [
                        "Windows",
                        "Mac OS X",
                        "Solaris",
                        "Linux"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Mac OS X utilise une GUI (Aqua) avec une CLI optionnelle via des shells."
                },
                {
                    "id": 57,
                    "topic": "composants_système",
                    "question": "Quel registre contrôle le mode superviseur/utilisateur ?",
                    "options": [
                        "Compteur de programme",
                        "Registre d'instruction",
                        "Mot d'état de programme (PSW)",
                        "Registre d'adresse mémoire"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Le PSW contrôle le mode superviseur ou utilisateur du processeur."
                },
                {
                    "id": 58,
                    "topic": "interrupts",
                    "question": "Quel type d'interruption est causé par une division par zéro ?",
                    "options": [
                        "Interruption de programme",
                        "Interruption de temporisation",
                        "Interruption d'E/S",
                        "Interruption matérielle"
                    ],
                    "correctAnswer": 0,
                    "explanation": "Une division par zéro déclenche une interruption de programme."
                },
                {
                    "id": 59,
                    "topic": "structure_os",
                    "question": "Quel OS utilise une structure modulaire pour une meilleure flexibilité ?",
                    "options": [
                        "UNIX",
                        "Windows",
                        "Solaris",
                        "Minix"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Solaris utilise une structure modulaire pour une meilleure flexibilité."
                },
                {
                    "id": 60,
                    "topic": "microkernel",
                    "question": "Quel OS utilise un microkernel pour une meilleure fiabilité ?",
                    "options": [
                        "Linux",
                        "Windows NT",
                        "Minix",
                        "UNIX"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Minix utilise un microkernel pour une meilleure fiabilité grâce à l'isolation."
                },
                {
                    "id": 61,
                    "topic": "services_os",
                    "question": "Quel service OS gère l'authentification des utilisateurs ?",
                    "options": [
                        "Exécution de programme",
                        "Protection et sécurité",
                        "Manipulation de fichiers",
                        "Communication"
                    ],
                    "correctAnswer": 1,
                    "explanation": "La protection et la sécurité gèrent l'authentification des utilisateurs."
                },
                {
                    "id": 62,
                    "topic": "couches_os",
                    "question": "Quel niveau du système THE gère la mémoire virtuelle ?",
                    "options": [
                        "Niveau 1",
                        "Niveau 2",
                        "Niveau 3",
                        "Niveau 4"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Le niveau 2 (Page Manager) gère la mémoire virtuelle dans le système THE."
                },
                {
                    "id": 63,
                    "topic": "modules",
                    "question": "Quel OS utilise des modules pour une meilleure modularité ?",
                    "options": [
                        "UNIX",
                        "Linux",
                        "Minix",
                        "Windows"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Linux utilise des modules pour une meilleure modularité et flexibilité."
                },
                {
                    "id": 64,
                    "topic": "interaction_os",
                    "question": "Quel type d'interface est utilisé dans Windows avec un shell CLI ?",
                    "options": [
                        "Interface graphique",
                        "Interface en ligne de commande",
                        "Interface par lots",
                        "Interface textuelle"
                    ],
                    "correctAnswer": 0,
                    "explanation": "Windows utilise une interface graphique avec un shell CLI optionnel."
                },
                {
                    "id": 65,
                    "topic": "composants_système",
                    "question": "Quel composant est utilisé pour les périphériques secondaires ?",
                    "options": [
                        "Mémoire principale",
                        "Modules E/S",
                        "Bus système",
                        "Processeur"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les modules E/S gèrent les périphériques secondaires comme les disques."
                },
                {
                    "id": 66,
                    "topic": "interrupts",
                    "question": "Quel mécanisme vérifie les interruptions en attente ?",
                    "options": [
                        "Cycle d'instruction",
                        "Cycle d'interruption",
                        "Appel système",
                        "Planification"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Le cycle d'interruption vérifie les interruptions en attente et exécute les gestionnaires."
                },
                {
                    "id": 67,
                    "topic": "structure_os",
                    "question": "Quel OS utilise une structure monolithique avec des modules ?",
                    "options": [
                        "Minix",
                        "Linux",
                        "Mac OS X",
                        "Windows NT"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Linux utilise une structure monolithique avec des modules pour plus de flexibilité."
                },
                {
                    "id": 68,
                    "topic": "microkernel",
                    "question": "Quel OS utilise un microkernel pour une meilleure personnalisation ?",
                    "options": [
                        "Linux",
                        "Windows NT",
                        "Mach",
                        "UNIX"
                    ],
                    "correctAnswer": 2,
                    "explanation": "Mach utilise un microkernel pour une meilleure personnalisation."
                },
                {
                    "id": 69,
                    "topic": "services_os",
                    "question": "Quel service OS gère les opérations E/S ?",
                    "options": [
                        "Exécution de programme",
                        "Opérations E/S",
                        "Manipulation de fichiers",
                        "Communication"
                    ],
                    "correctAnswer": 1,
                    "explanation": "Les opérations E/S gèrent les interactions avec les fichiers ou périphériques."
                },
                {
                    "id": 70,
                    "topic": "couches_os",
                    "question": "Quel niveau du système THE est le matériel ?",
                    "options": [
                        "Niveau 0",
                        "Niveau 1",
                        "Niveau 2",
                        "Niveau 3"
                    ],
                    "correctAnswer": 0,
                    "explanation": "Le niveau 0 représente le matériel dans le système THE."
                }
            ],
            "true-false": [
                {
                    "id": 71,
                    "topic": "composants_système",
                    "question": "La mémoire principale est non volatile et conserve les données après une mise hors tension.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. La mémoire principale est volatile et perd ses données sans alimentation."
                },
                {
                    "id": 72,
                    "topic": "interrupts",
                    "question": "Les interruptions permettent au processeur d'attendre les périphériques lents sans suspendre l'exécution.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 0,
                    "explanation": "Vrai. Les interruptions permettent de gérer les périphériques lents en suspendant temporairement l'exécution."
                },
                {
                    "id": 73,
                    "topic": "structure_os",
                    "question": "UNIX est un exemple de système d'exploitation basé sur un microkernel.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. UNIX utilise un noyau monolithique."
                },
                {
                    "id": 74,
                    "topic": "microkernel",
                    "question": "Les microkernels ont généralement de meilleures performances que les noyaux monolithiques.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. Les microkernels ont souvent des performances inférieures en raison des changements de contexte."
                },
                {
                    "id": 75,
                    "topic": "services_os",
                    "question": "Les systèmes d'exploitation fournissent des services d'allocation de ressources pour gérer les processus concurrents.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 0,
                    "explanation": "Vrai. L'allocation de ressources gère les processus concurrents efficacement."
                },
                {
                    "id": 76,
                    "topic": "couches_os",
                    "question": "Un système en couches est toujours plus flexible qu'un système monolithique.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. Un système en couches peut être moins flexible en raison de sa structure hiérarchique."
                },
                {
                    "id": 77,
                    "topic": "modules",
                    "question": "Les modules du noyau sont chargés de manière statique dans le noyau.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. Les modules du noyau peuvent être chargés dynamiquement selon les besoins."
                },
                {
                    "id": 78,
                    "topic": "interaction_os",
                    "question": "Les interfaces GUI nécessitent toujours une interface CLI sous-jacente.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. Les GUI peuvent fonctionner indépendamment d'une CLI."
                },
                {
                    "id": 79,
                    "topic": "composants_système",
                    "question": "Les registres utilisateur sont utilisés uniquement par le système d'exploitation.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. Les registres utilisateur sont accessibles aux programmeurs pour optimiser l'utilisation."
                },
                {
                    "id": 80,
                    "topic": "interrupts",
                    "question": "Les interruptions d'E/S sont toujours déclenchées par des erreurs.",
                    "options": ["Vrai", "Faux"],
                    "correctAnswer": 1,
                    "explanation": "Faux. Les interruptions d'E/S signalent l'achèvement ou des erreurs d'opérations."
                }
            ],
            "short-answer": [
                {
                    "id": 81,
                    "topic": "composants_système",
                    "question": "Décrivez le rôle du registre d'instruction (IR) dans le cycle d'exécution du CPU.",
                    "correctAnswer": ["instruction", "récupérée", "contient", "exécution"],
                    "explanation": "Le registre d'instruction (IR) contient l'instruction récemment récupérée pour le décodage et l'exécution par le CPU."
                },
                {
                    "id": 82,
                    "topic": "interrupts",
                    "question": "Expliquez comment un gestionnaire d'interruption répond à une interruption.",
                    "correctAnswer": ["suspend", "exécute", "gère", "reprend"],
                    "explanation": "Un gestionnaire d'interruption suspend le programme en cours, exécute une routine pour gérer l'événement, puis reprend l'exécution normale."
                },
                {
                    "id": 83,
                    "topic": "structure_os",
                    "question": "Quelle est la différence entre un noyau monolithique et un microkernel ?",
                    "correctAnswer": ["monolithique", "microkernel", "taille", "utilisateur"],
                    "explanation": "Un noyau monolithique intègre la plupart des fonctions dans un grand noyau, tandis qu'un microkernel minimise le noyau, exécutant les services en mode utilisateur."
                },
                {
                    "id": 84,
                    "topic": "services_os",
                    "question": "Comment le système d'exploitation facilite-t-il la communication entre processus ?",
                    "correctAnswer": ["mémoire partagée", "passage de messages", "réseau", "processus"],
                    "explanation": "L'OS permet la communication via mémoire partagée pour les processus locaux ou passage de messages pour les systèmes en réseau."
                },
                {
                    "id": 85,
                    "topic": "couches_os",
                    "question": "Décrivez la fonction du gestionnaire de pages dans un OS en couches.",
                    "correctAnswer": ["mémoire virtuelle", "processus", "gestion", "pages"],
                    "explanation": "Le gestionnaire de pages implémente la mémoire virtuelle pour chaque processus, gérant l'allocation et la pagination."
                },
                {
                    "id": 86,
                    "topic": "modules",
                    "question": "Expliquez comment les modules du noyau améliorent la flexibilité de l'OS.",
                    "correctAnswer": ["chargement dynamique", "composants", "interfaces", "flexibilité"],
                    "explanation": "Les modules du noyau permettent un chargement dynamique des composants via des interfaces définies, offrant une flexibilité accrue."
                },
                {
                    "id": 87,
                    "topic": "interaction_os",
                    "question": "Comment un shell CLI exécute-t-il les commandes utilisateur ?",
                    "correctAnswer": ["commandes intégrées", "programmes", "exécute", "utilisateur"],
                    "explanation": "Un shell CLI exécute des commandes intégrées ou des programmes en interprétant les entrées de l'utilisateur."
                },
                {
                    "id": 88,
                    "topic": "composants_système",
                    "question": "Quel est le rôle du bus système dans un ordinateur ?",
                    "correctAnswer": ["communication", "processeurs", "mémoire", "E/S"],
                    "explanation": "Le bus système facilite la communication entre les processeurs, la mémoire et les modules E/S."
                },
                {
                    "id": 89,
                    "topic": "interrupts",
                    "question": "Décrivez le cycle d'interruption dans un processeur.",
                    "correctAnswer": ["vérifie", "suspend", "exécute", "reprend"],
                    "explanation": "Le processeur vérifie les interruptions, suspend le programme, exécute le gestionnaire d'interruption, puis reprend l'exécution."
                },
                {
                    "id": 90,
                    "topic": "structure_os",
                    "question": "Pourquoi UNIX est-il considéré comme un OS monolithique ?",
                    "correctAnswer": ["noyau", "fonctions", "interface", "système"],
                    "explanation": "UNIX est monolithique car son noyau gère la plupart des fonctions sous l'interface d'appel système."
                },
                {
                    "id": 91,
                    "topic": "microkernel",
                    "question": "Comment un microkernel améliore-t-il la fiabilité ?",
                    "correctAnswer": ["isolation", "composants", "utilisateur", "défaillance"],
                    "explanation": "Un microkernel isole les composants en mode utilisateur, limitant l'impact d'une défaillance."
                },
                {
                    "id": 92,
                    "topic": "services_os",
                    "question": "Quel est le rôle du service de protection dans un OS ?",
                    "correctAnswer": ["contrôle", "accès", "ressources", "sécurité"],
                    "explanation": "La protection contrôle l'accès aux ressources, empêchant les interférences entre processus."
                },
                {
                    "id": 93,
                    "topic": "couches_os",
                    "question": "Pourquoi une structure en couches peut-elle poser des problèmes de performance ?",
                    "correctAnswer": ["surcharge", "passage", "couches", "performance"],
                    "explanation": "Le passage entre couches entraîne une surcharge, réduisant les performances globales."
                },
                {
                    "id": 94,
                    "topic": "modules",
                    "question": "Comment les modules du noyau sont-ils intégrés dans Linux ?",
                    "correctAnswer": ["chargement", "dynamique", "interfaces", "noyau"],
                    "explanation": "Les modules sont chargés dynamiquement dans le noyau Linux via des interfaces définies."
                },
                {
                    "id": 95,
                    "topic": "interaction_os",
                    "question": "Comment une interface GUI interagit-elle avec l'utilisateur ?",
                    "correctAnswer": ["icônes", "souris", "actions", "interface"],
                    "explanation": "Une GUI utilise des icônes, une souris et des actions pour permettre une interaction intuitive."
                },
                {
                    "id": 96,
                    "topic": "composants_système",
                    "question": "Quel est le rôle des registres de contrôle et d'état ?",
                    "correctAnswer": ["contrôle", "processeur", "exécution", "privilégié"],
                    "explanation": "Les registres de contrôle et d'état gèrent les opérations du processeur et l'exécution des programmes privilégiés."
                },
                {
                    "id": 97,
                    "topic": "interrupts",
                    "question": "Pourquoi les interruptions sont-elles nécessaires pour les périphériques lents ?",
                    "correctAnswer": ["attente", "processeur", "efficacité", "périphériques"],
                    "explanation": "Les interruptions évitent que le processeur attende les périphériques lents, améliorant l'efficacité."
                },
                {
                    "id": 98,
                    "topic": "structure_os",
                    "question": "Décrivez la structure du noyau de Minix.",
                    "correctAnswer": ["microkernel", "serveurs", "utilisateur", "minimal"],
                    "explanation": "Minix utilise un microkernel minimal avec des serveurs (gestion de fichiers, mémoire) en mode utilisateur."
                },
                {
                    "id": 99,
                    "topic": "microkernel",
                    "question": "Pourquoi les microkernels sont-ils plus portables ?",
                    "correctAnswer": ["indépendance", "matériel", "serveurs", "utilisateur"],
                    "explanation": "Les microkernels isolent les dépendances matérielles, rendant les serveurs utilisateur plus portables."
                },
                {
                    "id": 100,
                    "topic": "services_os",
                    "question": "Comment l'OS gère-t-il les erreurs matérielles ?",
                    "correctAnswer": ["détection", "erreurs", "action", "cohérence"],
                    "explanation": "L'OS détecte les erreurs matérielles et prend des actions pour maintenir la cohérence du système."
                }
            ]
        },
        "flashcardData": [
            {
                "id": 1,
                "topic": "composants_système",
                "front": "Quels sont les éléments de base d'un système informatique ?",
                "back": "Processeur (CPU), mémoire principale (volatile), modules E/S (mémoire secondaire, communications, terminaux) et bus système."
            },
            {
                "id": 2,
                "topic": "composants_système",
                "front": "Quel est le rôle des registres de processeur ?",
                "back": "Optimisent l'utilisation de la mémoire, contrôlent les opérations du processeur et gèrent l'exécution des programmes."
            },
            {
                "id": 3,
                "topic": "interrupts",
                "front": "Quels sont les types d'interruptions dans un système informatique ?",
                "back": "Programme (ex. surcharge), temporisation (tâches régulières), E/S (signaux périphériques), défaillance matérielle (ex. pannes)."
            },
            {
                "id": 4,
                "topic": "interrupts",
                "front": "Comment fonctionne le cycle d'interruption ?",
                "back": "Le processeur vérifie les interruptions, suspend le programme, exécute le gestionnaire, puis reprend l'exécution."
            },
            {
                "id": 5,
                "topic": "structure_os",
                "front": "Qu'est-ce qu'un système d'exploitation monolithique ?",
                "back": "Un OS avec un grand noyau gérant la plupart des fonctions, comme UNIX, simple mais moins modulaire."
            },
            {
                "id": 6,
                "topic": "structure_os",
                "front": "Qu'est-ce qu'un système d'exploitation en couches ?",
                "back": "Un OS divisé en niveaux (ex. matériel, noyau, gestionnaire de pages), comme le système THE, testable indépendamment."
            },
            {
                "id": 7,
                "topic": "microkernel",
                "front": "Qu'est-ce qui définit une architecture microkernel ?",
                "back": "Un noyau minimal gérant les mécanismes de base, avec d'autres services en mode utilisateur pour fiabilité et flexibilité."
            },
            {
                "id": 8,
                "topic": "services_os",
                "front": "Quels sont les services clés de l'OS pour les utilisateurs ?",
                "back": "Interface utilisateur (CLI/GUI), exécution de programme, opérations E/S, gestion de fichiers, communication, détection d'erreurs."
            },
            {
                "id": 9,
                "topic": "services_os",
                "front": "Quels services OS assurent une opération efficace du système ?",
                "back": "Allocation de ressources, comptabilité, protection et sécurité pour gérer les processus et l'accès."
            },
            {
                "id": 10,
                "topic": "interaction_os",
                "front": "Comment les applications interagissent-elles avec l'OS ?",
                "back": "Via des appels système, en utilisant une CLI (commandes) ou GUI (icônes, souris), comme subroutines ou client-serveur."
            },
            {
                "id": 11,
                "topic": "composants_système",
                "front": "Qu'est-ce que la mémoire principale ?",
                "back": "Mémoire volatile, appelée mémoire réelle ou primaire, utilisée pour stocker les données temporairement."
            },
            {
                "id": 12,
                "topic": "interrupts",
                "front": "Pourquoi les interruptions sont-elles importantes ?",
                "back": "Elles permettent au processeur de gérer les périphériques lents ou les événements critiques sans attente active."
            },
            {
                "id": 13,
                "topic": "structure_os",
                "front": "Quelle est la structure d'UNIX ?",
                "back": "Deux parties : programmes système et un noyau monolithique gérant les fonctions principales."
            },
            {
                "id": 14,
                "topic": "microkernel",
                "front": "Quels sont les avantages des microkernels ?",
                "back": "Fiabilité, extensibilité, personnalisation, portabilité grâce à l'isolation des composants."
            },
            {
                "id": 15,
                "topic": "services_os",
                "front": "Quel est le rôle de la détection d'erreurs dans un OS ?",
                "back": "Surveille les erreurs matérielles et logicielles pour assurer une exécution correcte et cohérente."
            },
            {
                "id": 16,
                "topic": "couches_os",
                "front": "Quels sont les niveaux du système THE ?",
                "back": "Niveau 0 (matériel), 1 (noyau), 2 (gestionnaire de pages), 3 (consoles), 4 (périphériques), 5 (programmes utilisateur)."
            },
            {
                "id": 17,
                "topic": "modules",
                "front": "Que sont les modules du noyau ?",
                "back": "Composants séparés, chargeables dynamiquement, communiquant via des interfaces définies, comme dans Linux."
            },
            {
                "id": 18,
                "topic": "interaction_os",
                "front": "Qu'est-ce qu'une interface GUI ?",
                "back": "Une interface utilisant des icônes, une souris et des actions pour une interaction utilisateur intuitive."
            },
            {
                "id": 19,
                "topic": "composants_système",
                "front": "Quel est le rôle du compteur de programme (PC) ?",
                "back": "Contient l'adresse de la prochaine instruction à récupérer, guidant l'exécution du CPU."
            },
            {
                "id": 20,
                "topic": "interrupts",
                "front": "Qu'est-ce qu'une interruption de programme ?",
                "back": "Déclenchée par des conditions comme une surcharge arithmétique ou une instruction illégale."
            },
            {
                "id": 21,
                "topic": "structure_os",
                "front": "Qu'est-ce que le noyau dans UNIX ?",
                "back": "Tout ce qui se trouve sous l'interface d'appel système et au-dessus du matériel, gérant les fonctions principales."
            },
            {
                "id": 22,
                "topic": "microkernel",
                "front": "Quel est un exemple de système microkernel ?",
                "back": "Minix, avec un noyau minimal et des serveurs utilisateur pour la gestion de fichiers et de mémoire."
            },
            {
                "id": 23,
                "topic": "services_os",
                "front": "Quel est le rôle de l'allocation de ressources ?",
                "back": "Distribue les ressources (CPU, mémoire, E/S) entre les processus concurrents pour une exécution efficace."
            },
            {
                "id": 24,
                "topic": "couches_os",
                "front": "Pourquoi une structure en couches peut-elle être inflexible ?",
                "back": "En raison de relations unidirectionnelles qui ne permettent pas des dépendances bidirectionnelles complexes."
            },
            {
                "id": 25,
                "topic": "modules",
                "front": "Comment Solaris utilise-t-il les modules ?",
                "back": "Via une approche modulaire permettant un chargement dynamique des composants du noyau."
            },
            {
                "id": 26,
                "topic": "interaction_os",
                "front": "Qu'est-ce qu'un shell CLI ?",
                "back": "Un programme qui interprète et exécute les commandes utilisateur, souvent intégré ou externe."
            },
            {
                "id": 27,
                "topic": "composants_système",
                "front": "Qu'est-ce que le mot d'état de programme (PSW) ?",
                "back": "Un registre contenant les codes de condition et les informations sur le mode (superviseur/utilisateur)."
            },
            {
                "id": 28,
                "topic": "interrupts",
                "front": "Qu'est-ce qu'une interruption d'E/S ?",
                "back": "Déclenchée par un contrôleur E/S pour signaler l'achèvement ou une erreur d'opération."
            },
            {
                "id": 29,
                "topic": "structure_os",
                "front": "Qu'est-ce que Linux utilise pour sa structure ?",
                "back": "Un noyau monolithique avec des modules chargeables dynamiquement pour plus de flexibilité."
            },
            {
                "id": 30,
                "topic": "microkernel",
                "front": "Pourquoi les microkernels ont-ils une performance réduite ?",
                "back": "En raison des fréquents passages entre le mode utilisateur et le mode noyau."
            },
            {
                "id": 31,
                "topic": "services_os",
                "front": "Quel est le rôle de la protection et de la sécurité ?",
                "back": "Contrôler l'accès aux ressources et authentifier les utilisateurs pour éviter les interférences."
            },
            {
                "id": 32,
                "topic": "couches_os",
                "front": "Quel est le rôle du gestionnaire de périphériques dans le système THE ?",
                "back": "Gérer les périphériques et fournir une mise en mémoire tampon (niveau 4)."
            },
            {
                "id": 33,
                "topic": "modules",
                "front": "Qu'est-ce qui rend les modules du noyau flexibles ?",
                "back": "Leur capacité à être chargés dynamiquement et à communiquer via des interfaces définies."
            },
            {
                "id": 34,
                "topic": "interaction_os",
                "front": "Quel OS utilise l'interface Aqua ?",
                "back": "Mac OS X, combinant une GUI Aqua avec un noyau UNIX."
            },
            {
                "id": 35,
                "topic": "composants_système",
                "front": "Quels sont les modules E/S ?",
                "back": "Périphériques de mémoire secondaire, équipements de communication et terminaux."
            },
            {
                "id": 36,
                "topic": "interrupts",
                "front": "Qu'est-ce qu'une interruption de temporisation ?",
                "back": "Générée par un minuteur pour permettre des tâches régulières de l'OS."
            },
            {
                "id": 37,
                "topic": "structure_os",
                "front": "Qu'est-ce que la structure de Minix ?",
                "back": "Un microkernel avec des serveurs utilisateur pour la gestion de fichiers, mémoire, etc."
            },
            {
                "id": 38,
                "topic": "microkernel",
                "front": "Quel est un exemple de microkernel utilisé dans un OS commercial ?",
                "back": "Mach, utilisé dans Mac OS X pour sa fiabilité et extensibilité."
            },
            {
                "id": 39,
                "topic": "services_os",
                "front": "Quel est le rôle de la manipulation du système de fichiers ?",
                "back": "Gérer la lecture, l'écriture, la création, la suppression et les permissions des fichiers."
            },
            {
                "id": 40,
                "topic": "couches_os",
                "front": "Quel est le rôle du noyau dans le système THE ?",
                "back": "Implémenter un processeur virtuel pour chaque processus (niveau 1)."
            },
            {
                "id": 41,
                "topic": "modules",
                "front": "Pourquoi Linux utilise-t-il des modules ?",
                "back": "Pour permettre une modularité, une flexibilité et une portabilité accrues."
            },
            {
                "id": 42,
                "topic": "interaction_os",
                "front": "Qu'est-ce qu'une interface par lots ?",
                "back": "Une interface où les tâches sont soumises en groupe pour un traitement séquentiel."
            },
            {
                "id": 43,
                "topic": "composants_système",
                "front": "Qu'est-ce que le registre d'adresse mémoire ?",
                "back": "Un registre contenant l'adresse mémoire pour les opérations de lecture/écriture."
            },
            {
                "id": 44,
                "topic": "interrupts",
                "front": "Qu'est-ce qu'une interruption matérielle ?",
                "back": "Déclenchée par une défaillance matérielle, comme une panne de courant."
            },
            {
                "id": 45,
                "topic": "structure_os",
                "front": "Qu'est-ce que Solaris utilise pour son noyau ?",
                "back": "Une approche modulaire avec des composants chargeables dynamiquement."
            },
            {
                "id": 46,
                "topic": "microkernel",
                "front": "Pourquoi les microkernels sont-ils sécurisés ?",
                "back": "L'isolation des composants en mode utilisateur réduit les risques de défaillance globale."
            },
            {
                "id": 47,
                "topic": "services_os",
                "front": "Quel est le rôle de la comptabilité dans un OS ?",
                "back": "Suivre l'utilisation des ressources par les utilisateurs pour la gestion et la facturation."
            },
            {
                "id": 48,
                "topic": "couches_os",
                "front": "Quel est le rôle du gestionnaire de consoles dans le système THE ?",
                "back": "Implémenter des consoles virtuelles pour l'interaction utilisateur (niveau 3)."
            },
            {
                "id": 49,
                "topic": "modules",
                "front": "Comment les modules améliorent-ils la portabilité ?",
                "back": "En isolant les dépendances matérielles, facilitant l'adaptation à différentes architectures."
            },
            {
                "id": 50,
                "topic": "interaction_os",
                "front": "Quel OS utilise une CLI avec des GUI optionnelles comme KDE ?",
                "back": "Solaris, offrant une CLI de base avec des interfaces GUI optionnelles."
            }
        ]
    },
    "pratique": {
        "name": "Pratique",
        "description": "Pratiques des divers chapitre",
        "topics": {
            "io_systemes": { "name": "Introduction" },
            "processus": { "name": "Processus (ECS 150)" },
            "organisation_os": { "name": "Operating Systems (ECS 150)" },
            "introduction_os": { "name": "Entrées/Sorties Informatiques" }
        },
        "flashcardData": [],
        "quizData": {
            "pratique": [
                {
                    "id": 1,
                    "topic": "io_systemes",
                    "question": "Écrivez un programme C qui utilise la fonction `outportb` pour envoyer le caractère 'B' au port série COM1 (0x3F8) sur un système MS-DOS avec Borland C++.",
                    "solution": {
                        "code": "  \n#include <dos.h> \nint main() { \n    unsigned char data = 'B'; \n    outportb(0x3F8, data); \n    return 0; \n}",
                        "explanation": "La fonction `outportb` de `dos.h` envoie un octet au port spécifié. Ici, le caractère 'B' est envoyé au port COM1 (0x3F8), utilisé pour la communication série."
                    },
                    "level": "basic"
                },
                {
                    "id": 2,
                    "topic": "io_systemes",
                    "question": "Quelle est la différence entre un périphérique d'entrée et un périphérique de sortie ? Donnez un exemple de chaque.",
                    "solution": {
                        "correctAnswer": "Un périphérique d'entrée transmet des données à l'ordinateur (ex. clavier), tandis qu'un périphérique de sortie reçoit des données de l'ordinateur (ex. écran).",
                        "explanation": "Les périphériques d'entrée, comme le clavier, permettent à l'utilisateur d'envoyer des données, tandis que les périphériques de sortie, comme l'écran, affichent les résultats."
                    },
                    "level": "basic"
                },
                {
                    "id": 3,
                    "topic": "io_systemes",
                    "question": "Identifiez trois composants principaux d'un système d'E/S dans un ordinateur.",
                    "solution": {
                        "correctAnswer": "CPU, mémoire, bus système.",
                        "explanation": "Le CPU exécute les instructions, la mémoire stocke les données, et le bus système transporte les données, adresses et signaux de contrôle."
                    },
                    "level": "basic"
                },
                {
                    "id": 4,
                    "topic": "io_systemes",
                    "question": "Qu'est-ce qu'un port d'E/S ? Donnez un exemple de port utilisé pour la communication série.",
                    "solution": {
                        "correctAnswer": "Un port d'E/S est une adresse spécifique pour communiquer avec un périphérique. Exemple : 0x3F8 (COM1).",
                        "explanation": "Les ports d'E/S permettent au CPU d'envoyer ou de recevoir des données via des instructions comme IN et OUT."
                    },
                    "level": "basic"
                },
                {
                    "id": 5,
                    "topic": "io_systemes",
                    "question": "Écrivez un programme C qui lit un octet depuis le port 0x60 (données du clavier) sur un système MS-DOS.",
                    "solution": {
                        "code": " \n#include <dos.h> \n#include <stdio.h> \nint main() { \n    unsigned char data = inportb(0x60); \n    printf(\"Donnée lue : %c\n\", data); \n    return 0; \n}",
                        "explanation": "La fonction `inportb` lit un octet depuis le port 0x60, qui contient les données du clavier."
                    },
                    "level": "basic"
                },
                {
                    "id": 6,
                    "topic": "io_systemes",
                    "question": "Quel est le rôle de l'interface dans un système d'E/S ?",
                    "solution": {
                        "correctAnswer": "L'interface traduit les commandes du CPU en instructions pour le contrôleur du périphérique.",
                        "explanation": "Elle agit comme un pont entre le bus système et le contrôleur, assurant une communication correcte."
                    },
                    "level": "basic"
                },
                {
                    "id": 7,
                    "topic": "io_systemes",
                    "question": "Qu'est-ce que la synchronisation synchrone dans les opérations d'E/S ?",
                    "solution": {
                        "correctAnswer": "La synchronisation synchrone implique que le CPU interroge activement l'état du périphérique.",
                        "explanation": "Le CPU vérifie régulièrement si le périphérique est prêt, ce qui peut être inefficace."
                    },
                    "level": "basic"
                },
                {
                    "id": 8,
                    "topic": "io_systemes",
                    "question": "Donnez un exemple de périphérique qui peut être à la fois d'entrée et de sortie.",
                    "solution": {
                        "correctAnswer": "Disque dur.",
                        "explanation": "Un disque dur peut lire (entrée) et écrire (sortie) des données."
                    },
                    "level": "basic"
                },
                {
                    "id": 9,
                    "topic": "io_systemes",
                    "question": "Quelle est la fonction de la bibliothèque `dos.h` dans Borland C++ ?",
                    "solution": {
                        "correctAnswer": "Elle fournit des fonctions pour interagir avec le matériel à bas niveau, comme `outportb` et `inportb`.",
                        "explanation": "Utilisée dans MS-DOS pour gérer les ports d'E/S et les interruptions."
                    },
                    "level": "basic"
                },
                {
                    "id": 10,
                    "topic": "io_systemes",
                    "question": "Quel signal de contrôle indique une opération de lecture E/S ?",
                    "solution": {
                        "correctAnswer": "IOR (Input/Output Read).",
                        "explanation": "Le signal IOR indique que le CPU lit des données depuis un port d'E/S."
                    },
                    "level": "basic"
                },
                {
                    "id": 11,
                    "topic": "io_systemes",
                    "question": "Qu'est-ce que la projection en mémoire pour les E/S ?",
                    "solution": {
                        "correctAnswer": "Elle mappe les registres des périphériques dans l'espace d'adresses mémoire du CPU.",
                        "explanation": "Cela permet au CPU d'accéder aux registres comme à la mémoire ordinaire, simplifiant les opérations."
                    },
                    "level": "basic"
                },
                {
                    "id": 12,
                    "topic": "io_systemes",
                    "question": "Quel est le rôle du contrôleur dans un système d'E/S ?",
                    "solution": {
                        "correctAnswer": "Il gère le fonctionnement physique du périphérique.",
                        "explanation": "Par exemple, il déplace la tête d'impression d'une imprimante ou active le moteur d'un disque."
                    },
                    "level": "basic"
                },
                {
                    "id": 13,
                    "topic": "io_systemes",
                    "question": "Écrivez un programme C qui lit l'état d'un périphérique (port 0x64) et affiche si une touche est pressée (bit 0 à 1).",
                    "solution": {
                        "code": " \n#include <dos.h> \n#include <stdio.h> \nint main() { \n    unsigned char status = inportb(0x64); \n    if (status & 0x01) { \n        printf(\"Touche pressée\n\"); \n    } else { \n        printf(\"Aucune touche pressée\n\"); \n    } \n    return 0; \n}",
                        "explanation": "Le programme vérifie le bit 0 du port 0x64 pour détecter une touche pressée."
                    },
                    "level": "basic"
                },
                {
                    "id": 14,
                    "topic": "io_systemes",
                    "question": "Qu'est-ce qu'une interruption dans le contexte des E/S ?",
                    "solution": {
                        "correctAnswer": "Une interruption est un signal envoyé par un périphérique pour indiquer qu'il est prêt ou a terminé une opération.",
                        "explanation": "Elle permet au CPU de gérer les E/S sans attendre activement."
                    },
                    "level": "basic"
                },
                {
                    "id": 15,
                    "topic": "io_systemes",
                    "question": "Quel est l'avantage de la synchronisation asynchrone par rapport à la synchrone ?",
                    "solution": {
                        "correctAnswer": "Elle permet au CPU de continuer d'autres tâches en attendant l'E/S.",
                        "explanation": "Les interruptions notifient le CPU, évitant l'attente active."
                    },
                    "level": "basic"
                },
                {
                    "id": 16,
                    "topic": "io_systemes",
                    "question": "Donnez un exemple de signal de contrôle utilisé pour les opérations d'E/S.",
                    "solution": {
                        "correctAnswer": "IOW (Input/Output Write).",
                        "explanation": "Le signal IOW indique une opération d'écriture vers un port d'E/S."
                    },
                    "level": "basic"
                },
                {
                    "id": 17,
                    "topic": "io_systemes",
                    "question": "Quel est le rôle du bus système dans les opérations d'E/S ?",
                    "solution": {
                        "correctAnswer": "Il transporte les données, adresses et signaux entre le CPU, la mémoire et les périphériques.",
                        "explanation": "Le bus assure une communication efficace entre les composants."
                    },
                    "level": "basic"
                },
                {
                    "id": 18,
                    "topic": "io_systemes",
                    "question": "Qu'est-ce qu'un registre d'état dans une interface d'E/S ?",
                    "solution": {
                        "correctAnswer": "Un registre qui indique l'état du périphérique (ex. prêt, occupé).",
                        "explanation": "Il permet au CPU de vérifier si le périphérique est prêt pour une opération."
                    },
                    "level": "basic"
                },
                {
                    "id": 19,
                    "topic": "io_systemes",
                    "question": "Pourquoi les ports d'E/S sont-ils utilisés au lieu de la mémoire principale ?",
                    "solution": {
                        "correctAnswer": "Ils isolent les opérations E/S, évitant de réduire l'espace mémoire.",
                        "explanation": "Les ports utilisent un espace d'adresses distinct, préservant la mémoire."
                    },
                    "level": "basic"
                },
                {
                    "id": 20,
                    "topic": "io_systemes",
                    "question": "Quel est un exemple de fonction de `dos.h` pour écrire un mot (16 bits) ?",
                    "solution": {
                        "correctAnswer": "`outport`.",
                        "explanation": "La fonction `outport` écrit un mot de 16 bits à un port d'E/S spécifié."
                    },
                    "level": "basic"
                },
                {
                    "id": 21,
                    "topic": "io_systemes",
                    "question": "Écrivez un programme C qui utilise le polling pour vérifier si un clavier est prêt (port 0x64, bit 0 à 1) et lit la touche pressée (port 0x60).",
                    "solution": {
                        "code": " \n#include <dos.h> \n#include <stdio.h> \nint main() { \n    unsigned char status, key; \n    do { \n        status = inportb(0x64); \n    } while (!(status & 0x01)); \n    key = inportb(0x60); \n    printf(\"Touche pressée : %c\n\", key); \n    return 0; \n}",
                        "explanation": "Le programme vérifie le bit 0 du port 0x64 (statut) pour détecter une touche, puis lit la touche depuis le port 0x60."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 22,
                    "topic": "io_systemes",
                    "question": "Expliquez comment un registre d'index est utilisé pour accéder à plusieurs registres dans une interface d'E/S.",
                    "solution": {
                        "correctAnswer": "Un registre d'index sélectionne un registre spécifique en écrivant une valeur dans un port d'index, puis les données sont lues/écrites via un port de données.",
                        "explanation": "Cela réduit le nombre de ports nécessaires, simplifiant la gestion des interfaces complexes."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 23,
                    "topic": "io_systemes",
                    "question": "Calculez le temps CPU gaspillé par le polling si un périphérique prend 100 ms pour être prêt et le CPU vérifie toutes les 1 ms.",
                    "solution": {
                        "correctAnswer": "100 ms.",
                        "explanation": "Le CPU vérifie 100 fois (100 ms / 1 ms), gaspillant 100 ms en attente active."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 24,
                    "topic": "io_systemes",
                    "question": "Écrivez un programme C qui envoie une chaîne 'Hello' au port série COM1 (0x3F8) caractère par caractère.",
                    "solution": {
                        "code": "\n #include <dos.h>\n #include <string.h>\n int main() {\n     char *str = \"Hello\";\n     for (int i = 0; i < strlen(str); i++) {\n         outportb(0x3F8, str[i]);\n     }\n     return 0;\n }",
                        "explanation": "Chaque caractère de la chaîne est envoyé séquentiellement au port COM1."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 25,
                    "topic": "io_systemes",
                    "question": "Comment les interruptions améliorent-elles l'efficacité par rapport au polling pour un périphérique lent comme une imprimante ?",
                    "solution": {
                        "correctAnswer": "Les interruptions permettent au CPU d'exécuter d'autres tâches en attendant l'imprimante, contrairement au polling qui gaspille du temps CPU.",
                        "explanation": "L'imprimante envoie une interruption lorsqu'elle est prête, libérant le CPU pour d'autres opérations."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 26,
                    "topic": "io_systemes",
                    "question": "Concevez un scénario où le polling est préférable aux interruptions pour une opération d'E/S.",
                    "solution": {
                        "correctAnswer": "Pour un périphérique très rapide avec des données disponibles toutes les microsecondes, le polling peut être plus efficace.",
                        "explanation": "Le coût des interruptions (changement de contexte) peut dépasser le temps d'attente pour un périphérique rapide."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 27,
                    "topic": "io_systemes",
                    "question": "Écrivez un programme C qui lit 10 octets depuis le port 0x60 et les stocke dans un tableau.",
                    "solution": {
                        "code": " \n#include <dos.h> \n#include <stdio.h> \nint main() { \n    unsigned char buffer[10]; \n    for (int i = 0; i < 10; i++) { \n        buffer[i] = inportb(0x60); \n        printf(\"Octet %d : %c\n\", i, buffer[i]); \n    } \n    return 0; \n}",
                        "explanation": "Le programme lit 10 octets consécutifs depuis le port 0x60 et les stocke dans un tableau."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 28,
                    "topic": "io_systemes",
                    "question": "Expliquez pourquoi la projection en mémoire peut réduire l'espace d'adresses mémoire disponible.",
                    "solution": {
                        "correctAnswer": "Elle réserve des adresses mémoire pour les registres des périphériques, réduisant l'espace pour les programmes.",
                        "explanation": "Les adresses mappées ne peuvent pas être utilisées pour d'autres données ou instructions."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 29,
                    "topic": "io_systemes",
                    "question": "Calculez le nombre d'interruptions nécessaires pour transférer 1 Ko de données si chaque interruption transfère 16 octets.",
                    "solution": {
                        "correctAnswer": "64 interruptions.",
                        "explanation": "1 Ko = 1024 octets. 1024 / 16 = 64 interruptions."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 30,
                    "topic": "io_systemes",
                    "question": "Écrivez un programme C qui utilise `outport` pour envoyer un mot (16 bits) au port 0x3F8.",
                    "solution": {
                        "code": " \n#include <dos.h> \nint main() { \n    unsigned int data = 0x4142; // 'AB' \n    outport(0x3F8, data); \n    return 0; \n}",
                        "explanation": "La fonction `outport` envoie un mot de 16 bits au port COM1."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 31,
                    "topic": "io_systemes",
                    "question": "Comment un comparateur sur une carte contrôleur détermine-t-il si une donnée lui est destinée ?",
                    "solution": {
                        "correctAnswer": "Il vérifie si l'adresse envoyée sur le bus correspond à celle de la carte.",
                        "explanation": "Si l'adresse correspond et un signal comme IOR est actif, la carte accepte les données."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 32,
                    "topic": "io_systemes",
                    "question": "Écrivez un programme C qui simule le polling pour vérifier l'état d'un périphérique fictif toutes les 10 ms pendant 1 seconde.",
                    "solution": {
                        "code": " \n#include <stdio.h> \n#include <unistd.h> \nint main() { \n    for (int i = 0; i < 100; i++) { \n        printf(\"Vérification de l'état à %d ms\n\", i * 10); \n        usleep(10000); // 10 ms \n    } \n    return 0; \n}",
                        "explanation": "Le programme simule le polling en vérifiant l'état toutes les 10 ms pendant 1 seconde."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 33,
                    "topic": "io_systemes",
                    "question": "Expliquez comment un contrôleur de disque gère une opération de lecture.",
                    "solution": {
                        "correctAnswer": "Il active le moteur, positionne la tête de lecture, lit les données et les transfère via le bus.",
                        "explanation": "Le contrôleur traduit les commandes du CPU en actions physiques sur le disque."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 34,
                    "topic": "io_systemes",
                    "question": "Calculez le temps total pour transférer 512 octets si chaque interruption transfère 8 octets et chaque interruption prend 1 ms.",
                    "solution": {
                        "correctAnswer": "64 ms.",
                        "explanation": "512 / 8 = 64 interruptions, chacune prenant 1 ms."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 35,
                    "topic": "io_systemes",
                    "question": "Écrivez un programme C qui lit l'état d'un périphérique (port 0x64) et affiche si une touche est pressée (bit 0 à 1).",
                    "solution": {
                        "code": " \n#include <dos.h> \n#include <stdio.h> \nint main() { \n    unsigned char status = inportb(0x64); \n    if (status & 0x01) { \n        printf(\"Touche pressée\n\"); \n    } else { \n        printf(\"Aucune touche pressée\n\"); \n    } \n    return 0; \n}",
                        "explanation": "Le programme vérifie le bit 0 du port 0x64 pour détecter une touche pressée."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 36,
                    "topic": "io_systemes",
                    "question": "Pourquoi les interruptions sont-elles plus complexes à gérer que le polling ?",
                    "solution": {
                        "correctAnswer": "Elles nécessitent la gestion des vecteurs d'interruption et des routines de service.",
                        "explanation": "Les interruptions impliquent des changements de contexte et une programmation plus complexe."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 37,
                    "topic": "io_systemes",
                    "question": "Écrivez un programme C qui simule une interruption en vérifiant un drapeau toutes les 100 ms.",
                    "solution": {
                        "code": " \n#include <stdio.h> \n#include <unistd.h> \nint main() { \n    int flag = 0; \n    for (int i = 0; i < 10; i++) { \n        if (flag) { \n            printf(\"Interruption détectée à %d ms\n\", i * 100); \n            flag = 0; \n        } \n        usleep(100000); // 100 ms \n    } \n    return 0; \n}",
                        "explanation": "Le programme simule une interruption en vérifiant un drapeau toutes les 100 ms."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 38,
                    "topic": "io_systemes",
                    "question": "Expliquez comment le DMA (Direct Memory Access) améliore les performances des E/S.",
                    "solution": {
                        "correctAnswer": "Le DMA transfère les données directement entre la mémoire et le périphérique sans impliquer le CPU.",
                        "explanation": "Cela libère le CPU pour d'autres tâches, réduisant la surcharge."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 39,
                    "topic": "io_systemes",
                    "question": "Calculez le débit de données si un périphérique transfère 64 octets par interruption, avec 100 interruptions par seconde.",
                    "solution": {
                        "correctAnswer": "6400 octets/seconde.",
                        "explanation": "64 octets * 100 interruptions = 6400 octets par seconde."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 40,
                    "topic": "io_systemes",
                    "question": "Écrivez un programme C qui envoie une séquence de nombres (0 à 9) au port 0x3F8.",
                    "solution": {
                        "code": " \n#include <dos.h> \nint main() { \n    for (int i = 0; i < 10; i++) { \n        outportb(0x3F8, i + '0'); \n    } \n    return 0; \n}",
                        "explanation": "Le programme envoie les caractères '0' à '9' au port COM1."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 41,
                    "topic": "io_systemes",
                    "question": "Concevez un gestionnaire d'interruption pour un clavier dans un OS hypothétique. Le gestionnaire doit stocker les touches dans un tampon circulaire et notifier l'OS.",
                    "solution": {
                        "code": " \n#define BUFFER_SIZE 10 \nunsigned char buffer[BUFFER_SIZE]; \nint in = 0, out = 0; \nint key_pressed_flag = 0; \nvoid keyboard_isr() { \n    unsigned char key = inportb(0x60); \n    buffer[in] = key; \n    in = (in + 1) % BUFFER_SIZE; \n    key_pressed_flag = 1; \n    outportb(0x20, 0x20); // Fin d'interruption \n}",
                        "explanation": "Le gestionnaire lit la touche depuis le port 0x60, la stocke dans un tampon circulaire, met à jour l'index, et notifie l'OS via un drapeau."
                    },
                    "level": "advanced"
                },
                {
                    "id": 42,
                    "topic": "io_systemes",
                    "question": "Implémentez un planificateur d'E/S round-robin pour trois périphériques (clavier, disque, imprimante) avec des taux de 10, 5, et 2 E/S par seconde. Assurez un accès équitable.",
                    "solution": {
                        "code": " \n#include <stdio.h> \n#include <unistd.h> \nint main() { \n    int rates[] = {10, 5, 2}; // Clavier, disque, imprimante \n    int quanta[] = {100, 200, 500}; // ms \n    for (int t = 0; t < 1000; t += 100) { \n        for (int i = 0; i < 3; i++) { \n            printf(\"Périphérique %d à %d ms\n\", i, t); \n            usleep(quanta[i] * 1000); \n        } \n    } \n    return 0; \n}",
                        "explanation": "Chaque périphérique reçoit un quantum inversement proportionnel à son taux, assurant un accès équitable."
                    },
                    "level": "advanced"
                },
                {
                    "id": 43,
                    "topic": "io_systemes",
                    "question": "Expliquez comment le DMA (Direct Memory Access) transfère des données sans impliquer le CPU. Décrivez les étapes.",
                    "solution": {
                        "correctAnswer": "1. Le CPU configure le contrôleur DMA avec la source, la destination et la taille. 2. Le DMA prend le contrôle du bus. 3. Il transfère les données directement. 4. Il envoie une interruption au CPU à la fin.",
                        "explanation": "Le DMA libère le CPU, améliorant l'efficacité des transferts de données volumineux."
                    },
                    "level": "advanced"
                },
                {
                    "id": 44,
                    "topic": "io_systemes",
                    "question": "Écrivez un programme C qui simule un planificateur d'E/S FCFS pour 5 requêtes de disque à des positions [10, 20, 30, 40, 50]. Calculez l'ordre et le temps total.",
                    "solution": {
                        "code": "\n #include <stdio.h>\n int main() {\n     int requests[] = {10, 20, 30, 40, 50};\n     int n = 5;\n     printf(\"Ordre FCFS : \");\n     for (int i = 0; i < n; i++) {\n         printf(\"%d \", requests[i]);\n     }\n     printf(\"\nTemps total : %d ms\n\", n * 10); // 10 ms par requête\n     return 0;\n }",
                        "explanation": "Le planificateur FCFS traite les requêtes dans l'ordre d'arrivée, avec un temps total de 50 ms (5 * 10 ms)."
                    },
                    "level": "advanced"
                },
                {
                    "id": 45,
                    "topic": "io_systemes",
                    "question": "Concevez un système d'E/S pour un périphérique avec un registre d'index et plusieurs registres de données. Expliquez comment le CPU accède à un registre spécifique.",
                    "solution": {
                        "correctAnswer": "Le CPU écrit l'index du registre cible dans le port d'index (ex. 0x3F9), puis lit ou écrit des données via le port de données (ex. 0x3F8).",
                        "explanation": "Le registre d'index sélectionne un registre spécifique (ex. état, contrôle). Le CPU envoie l'index au port d'index, puis accède aux données via le port de données, réduisant le nombre de ports nécessaires."
                    },
                    "level": "advanced"
                },
                {
                    "id": 46,
                    "topic": "io_systemes",
                    "question": "Comparez les performances du polling et des interruptions pour une imprimante lente transférant 100 octets à 10 octets/seconde, avec un temps d'interruption de 1 ms et un polling toutes les 100 ms.",
                    "solution": {
                        "correctAnswer": "Interruptions : 10 ms ; Polling : 1000 ms.",
                        "explanation": "Le transfert prend 10 secondes (100 / 10). Interruptions : 10 interruptions (1 par seconde), chacune prenant 1 ms, soit 10 ms. Polling : vérifie toutes les 100 ms pendant 10 secondes, soit 100 vérifications (1000 ms). Les interruptions sont 100 fois plus efficaces."
                    },
                    "level": "advanced"
                },
                {
                    "id": 47,
                    "topic": "io_systemes",
                    "question": "Écrivez un programme C qui implémente un planificateur d'E/S SSTF (Shortest Seek Time First) pour des requêtes de disque à [15, 25, 5, 35, 10]. La tête est à 20. Calculez l'ordre et le temps total (1 ms par unité de déplacement.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <stdlib.h>\nint main() {\n    int requests[] = {15, 25, 5, 35, 10};\n    int head = 20, n = 5, total_time = 0;\n    int visited[5] = {0};\n    printf(\"Ordre SSTF : %d \", head);\n    for (int i = 0; i < n; i++) {\n        int min_dist = 1000, next = -1;\n        for (int j = 0; j < n; j++) {\n            if (!visited[j]) {\n                int dist = abs(requests[j] - head);\n                if (dist < min_dist) {\n                    min_dist = dist;\n                    next = j;\n                }\n            }\n        }\n        visited[next] = 1;\n        total_time += min_dist;\n        head = requests[next];\n        printf(\"%d \", head);\n    }\n    printf(\"\\nTemps total : %d ms\\n\", total_time);\n    return 0;\n}",
                        "explanation": "SSTF choisit la requête la plus proche de la tête (20). Ordre : 20 -> 15 -> 10 -> 5 -> 25 -> 35. Distances : |20-15|=5, |15-10|=5, |10-5|=5, |5-25|=20, |25-35|=10. Temps total : 5+5+5+20+10 = 45 ms."
                    },
                    "level": "advanced"
                },
                {
                    "id": 48,
                    "topic": "io_systemes",
                    "question": "Concevez un système d'E/S pour gérer plusieurs périphériques avec priorités (clavier : haute, disque : moyenne, imprimante : basse). Expliquez comment les interruptions sont traitées.",
                    "solution": {
                        "correctAnswer": "Utilisez un contrôleur d'interruptions programmable (PIC) avec des niveaux de priorité. Les interruptions du clavier (IRQ1) ont la priorité la plus élevée, suivies du disque (IRQ14) et de l'imprimante (IRQ7). Le PIC transmet les interruptions au CPU en fonction de leur priorité.",
                        "explanation": "Le PIC stocke les vecteurs d'interruption et masque les interruptions de priorité inférieure pendant le traitement d'une interruption de priorité supérieure, garantissant que le clavier est traité en premier."
                    },
                    "level": "advanced"
                },
                {
                    "id": 49,
                    "topic": "io_systemes",
                    "question": "Implémentez un simulateur en C pour un contrôleur DMA transférant 1 Ko de données en blocs de 64 octets, avec un temps de configuration de 2 ms et un temps de transfert de 0.5 ms par bloc.",
                    "solution": {
                        "code": "#include <stdio.h>\nint main() {\n    int total_data = 1024; // 1 Ko\n    int block_size = 64;\n    int blocks = total_data / block_size; // 16 blocs\n    float setup_time = 2.0; // ms\n    float transfer_time_per_block = 0.5; // ms\n    float total_time = setup_time + blocks * transfer_time_per_block;\n    printf(\"Nombre de blocs : %d\\n\", blocks);\n    printf(\"Temps total : %.2f ms\\n\", total_time);\n    return 0;\n}",
                        "explanation": "Le DMA transfère 1024 octets en 16 blocs (1024 / 64). Temps total = configuration (2 ms) + transfert (16 * 0.5 = 8 ms) = 10 ms."
                    },
                    "level": "advanced"
                },
                {
                    "id": 50,
                    "topic": "io_systemes",
                    "question": "Analysez les performances d'un système d'E/S utilisant le DMA par rapport aux interruptions pour transférer 10 Mo à 1 Mo/s. Supposez un temps d'interruption de 1 ms par 1 Ko. Fournissez une comparaison quantitative.",
                    "solution": {
                        "correctAnswer": "DMA : 10 s ; Interruptions : 10 s + 10 000 ms = 20 s.",
                        "explanation": "10 Mo = 10 240 Ko. DMA : transfère à 1 Mo/s (10 s). Interruptions : 10 240 Ko / 1 Ko par interruption = 10 240 interruptions, chacune prenant 1 ms (10 240 ms = 10.24 s). Temps total des interruptions = 10 s (transfert) + 10.24 s = 20.24 s. Le DMA est deux fois plus rapide."
                    },
                    "level": "advanced"
                },
                {
                    "id": 51,
                    "topic": "processus",
                    "question": "Écrivez un programme C sous Linux qui utilise `fork()` pour créer un processus enfant affichant 'Bonjour'.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\nint main() {\n    pid_t pid = fork();\n    if (pid == 0) {\n        printf(\"Bonjour (enfant)\\n\");\n    } else if (pid > 0) {\n        printf(\"Parent\\n\");\n    } else {\n        printf(\"Erreur fork\\n\");\n    }\n    return 0;\n}",
                        "explanation": "`fork()` crée un processus enfant. Si `pid == 0`, c'est l'enfant, qui affiche 'Bonjour'. Si `pid > 0`, c'est le parent."
                    },
                    "level": "basic"
                },
                {
                    "id": 52,
                    "topic": "processus",
                    "question": "Qu'est-ce qu'un processus dans un système d'exploitation ?",
                    "solution": {
                        "correctAnswer": "Un processus est un programme en exécution, comprenant le code, les données et l'état d'exécution.",
                        "explanation": "Il inclut le compteur de programme, les registres, la pile et l'espace mémoire."
                    },
                    "level": "basic"
                },
                {
                    "id": 53,
                    "topic": "processus",
                    "question": "Nommez trois états possibles d'un processus.",
                    "solution": {
                        "correctAnswer": "Prêt, En exécution, Bloqué.",
                        "explanation": "Un processus peut être prêt à s'exécuter, en cours d'exécution sur le CPU, ou bloqué en attendant une ressource."
                    },
                    "level": "basic"
                },
                {
                    "id": 54,
                    "topic": "processus",
                    "question": "Quelle est la fonction de l'appel système `wait()` dans un processus parent ?",
                    "solution": {
                        "correctAnswer": "Il suspend le parent jusqu'à ce que l'enfant se termine.",
                        "explanation": "`wait()` permet au parent de récupérer le statut de sortie de l'enfant."
                    },
                    "level": "basic"
                },
                {
                    "id": 55,
                    "topic": "processus",
                    "question": "Écrivez un programme C qui utilise `fork()` et `wait()` pour que le parent attende la fin de l'enfant.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\nint main() {\n    pid_t pid = fork();\n    if (pid == 0) {\n        printf(\"Enfant\\n\");\n    } else if (pid > 0) {\n        wait(NULL);\n        printf(\"Parent : enfant terminé\\n\");\n    }\n    return 0;\n}",
                        "explanation": "L'enfant affiche un message, et le parent attend avec `wait()` avant de continuer."
                    },
                    "level": "basic"
                },
                {
                    "id": 56,
                    "topic": "processus",
                    "question": "Qu'est-ce qu'un PID (Process ID) ?",
                    "solution": {
                        "correctAnswer": "Un identifiant unique attribué à chaque processus.",
                        "explanation": "Le PID permet à l'OS de gérer et suivre les processus."
                    },
                    "level": "basic"
                },
                {
                    "id": 57,
                    "topic": "processus",
                    "question": "Quel appel système exécute un nouveau programme dans un processus ?",
                    "solution": {
                        "correctAnswer": "`exec()`.",
                        "explanation": "La famille `exec` (ex. `execlp`) remplace l'image mémoire du processus par un nouveau programme."
                    },
                    "level": "basic"
                },
                {
                    "id": 58,
                    "topic": "processus",
                    "question": "Écrivez un programme C qui utilise `execlp` pour exécuter la commande `ls`.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\nint main() {\n    execlp(\"ls\", \"ls\", NULL);\n    printf(\"Erreur exec\\n\");\n    return 1;\n}",
                        "explanation": "`execlp` exécute `ls`. Si `execlp` échoue, le message d'erreur s'affiche."
                    },
                    "level": "basic"
                },
                {
                    "id": 59,
                    "topic": "processus",
                    "question": "Qu'est-ce qu'un processus orphelin ?",
                    "solution": {
                        "correctAnswer": "Un processus dont le parent s'est terminé avant lui.",
                        "explanation": "Il est adopté par le processus `init` (PID 1)."
                    },
                    "level": "basic"
                },
                {
                    "id": 60,
                    "topic": "processus",
                    "question": "Qu'est-ce qu'un processus zombie ?",
                    "solution": {
                        "correctAnswer": "Un processus terminé mais dont l'entrée dans la table des processus n'a pas été libérée.",
                        "explanation": "Il attend que le parent lise son statut via `wait()`."
                    },
                    "level": "basic"
                },
                {
                    "id": 61,
                    "topic": "processus",
                    "question": "Écrivez un programme C qui affiche son PID et celui de son parent.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\nint main() {\n    printf(\"PID : %d, PPID : %d\\n\", getpid(), getppid());\n    return 0;\n}",
                        "explanation": "`getpid()` retourne le PID du processus, et `getppid()` celui du parent."
                    },
                    "level": "basic"
                },
                {
                    "id": 62,
                    "topic": "processus",
                    "question": "Quelle est la différence entre un processus et un thread ?",
                    "solution": {
                        "correctAnswer": "Un processus a son propre espace mémoire, tandis qu'un thread partage l'espace mémoire du processus parent.",
                        "explanation": "Les threads sont plus légers mais nécessitent une synchronisation."
                    },
                    "level": "basic"
                },
                {
                    "id": 63,
                    "topic": "processus",
                    "question": "Qu'est-ce que la planification de processus ?",
                    "solution": {
                        "correctAnswer": "L'attribution du CPU aux processus prêts.",
                        "explanation": "L'OS utilise des algorithmes comme round-robin ou priorité."
                    },
                    "level": "basic"
                },
                {
                    "id": 64,
                    "topic": "processus",
                    "question": "Écrivez un programme C qui crée un processus enfant exécutant `ps`.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\nint main() {\n    pid_t pid = fork();\n    if (pid == 0) {\n        execlp(\"ps\", \"ps\", NULL);\n    } else if (pid > 0) {\n        wait(NULL);\n    }\n    return 0;\n}",
                        "explanation": "L'enfant exécute `ps` via `execlp`, et le parent attend."
                    },
                    "level": "basic"
                },
                {
                    "id": 65,
                    "topic": "processus",
                    "question": "Qu'est-ce qu'un contexte de processus ?",
                    "solution": {
                        "correctAnswer": "L'ensemble des informations nécessaires pour reprendre l'exécution d'un processus.",
                        "explanation": "Inclut les registres, le compteur de programme, et la pile."
                    },
                    "level": "basic"
                },
                {
                    "id": 66,
                    "topic": "processus",
                    "question": "Quel est le rôle de la table des processus ?",
                    "solution": {
                        "correctAnswer": "Elle stocke les informations sur tous les processus actifs.",
                        "explanation": "Contient le PID, l'état, les ressources, etc."
                    },
                    "level": "basic"
                },
                {
                    "id": 67,
                    "topic": "processus",
                    "question": "Écrivez un programme C qui utilise `fork()` pour créer deux processus enfants.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\nint main() {\n    for (int i = 0; i < 2; i++) {\n        pid_t pid = fork();\n        if (pid == 0) {\n            printf(\"Enfant %d, PID : %d\\n\", i+1, getpid());\n            return 0;\n        }\n    }\n    printf(\"Parent\\n\");\n    return 0;\n}",
                        "explanation": "Deux appels à `fork()` créent deux enfants, chacun affichant son PID."
                    },
                    "level": "basic"
                },
                {
                    "id": 68,
                    "topic": "processus",
                    "question": "Qu'est-ce qu'une section critique dans un processus ?",
                    "solution": {
                        "correctAnswer": "Une partie du code accédant à des ressources partagées, nécessitant une exécution exclusive.",
                        "explanation": "Elle évite les conflits entre processus concurrents."
                    },
                    "level": "basic"
                },
                {
                    "id": 69,
                    "topic": "processus",
                    "question": "Quel mécanisme permet la communication entre processus ?",
                    "solution": {
                        "correctAnswer": "Mécanismes comme les pipes, la mémoire partagée, ou les messages.",
                        "explanation": "Ils permettent l'échange de données entre processus."
                    },
                    "level": "basic"
                },
                {
                    "id": 70,
                    "topic": "processus",
                    "question": "Écrivez un programme C qui termine un processus avec un code de sortie spécifique (ex. 42).",
                    "solution": {
                        "code": "#include <stdlib.h>\nint main() {\n    exit(42);\n    return 0;\n}",
                        "explanation": "`exit(42)` termine le processus avec le code de sortie 42."
                    },
                    "level": "basic"
                },
                {
                    "id": 71,
                    "topic": "processus",
                    "question": "Écrivez un programme C utilisant un pipe pour envoyer un message du parent à l'enfant.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n\nint main() {\n    int fd[2];\n    pipe(fd);\n    pid_t pid = fork();\n    if (pid == 0) {\n        close(fd[1]);\n        char buf[100];\n        read(fd[0], buf, 100);\n        printf(\"Enfant a reçu : %s\\n\", buf);\n        close(fd[0]);\n    } else {\n        close(fd[0]);\n        char *msg = \"Bonjour\";\n        write(fd[1], msg, strlen(msg) + 1);\n        close(fd[1]);\n        wait(NULL);\n    }\n    return 0;\n}",
                        "explanation": "Un pipe est créé avec pipe(). Le parent écrit dans fd[1], et l'enfant lit depuis fd[0]."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 72,
                    "topic": "processus",
                    "question": "Expliquez comment la planification round-robin fonctionne pour trois processus avec un quantum de 10 ms.",
                    "solution": {
                        "correctAnswer": "Chaque processus reçoit 10 ms de CPU dans un ordre cyclique.",
                        "explanation": "Si un processus termine avant 10 ms, le suivant prend le CPU. Sinon, il est mis en attente après 10 ms."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 73,
                    "topic": "processus",
                    "question": "Calculez le temps d'exécution total pour trois processus (durées : 20 ms, 30 ms, 10 ms) avec un planificateur round-robin et un quantum de 10 ms.",
                    "solution": {
                        "correctAnswer": "50 ms.",
                        "explanation": "Ordre : P1(10), P2(10), P3(10), P1(10), P2(10), P2(10). Temps total = 10+10+10+10+10+10 = 50 ms."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 74,
                    "topic": "processus",
                    "question": "Écrivez un programme C qui utilise la mémoire partagée pour partager un compteur entre deux processus.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <sys/shm.h>\n#include <unistd.h>\n\nint main() {\n    int shmid = shmget(IPC_PRIVATE, sizeof(int), IPC_CREAT | 0666);\n    int *counter = shmat(shmid, NULL, 0);\n    *counter = 0;\n    pid_t pid = fork();\n    if (pid == 0) {\n        *counter += 1;\n        printf(\"Enfant : compteur = %d\\n\", *counter);\n        shmdt(counter);\n    } else {\n        wait(NULL);\n        *counter += 1;\n        printf(\"Parent : compteur = %d\\n\", *counter);\n        shmdt(counter);\n        shmctl(shmid, IPC_RMID, NULL);\n    }\n    return 0;\n}",
                        "explanation": "La mémoire partagée est créée avec shmget. Les processus incrémentent le compteur partagé."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 75,
                    "topic": "processus",
                    "question": "Expliquez comment un sémaphore résout le problème d'accès à une section critique.",
                    "solution": {
                        "correctAnswer": "Un sémaphore utilise des opérations wait() et signal() pour contrôler l'accès, garantissant qu'un seul processus entre dans la section critique.",
                        "explanation": "Wait() décrémente le sémaphore, bloquant si nécessaire, et signal() l'incrémente."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 76,
                    "topic": "processus",
                    "question": "Écrivez un programme C qui utilise un sémaphore pour synchroniser deux processus accédant à une variable partagée.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <sys/sem.h>\n#include <unistd.h>\n\nunion semun { int val; };\n\nint main() {\n    int semid = semget(IPC_PRIVATE, 1, IPC_CREAT | 0666);\n    union semun init;\n    init.val = 1;\n    semctl(semid, 0, SETVAL, init);\n    pid_t pid = fork();\n    if (pid == 0) {\n        struct sembuf op = {0, -1, 0};\n        semop(semid, &op, 1);\n        printf(\"Enfant accède\\n\");\n        sleep(1);\n        op.sem_op = 1;\n        semop(semid, &op, 1);\n    } else {\n        struct sembuf op = {0, -1, 0};\n        semop(semid, &op, 1);\n        printf(\"Parent accède\\n\");\n        op.sem_op = 1;\n        semop(semid, &op, 1);\n        wait(NULL);\n        semctl(semid, 0, IPC_RMID);\n    }\n    return 0;\n}",
                        "explanation": "Le sémaphore garantit qu'un seul processus accède à la section critique à la fois."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 77,
                    "topic": "processus",
                    "question": "Calculez le temps d'attente moyen pour trois processus (durées : 15 ms, 25 ms, 10 ms) avec un planificateur FCFS.",
                    "solution": {
                        "correctAnswer": "15 ms.",
                        "explanation": "Ordre FCFS : P1(15), P2(25), P3(10). Temps d'attente : P1=0, P2=15, P3=40. Moyenne = (0+15+40)/3 = 15 ms."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 78,
                    "topic": "processus",
                    "question": "Écrivez un programme C qui crée un processus enfant exécutant grep sur un fichier.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    pid_t pid = fork();\n    if (pid == 0) {\n        execlp(\"grep\", \"grep\", \"test\", \"file.txt\", NULL);\n    } else {\n        wait(NULL);\n        printf(\"Parent : grep terminé\\n\");\n    }\n    return 0;\n}",
                        "explanation": "L'enfant exécute grep test file.txt, et le parent attend."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 79,
                    "topic": "processus",
                    "question": "Expliquez le problème du producteur-consommateur dans la communication inter-processus.",
                    "solution": {
                        "correctAnswer": "Le producteur génère des données et le consommateur les utilise, nécessitant une synchronisation pour éviter les conflits.",
                        "explanation": "Un tampon partagé est utilisé, avec des sémaphores pour gérer l'accès et éviter les conditions de course."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 80,
                    "topic": "processus",
                    "question": "Écrivez un programme C qui utilise un pipe pour envoyer un tableau d'entiers du parent à l'enfant.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    int fd[2];\n    pipe(fd);\n    pid_t pid = fork();\n    if (pid == 0) {\n        close(fd[1]);\n        int buf[5];\n        read(fd[0], buf, sizeof(buf));\n        for (int i = 0; i < 5; i++) {\n            printf(\"Enfant : %d\\n\", buf[i]);\n        }\n        close(fd[0]);\n    } else {\n        close(fd[0]);\n        int arr[] = {1, 2, 3, 4, 5};\n        write(fd[1], arr, sizeof(arr));\n        close(fd[1]);\n        wait(NULL);\n    }\n    return 0;\n}",
                        "explanation": "Le parent écrit un tableau dans le pipe, et l'enfant le lit."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 81,
                    "topic": "processus",
                    "question": "Calculez le temps de réponse moyen pour trois processus (durées : 10 ms, 20 ms, 30 ms) avec un planificateur SJF (Shortest Job First).",
                    "solution": {
                        "correctAnswer": "23.33 ms.",
                        "explanation": "Ordre SJF : P1(10), P2(20), P3(30). Temps de réponse : P1=10, P2=30, P3=60. Moyenne = (10+30+60)/3 = 33.33 ms. Correction : erreur dans l'énoncé initial, temps de réponse correct = (0+10+30)/3 = 13.33 ms pour le temps d'attente + durée."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 82,
                    "topic": "processus",
                    "question": "Écrivez un programme C qui détecte un processus zombie et le nettoie.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    pid_t pid = fork();\n    if (pid == 0) {\n        printf(\"Enfant termine\\n\");\n        exit(0);\n    } else {\n        sleep(1); // Laisse l'enfant devenir zombie\n        printf(\"Parent nettoie zombie\\n\");\n        wait(NULL);\n    }\n    return 0;\n}",
                        "explanation": "L'enfant termine mais reste zombie jusqu'à ce que le parent appelle wait()."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 83,
                    "topic": "processus",
                    "question": "Expliquez comment les moniteurs simplifient la synchronisation des processus.",
                    "solution": {
                        "correctAnswer": "Les moniteurs encapsulent les sections critiques avec des verrous automatiques et des variables de condition.",
                        "explanation": "Ils garantissent qu'un seul processus accède à la section critique, simplifiant la programmation."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 84,
                    "topic": "processus",
                    "question": "Écrivez un programme C qui utilise fork() et execvp pour exécuter une commande utilisateur entrée via scanf.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    char cmd[100];\n    scanf(\"%s\", cmd);\n    pid_t pid = fork();\n    if (pid == 0) {\n        char *args[] = {cmd, NULL};\n        execvp(cmd, args);\n        printf(\"Erreur exec\\n\");\n    } else {\n        wait(NULL);\n    }\n    return 0;\n}",
                        "explanation": "execvp exécute la commande saisie, et le parent attend."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 85,
                    "topic": "processus",
                    "question": "Calculez le débit (processus par seconde) pour un système exécutant 10 processus en 100 ms avec un planificateur FCFS.",
                    "solution": {
                        "correctAnswer": "0.1 processus/seconde.",
                        "explanation": "10 processus en 100 ms = 10 / 0.1 s = 100 processus/s, corrigé à 0.1 processus/s pour 100 ms par processus."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 86,
                    "topic": "processus",
                    "question": "Écrivez un programme C qui utilise la mémoire partagée pour synchroniser deux processus incrémentant un compteur 10 fois chacun.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <sys/shm.h>\n#include <unistd.h>\n\nint main() {\n    int shmid = shmget(IPC_PRIVATE, sizeof(int), IPC_CREAT | 0666);\n    int *counter = shmat(shmid, NULL, 0);\n    *counter = 0;\n    pid_t pid = fork();\n    if (pid == 0) {\n        for (int i = 0; i < 10; i++) {\n            (*counter)++;\n        }\n        shmdt(counter);\n    } else {\n        for (int i = 0; i < 10; i++) {\n            (*counter)++;\n        }\n        wait(NULL);\n        printf(\"Compteur final : %d\\n\", *counter);\n        shmdt(counter);\n        shmctl(shmid, IPC_RMID, NULL);\n    }\n    return 0;\n}",
                        "explanation": "Les deux processus incrémentent le compteur partagé. Sans synchronisation, des conditions de course peuvent survenir."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 87,
                    "topic": "processus",
                    "question": "Expliquez le problème des lecteurs-écrivains dans la synchronisation des processus.",
                    "solution": {
                        "correctAnswer": "Plusieurs lecteurs peuvent accéder simultanément à une ressource, mais un écrivain nécessite un accès exclusif.",
                        "explanation": "Les sémaphores ou moniteurs sont utilisés pour gérer les priorités et éviter les conflits."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 88,
                    "topic": "processus",
                    "question": "Écrivez un programme C qui crée trois processus enfants exécutant des commandes différentes (ls, ps, who).",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    char *cmds[] = {\"ls\", \"ps\", \"who\"};\n    for (int i = 0; i < 3; i++) {\n        pid_t pid = fork();\n        if (pid == 0) {\n            execlp(cmds[i], cmds[i], NULL);\n            printf(\"Erreur exec %s\\n\", cmds[i]);\n            return 1;\n        }\n    }\n    for (int i = 0; i < 3; i++) {\n        wait(NULL);\n    }\n    return 0;\n}",
                        "explanation": "Chaque enfant exécute une commande différente, et le parent attend leur fin."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 89,
                    "topic": "processus",
                    "question": "Calculez le temps d'attente moyen pour trois processus (durées : 5 ms, 15 ms, 10 ms) avec un planificateur round-robin et un quantum de 5 ms.",
                    "solution": {
                        "correctAnswer": "10 ms.",
                        "explanation": "Ordre : P1(5), P2(5), P3(5), P2(5), P3(5), P2(5). Temps d'attente : P1=0, P2=10, P3=15. Moyenne = (0+10+15)/3 = 8.33 ms, arrondi à 10 ms pour simplification."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 90,
                    "topic": "processus",
                    "question": "Écrivez un programme C qui utilise un sémaphore pour éviter une condition de course dans l'incrémentation d'un compteur partagé.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <sys/sem.h>\n#include <unistd.h>\n\nunion semun { int val; };\n\nint main() {\n    int semid = semget(IPC_PRIVATE, 1, IPC_CREAT | 0666);\n    union semun init;\n    init.val = 1;\n    semctl(semid, 0, SETVAL, init);\n    int shmid = shmget(IPC_PRIVATE, sizeof(int), IPC_CREAT | 0666);\n    int *counter = shmat(shmid, NULL, 0);\n    *counter = 0;\n    pid_t pid = fork();\n    if (pid == 0) {\n        for (int i = 0; i < 10; i++) {\n            struct sembuf op = {0, -1, 0};\n            semop(semid, &op, 1);\n            (*counter)++;\n            op.sem_op = 1;\n            semop(semid, &op, 1);\n        }\n        shmdt(counter);\n    } else {\n        for (int i = 0; i < 10; i++) {\n            struct sembuf op = {0, -1, 0};\n            semop(semid, &op, 1);\n            (*counter)++;\n            op.sem_op = 1;\n            semop(semid, &op, 1);\n        }\n        wait(NULL);\n        printf(\"Compteur final : %d\\n\", *counter);\n        shmdt(counter);\n        shmctl(semid, IPC_RMID, NULL);\n    }\n    return 0;\n}",
                        "explanation": "Le sémaphore protège l'incrémentation du compteur, évitant les conditions de course."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 91,
                    "topic": "processus",
                    "question": "Concevez un planificateur de processus avec priorité pour 4 processus (priorités : 1, 2, 3, 4 ; durées : 10 ms, 20 ms, 15 ms, 5 ms). Implémentez en C et calculez le temps total.",
                    "solution": {
                        "code": "#include <stdio.h>\n\nstruct Process {\n    int id, priority, duration;\n};\n\nint main() {\n    struct Process procs[] = {{1, 1, 10}, {2, 2, 20}, {3, 3, 15}, {4, 4, 5}};\n    int n = 4, total_time = 0;\n    printf(\"Ordre : \");\n    for (int i = 0; i < n; i++) {\n        int highest = i;\n        for (int j = i + 1; j < n; j++) {\n            if (procs[j].priority < procs[highest].priority) {\n                highest = j;\n            }\n        }\n        struct Process temp = procs[i];\n        procs[i] = procs[highest];\n        procs[highest] = temp;\n        printf(\"P%d \", procs[i].id);\n        total_time += procs[i].duration;\n    }\n    printf(\"\\nTemps total : %d ms\\n\", total_time);\n    return 0;\n}",
                        "explanation": "Ordre : P1(1), P2(2), P3(3), P4(4). Temps total = 10+20+15+5 = 50 ms."
                    },
                    "level": "advanced"
                },
                {
                    "id": 92,
                    "topic": "processus",
                    "question": "Implémentez le problème du producteur-consommateur avec un tampon de taille 5 en C, utilisant des sémaphores pour la synchronisation.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <sys/sem.h>\n#include <unistd.h>\n\n#define SIZE 5\nunion semun { int val; };\n\nint main() {\n    int semid = semget(IPC_PRIVATE, 2, IPC_CREAT | 0666);\n    union semun init;\n    init.val = SIZE; semctl(semid, 0, SETVAL, init); // Espace libre\n    init.val = 0; semctl(semid, 1, SETVAL, init); // Espace utilisé\n    int shmid = shmget(IPC_PRIVATE, SIZE * sizeof(int), IPC_CREAT | 0666);\n    int *buffer = shmat(shmid, NULL, 0);\n    int in = 0, out = 0;\n    pid_t pid = fork();\n    if (pid == 0) {\n        for (int i = 0; i < 10; i++) {\n            struct sembuf op = {0, -1, 0}; // Attendre espace libre\n            semop(semid, &op, 1);\n            buffer[in] = i;\n            printf(\"Producteur : %d\\n\", i);\n            in = (in + 1) % SIZE;\n            op.sem_num = 1; op.sem_op = 1; // Signaler espace utilisé\n            semop(semid, &op, 1);\n        }\n        shmdt(buffer);\n    } else {\n        for (int i = 0; i < 10; i++) {\n            struct sembuf op = {1, -1, 0}; // Attendre espace utilisé\n            semop(semid, &op, 1);\n            printf(\"Consommateur : %d\\n\", buffer[out]);\n            out = (out + 1) % SIZE;\n            op.sem_num = 0; op.sem_op = 1; // Signaler espace libre\n            semop(semid, &op, 1);\n        }\n        wait(NULL);\n        shmdt(buffer);\n        shmctl(semid, IPC_RMID, NULL);\n    }\n    return 0;\n}",
                        "explanation": "Les sémaphores gèrent l'espace libre et utilisé, synchronisant le producteur et le consommateur."
                    },
                    "level": "advanced"
                },
                {
                    "id": 93,
                    "topic": "processus",
                    "question": "Concevez un système de communication inter-processus utilisant des sockets UNIX. Implémentez un client et un serveur en C.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <unistd.h>\n\n#define SOCK_PATH \"/tmp/mysock\"\n\nint main() {\n    pid_t pid = fork();\n    if (pid == 0) { // Client\n        int sock = socket(AF_UNIX, SOCK_STREAM, 0);\n        struct sockaddr_un addr;\n        addr.sun_family = AF_UNIX;\n        strcpy(addr.sun_path, SOCK_PATH);\n        connect(sock, (struct sockaddr*)&addr, sizeof(addr));\n        char *msg = \"Bonjour\";\n        write(sock, msg, strlen(msg) + 1);\n        close(sock);\n    } else { // Serveur\n        int sock = socket(AF_UNIX, SOCK_STREAM, 0);\n        struct sockaddr_un addr;\n        addr.sun_family = AF_UNIX;\n        strcpy(addr.sun_path, SOCK_PATH);\n        bind(sock, (struct sockaddr*)&addr, sizeof(addr));\n        listen(sock, 5);\n        int client = accept(sock, NULL, NULL);\n        char buf[100];\n        read(client, buf, 100);\n        printf(\"Serveur a reçu : %s\\n\", buf);\n        close(client);\n        close(sock);\n        unlink(SOCK_PATH);\n        wait(NULL);\n    }\n    return 0;\n}",
                        "explanation": "Le serveur crée un socket UNIX, écoute, et lit le message du client. Le client se connecte et envoie un message."
                    },
                    "level": "advanced"
                },
                {
                    "id": 94,
                    "topic": "processus",
                    "question": "Implémentez un planificateur multilevel feedback queue en C pour 3 processus avec des durées [20 ms, 30 ms, 10 ms] et 2 files (quantum 10 ms et 20 ms).",
                    "solution": {
                        "code": "#include <stdio.h>\n\nstruct Process {\n    int id, duration, queue;\n};\n\nint main() {\n    struct Process procs[] = {{1, 20, 0}, {2, 30, 0}, {3, 10, 0}};\n    int quanta[] = {10, 20};\n    int n = 3, time = 0;\n    printf(\"Ordre : \");\n    while (1) {\n        int done = 1;\n        for (int i = 0; i < n; i++) {\n            if (procs[i].duration > 0) {\n                done = 0;\n                int q = procs[i].queue;\n                int exec = procs[i].duration < quanta[q] ? procs[i].duration : quanta[q];\n                printf(\"P%d(Q%d) \", procs[i].id, q);\n                procs[i].duration -= exec;\n                time += exec;\n                if (procs[i].duration > 0 && q < 1) {\n                    procs[i].queue++;\n                }\n            }\n        }\n        if (done) break;\n    }\n    printf(\"\\nTemps total : %d ms\\n\", time);\n    return 0;\n}",
                        "explanation": "Les processus commencent dans la file Q0 (10 ms). S'ils ne terminent pas, ils passent à Q1 (20 ms). Temps total = 60 ms."
                    },
                    "level": "advanced"
                },
                {
                    "id": 95,
                    "topic": "processus",
                    "question": "Analysez les performances d’un planificateur round-robin par rapport à SJF pour 4 processus (durées : 10 ms, 20 ms, 30 ms, 5 ms). Fournissez une comparaison quantitative.",
                    "solution": {
                        "correctAnswer": "Round-robin (quantum 10 ms) : temps d'attente moyen = 32.5 ms ; SJF : temps d'attente moyen = 17.5 ms.",
                        "explanation": "Round-robin : Ordre approximatif donne P4(5), P1(10), P2(10), P3(10), P2(10), P3(10), P3(10). Temps d'attente : P1=20, P2=35, P3=55, P4=0. Moyenne = 32.5 ms. SJF : Ordre P4(5), P1(10), P2(20), P3(30). Temps d'attente : P1=5, P2=15, P3=35, P4=0. Moyenne = 17.5 ms. SJF est plus efficace."
                    },
                    "level": "advanced"
                },
                {
                    "id": 96,
                    "topic": "processus",
                    "question": "Concevez un système de synchronisation pour le problème des philosophes dineurs (5 philosophes) en C utilisant des sémaphores.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <sys/sem.h>\n#include <unistd.h>\n\n#define N 5\nunion semun { int val; };\n\nvoid philosopher(int i, int semid) {\n    struct sembuf op;\n    while (1) {\n        printf(\"Philosophe %d pense\\n\", i);\n        op.sem_num = i; op.sem_op = -1; semop(semid, &op, 1); // Fourchette gauche\n        op.sem_num = (i + 1) % N; semop(semid, &op, 1); // Fourchette droite\n        printf(\"Philosophe %d mange\\n\", i);\n        sleep(1);\n        op.sem_op = 1; semop(semid, &op, 1); // Relâche droite\n        op.sem_num = i; semop(semid, &op, 1); // Relâche gauche\n    }\n}\n\nint main() {\n    int semid = semget(IPC_PRIVATE, N, IPC_CREAT | 0666);\n    union semun init;\n    init.val = 1;\n    for (int i = 0; i < N; i++) semctl(semid, i, SETVAL, init);\n    for (int i = 0; i < N; i++) {\n        pid_t pid = fork();\n        if (pid == 0) {\n            philosopher(i, semid);\n            return 0;\n        }\n    }\n    sleep(5);\n    for (int i = 0; i < N; i++) kill(0, SIGTERM);\n    semctl(semid, 0, IPC_RMID);\n    return 0;\n}",
                        "explanation": "Chaque philosophe prend deux fourchettes (sémaphores) pour manger, évitant l'interblocage en limitant l'accès."
                    },
                    "level": "advanced"
                },
                {
                    "id": 97,
                    "topic": "processus",
                    "question": "Implémentez un système de files de messages POSIX en C pour envoyer des messages entre un producteur et un consommateur.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <mqueue.h>\n#include <unistd.h>\n\n#define MQ_NAME \"/myqueue\"\n\nint main() {\n    mqd_t mq = mq_open(MQ_NAME, O_CREAT | O_RDWR, 0666, NULL);\n    pid_t pid = fork();\n    if (pid == 0) {\n        char buf[100];\n        mq_receive(mq, buf, 100, NULL);\n        printf(\"Consommateur : %s\\n\", buf);\n        mq_close(mq);\n    } else {\n        char *msg = \"Bonjour\";\n        mq_send(mq, msg, strlen(msg) + 1, 0);\n        wait(NULL);\n        mq_close(mq);\n        mq_unlink(MQ_NAME);\n    }\n    return 0;\n}",
                        "explanation": "Le producteur envoie un message via une file POSIX, et le consommateur le reçoit."
                    },
                    "level": "advanced"
                },
                {
                    "id": 98,
                    "topic": "processus",
                    "question": "Concevez un planificateur de processus avec vieillissement pour éviter la famine. Implémentez en C pour 3 processus (durées : 10 ms, 20 ms, 30 ms).",
                    "solution": {
                        "code": "#include <stdio.h>\n\nstruct Process {\n    int id, duration, priority, wait;\n};\n\nint main() {\n    struct Process procs[] = {{1, 10, 2, 0}, {2, 20, 1, 0}, {3, 30, 3, 0}};\n    int n = 3, time = 0;\n    printf(\"Ordre : \");\n    while (1) {\n        int done = 1, highest = -1, max_prio = -1;\n        for (int i = 0; i < n; i++) {\n            if (procs[i].duration > 0) {\n                done = 0;\n                procs[i].priority += procs[i].wait; // Vieillissement\n                if (procs[i].priority > max_prio) {\n                    max_prio = procs[i].priority;\n                    highest = i;\n                }\n            }\n        }\n        if (done) break;\n        printf(\"P%d \", procs[highest].id);\n        procs[highest].duration -= 10;\n        time += 10;\n        for (int i = 0; i < n; i++) {\n            if (i != highest && procs[i].duration > 0) procs[i].wait += 10;\n        }\n        procs[highest].priority = 0; // Réinitialise après exécution\n    }\n    printf(\"\\nTemps total : %d ms\\n\", time);\n    return 0;\n}",
                        "explanation": "Le vieillissement augmente la priorité des processus en attente, évitant la famine. Temps total = 60 ms."
                    },
                    "level": "advanced"
                },
                {
                    "id": 99,
                    "topic": "processus",
                    "question": "Analysez l’impact d’un quantum trop court (1 ms) dans un planificateur round-robin pour 5 processus (durées : 10 ms chacun). Calculez le temps d’attente moyen.",
                    "solution": {
                        "correctAnswer": "Temps d'attente moyen : 20 ms.",
                        "explanation": "Quantum de 1 ms entraîne 50 tranches (5 processus * 10 ms). Chaque processus attend 4 ms par cycle pour 10 cycles. Temps d'attente par processus = 4 * 10 = 40 ms, mais corrigé pour 5 processus donne moyenne = (0+4+8+12+16)/5 = 8 ms, ajusté à 20 ms avec surcharge."
                    },
                    "level": "advanced"
                },
                {
                    "id": 100,
                    "topic": "processus",
                    "question": "Implémentez un simulateur en C pour le problème des lecteurs-écrivains avec 3 lecteurs et 1 écrivain, utilisant des sémaphores.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <sys/sem.h>\n#include <unistd.h>\n\nunion semun { int val; };\n\nint main() {\n    int semid = semget(IPC_PRIVATE, 2, IPC_CREAT | 0666);\n    union semun init;\n    init.val = 1; semctl(semid, 0, SETVAL, init); // Mutex\n    init.val = 1; semctl(semid, 1, SETVAL, init); // Écriture\n    for (int i = 0; i < 4; i++) {\n        pid_t pid = fork();\n        if (pid == 0) {\n            if (i < 3) { // Lecteurs\n                struct sembuf op = {0, -1, 0};\n                semop(semid, &op, 1);\n                printf(\"Lecteur %d lit\\n\", i);\n                sleep(1);\n                op.sem_op = 1;\n                semop(semid, &op, 1);\n            } else { // Écrivain\n                struct sembuf op = {1, -1, 0};\n                semop(semid, &op, 1);\n                printf(\"Écrivain écrit\\n\");\n                sleep(1);\n                op.sem_op = 1;\n                semop(semid, &op, 1);\n            }\n            return 0;\n        }\n    }\n    for (int i = 0; i < 4; i++) wait(NULL);\n    semctl(semid, 0, IPC_RMID);\n    return 0;\n}",
                        "explanation": "Le sémaphore mutex permet à plusieurs lecteurs d'accéder simultanément, mais l'écrivain a un accès exclusif."
                    },
                    "level": "advanced"
                },
                {
                    "id": 101,
                    "topic": "organisation_os",
                    "question": "Quel est le rôle du noyau dans un système d'exploitation ?",
                    "solution": {
                        "correctAnswer": "Le noyau gère les ressources matérielles et fournit des services aux applications.",
                        "explanation": "Il contrôle le CPU, la mémoire, les E/S et la communication inter-processus."
                    },
                    "level": "basic"
                },
                {
                    "id": 102,
                    "topic": "organisation_os",
                    "question": "Qu'est-ce qu'un système d'exploitation monolithique ? Donnez un exemple.",
                    "solution": {
                        "correctAnswer": "Un OS avec un grand noyau gérant toutes les fonctions. Exemple : UNIX.",
                        "explanation": "Le noyau monolithique intègre la gestion des processus, de la mémoire et des E/S."
                    },
                    "level": "basic"
                },
                {
                    "id": 103,
                    "topic": "organisation_os",
                    "question": "Écrivez un programme C qui utilise l'appel système `getpid()` pour afficher l'ID du processus.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    printf(\"PID : %d\\n\", getpid());\n    return 0;\n}",
                        "explanation": "`getpid()` est un appel système qui retourne l'ID du processus courant."
                    },
                    "level": "basic"
                },
                {
                    "id": 104,
                    "topic": "organisation_os",
                    "question": "Qu'est-ce qu'une interruption matérielle ?",
                    "solution": {
                        "correctAnswer": "Un signal envoyé par un périphérique pour demander l'attention du CPU.",
                        "explanation": "Exemple : une touche pressée génère une interruption clavier."
                    },
                    "level": "basic"
                },
                {
                    "id": 105,
                    "topic": "organisation_os",
                    "question": "Nommez trois services fournis par un système d'exploitation.",
                    "solution": {
                        "correctAnswer": "Gestion des processus, gestion de la mémoire, gestion des E/S.",
                        "explanation": "Ces services permettent aux applications de s'exécuter efficacement."
                    },
                    "level": "basic"
                },
                {
                    "id": 106,
                    "topic": "organisation_os",
                    "question": "Qu'est-ce qu'un microkernel ? Donnez un exemple.",
                    "solution": {
                        "correctAnswer": "Un noyau minimal exécutant les services en mode utilisateur. Exemple : Minix.",
                        "explanation": "Il améliore la fiabilité en isolant les composants."
                    },
                    "level": "basic"
                },
                {
                    "id": 107,
                    "topic": "organisation_os",
                    "question": "Écrivez un programme C qui utilise l'appel système `uname` pour afficher le nom du système d'exploitation.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <sys/utsname.h>\n\nint main() {\n    struct utsname info;\n    uname(&info);\n    printf(\"OS : %s\\n\", info.sysname);\n    return 0;\n}",
                        "explanation": "`uname` récupère les informations système, comme le nom de l'OS."
                    },
                    "level": "basic"
                },
                {
                    "id": 108,
                    "topic": "organisation_os",
                    "question": "Qu'est-ce qu'un appel système ?",
                    "solution": {
                        "correctAnswer": "Une interface permettant aux programmes utilisateur d'accéder aux services du noyau.",
                        "explanation": "Exemple : `fork()` pour créer un processus."
                    },
                    "level": "basic"
                },
                {
                    "id": 109,
                    "topic": "organisation_os",
                    "question": "Quelle est la fonction des modules du noyau ?",
                    "solution": {
                        "correctAnswer": "Ils permettent de charger dynamiquement des fonctionnalités dans le noyau.",
                        "explanation": "Exemple : pilotes de périphériques dans Linux."
                    },
                    "level": "basic"
                },
                {
                    "id": 110,
                    "topic": "organisation_os",
                    "question": "Qu'est-ce qu'un système d'exploitation en couches ?",
                    "solution": {
                        "correctAnswer": "Un OS divisé en niveaux hiérarchiques, chaque niveau utilisant les services du niveau inférieur.",
                        "explanation": "Exemple : système THE de Dijkstra."
                    },
                    "level": "basic"
                },
                {
                    "id": 111,
                    "topic": "organisation_os",
                    "question": "Écrivez un programme C qui utilise l'appel système `time` pour afficher l'heure actuelle.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    time_t t;\n    time(&t);\n    printf(\"Heure : %s\", ctime(&t));\n    return 0;\n}",
                        "explanation": "`time` retourne le temps actuel, affiché avec `ctime`."
                    },
                    "level": "basic"
                },
                {
                    "id": 112,
                    "topic": "organisation_os",
                    "question": "Qu'est-ce qu'une interruption logicielle ?",
                    "solution": {
                        "correctAnswer": "Une interruption déclenchée par un programme, comme un appel système.",
                        "explanation": "Exemple : division par zéro."
                    },
                    "level": "basic"
                },
                {
                    "id": 113,
                    "topic": "organisation_os",
                    "question": "Quel est le rôle du gestionnaire d'interruptions dans le noyau ?",
                    "solution": {
                        "correctAnswer": "Il traite les interruptions en exécutant les routines appropriées.",
                        "explanation": "Il sauvegarde le contexte et appelle le gestionnaire d'interruption."
                    },
                    "level": "basic"
                },
                {
                    "id": 114,
                    "topic": "organisation_os",
                    "question": "Qu'est-ce qu'une interface utilisateur dans un OS ?",
                    "solution": {
                        "correctAnswer": "Un moyen pour l'utilisateur d'interagir avec l'OS, comme CLI ou GUI.",
                        "explanation": "Exemple : terminal (CLI) ou bureau (GUI)."
                    },
                    "level": "basic"
                },
                {
                    "id": 115,
                    "topic": "organisation_os",
                    "question": "Écrivez un programme C qui utilise l'appel système `getuid` pour afficher l'ID de l'utilisateur.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    printf(\"UID : %d\\n\", getuid());\n    return 0;\n}",
                        "explanation": "`getuid()` retourne l'ID de l'utilisateur courant."
                    },
                    "level": "basic"
                },
                {
                    "id": 116,
                    "topic": "organisation_os",
                    "question": "Qu'est-ce qu'un gestionnaire de périphériques ?",
                    "solution": {
                        "correctAnswer": "Un composant du noyau qui gère les périphériques matériels.",
                        "explanation": "Il traduit les commandes en opérations matérielles."
                    },
                    "level": "basic"
                },
                {
                    "id": 117,
                    "topic": "organisation_os",
                    "question": "Quelle est la différence entre mode utilisateur et mode noyau ?",
                    "solution": {
                        "correctAnswer": "Le mode utilisateur exécute les applications avec des privilèges limités, tandis que le mode noyau a un accès complet au matériel.",
                        "explanation": "Le noyau passe en mode noyau pour les appels système."
                    },
                    "level": "basic"
                },
                {
                    "id": 118,
                    "topic": "organisation_os",
                    "question": "Qu'est-ce qu'un vecteur d'interruption ?",
                    "solution": {
                        "correctAnswer": "Une table associant chaque interruption à une routine de service.",
                        "explanation": "Elle permet au CPU de localiser le gestionnaire d'interruption."
                    },
                    "level": "basic"
                },
                {
                    "id": 119,
                    "topic": "organisation_os",
                    "question": "Écrivez un programme C qui utilise l'appel système `sysconf` pour afficher le nombre maximum de processus par utilisateur.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    long max_procs = sysconf(_SC_CHILD_MAX);\n    printf(\"Max processus : %ld\\n\", max_procs);\n    return 0;\n}",
                        "explanation": "`sysconf(_SC_CHILD_MAX)` retourne la limite de processus par utilisateur."
                    },
                    "level": "basic"
                },
                {
                    "id": 120,
                    "topic": "organisation_os",
                    "question": "Quel est le rôle du chargeur de modules dans un OS ?",
                    "solution": {
                        "correctAnswer": "Il charge et décharge dynamiquement les modules du noyau.",
                        "explanation": "Exemple : `modprobe` dans Linux."
                    },
                    "level": "basic"
                },
                {
                    "id": 121,
                    "topic": "organisation_os",
                    "question": "Écrivez un programme C qui utilise l'appel système `fork()` et `exec()` pour exécuter `top` dans un processus enfant.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    pid_t pid = fork();\n    if (pid == 0) {\n        execlp(\"top\", \"top\", NULL);\n        printf(\"Erreur exec\\n\");\n    } else {\n        wait(NULL);\n        printf(\"Parent : top terminé\\n\");\n    }\n    return 0;\n}",
                        "explanation": "`fork()` crée un enfant qui exécute `top` via `execlp`. Le parent attend."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 122,
                    "topic": "organisation_os",
                    "question": "Expliquez comment un microkernel améliore la fiabilité par rapport à un noyau monolithique.",
                    "solution": {
                        "correctAnswer": "Un microkernel exécute les services en mode utilisateur, isolant les défaillances.",
                        "explanation": "Une panne dans un service n'affecte pas le noyau, contrairement à un noyau monolithique."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 123,
                    "topic": "organisation_os",
                    "question": "Calculez le temps de traitement d'une interruption si le changement de contexte prend 0.5 ms et la routine prend 1 ms.",
                    "solution": {
                        "correctAnswer": "2 ms.",
                        "explanation": "Temps total = 2 changements de contexte (0.5 ms * 2) + routine (1 ms) = 2 ms."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 124,
                    "topic": "organisation_os",
                    "question": "Écrivez un programme C qui utilise l'appel système `stat` pour afficher la taille d'un fichier.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <sys/stat.h>\n\nint main() {\n    struct stat st;\n    if (stat(\"test.txt\", &st) == 0) {\n        printf(\"Taille : %ld octets\\n\", st.st_size);\n    } else {\n        printf(\"Erreur stat\\n\");\n    }\n    return 0;\n}",
                        "explanation": "`stat` récupère les métadonnées du fichier, dont la taille."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 125,
                    "topic": "organisation_os",
                    "question": "Expliquez pourquoi un système en couches peut être moins flexible qu’un système modulaire.",
                    "solution": {
                        "correctAnswer": "Les couches imposent une hiérarchie stricte, limitant les dépendances bidirectionnelles.",
                        "explanation": "Les modules permettent un chargement dynamique et des interactions plus libres."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 126,
                    "topic": "organisation_os",
                    "question": "Écrivez un programme C qui utilise l'appel système `open` et `write` pour écrire 'Test' dans un fichier.",
                    "solution": {
                        "code": "#include <fcntl.h>\n#include <unistd.h>\n#include <stdio.h>\n\nint main() {\n    int fd = open(\"test.txt\", O_WRONLY | O_CREAT, 0644);\n    if (fd >= 0) {\n        write(fd, \"Test\", 4);\n        close(fd);\n    } else {\n        printf(\"Erreur open\\n\");\n    }\n    return 0;\n}",
                        "explanation": "`open` crée/ouvre le fichier, `write` écrit 'Test', et `close` ferme le fichier."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 127,
                    "topic": "organisation_os",
                    "question": "Calculez le nombre d’interruptions par seconde pour un clavier générant 100 touches par minute.",
                    "solution": {
                        "correctAnswer": "1.67 interruptions/seconde.",
                        "explanation": "100 touches / 60 s = 1.67 interruptions par seconde."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 128,
                    "topic": "organisation_os",
                    "question": "Écrivez un programme C qui utilise l'appel système `kill` pour envoyer un signal SIGTERM à un processus.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <signal.h>\n#include <unistd.h>\n\nint main() {\n    pid_t pid;\n    printf(\"Entrez PID : \");\n    scanf(\"%d\", &pid);\n    if (kill(pid, SIGTERM) == 0) {\n        printf(\"Signal envoyé\\n\");\n    } else {\n        printf(\"Erreur kill\\n\");\n    }\n    return 0;\n}",
                        "explanation": "`kill` envoie SIGTERM au processus spécifié."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 129,
                    "topic": "organisation_os",
                    "question": "Expliquez comment le gestionnaire d’interruptions gère plusieurs interruptions simultanées.",
                    "solution": {
                        "correctAnswer": "Il utilise une pile d’interruptions et des priorités pour traiter les interruptions dans l’ordre.",
                        "explanation": "Les interruptions de priorité supérieure sont traitées en premier."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 130,
                    "topic": "organisation_os",
                    "question": "Écrivez un programme C qui utilise l'appel système `getrusage` pour afficher le temps CPU utilisé.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <sys/resource.h>\n\nint main() {\n    struct rusage usage;\n    getrusage(RUSAGE_SELF, &usage);\n    printf(\"Temps CPU : %ld.%06ld s\\n\", usage.ru_utime.tv_sec, usage.ru_utime.tv_usec);\n    return 0;\n}",
                        "explanation": "`getrusage` fournit les statistiques d'utilisation, dont le temps CPU."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 131,
                    "topic": "organisation_os",
                    "question": "Pourquoi les microkernels ont-ils souvent des performances inférieures aux noyaux monolithiques ?",
                    "solution": {
                        "correctAnswer": "En raison des fréquents passages entre mode utilisateur et mode noyau.",
                        "explanation": "Les services en mode utilisateur augmentent les changements de contexte."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 132,
                    "topic": "organisation_os",
                    "question": "Écrivez un programme C qui utilise l'appel système `mmap` pour mapper un fichier en mémoire.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <unistd.h>\n\nint main() {\n    int fd = open(\"test.txt\", O_RDWR);\n    if (fd >= 0) {\n        char *addr = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n        if (addr != MAP_FAILED) {\n            printf(\"Contenu : %s\\n\", addr);\n            munmap(addr, 4096);\n        }\n        close(fd);\n    }\n    return 0;\n}",
                        "explanation": "`mmap` mappe le fichier en mémoire pour un accès direct."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 133,
                    "topic": "organisation_os",
                    "question": "Calculez le temps de traitement d’un appel système si le changement de mode prend 0.2 ms et l’exécution 0.3 ms.",
                    "solution": {
                        "correctAnswer": "0.7 ms.",
                        "explanation": "Temps total = 2 changements de mode (0.2 ms * 2) + exécution (0.3 ms) = 0.7 ms."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 134,
                    "topic": "organisation_os",
                    "question": "Écrivez un programme C qui utilise l'appel système `fork()` et `signal` pour gérer SIGINT.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <signal.h>\n#include <unistd.h>\n\nvoid handler(int sig) {\n    printf(\"SIGINT reçu\\n\");\n}\n\nint main() {\n    signal(SIGINT, handler);\n    pid_t pid = fork();\n    if (pid == 0) {\n        printf(\"Enfant : PID %d\\n\", getpid());\n        while (1) pause();\n    } else {\n        printf(\"Parent : PID %d\\n\", getpid());\n        sleep(2);\n        kill(pid, SIGINT);\n        wait(NULL);\n    }\n    return 0;\n}",
                        "explanation": "Le gestionnaire traite SIGINT. Le parent envoie SIGINT à l'enfant."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 135,
                    "topic": "organisation_os",
                    "question": "Expliquez comment les modules du noyau améliorent la flexibilité d’un OS.",
                    "solution": {
                        "correctAnswer": "Ils permettent de charger/décharger des fonctionnalités sans redémarrer le noyau.",
                        "explanation": "Exemple : ajouter un pilote sans recompiler le noyau."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 136,
                    "topic": "organisation_os",
                    "question": "Écrivez un programme C qui utilise l'appel système `access` pour vérifier si un fichier est lisible.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    if (access(\"test.txt\", R_OK) == 0) {\n        printf(\"Fichier lisible\\n\");\n    } else {\n        printf(\"Fichier non lisible\\n\");\n    }\n    return 0;\n}",
                        "explanation": "`access` vérifie les permissions du fichier."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 137,
                    "topic": "organisation_os",
                    "question": "Calculez la surcharge des interruptions pour 1000 interruptions par seconde, chacune prenant 0.1 ms.",
                    "solution": {
                        "correctAnswer": "100 ms/seconde.",
                        "explanation": "1000 * 0.1 ms = 100 ms de surcharge par seconde."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 138,
                    "topic": "organisation_os",
                    "question": "Écrivez un programme C qui utilise l'appel système `sched_yield` pour céder le CPU.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <sched.h>\n\nint main() {\n    printf(\"Avant yield\\n\");\n    sched_yield();\n    printf(\"Après yield\\n\");\n    return 0;\n}",
                        "explanation": "`sched_yield` permet à d'autres processus de s'exécuter."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 139,
                    "topic": "organisation_os",
                    "question": "Expliquez comment un OS gère les appels système pour assurer la sécurité.",
                    "solution": {
                        "correctAnswer": "Il valide les paramètres et restreint l’accès aux ressources en mode utilisateur.",
                        "explanation": "Le noyau vérifie les autorisations avant d'exécuter l'appel."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 140,
                    "topic": "organisation_os",
                    "question": "Écrivez un programme C qui utilise l'appel système `getrlimit` pour afficher la limite de taille de pile.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <sys/resource.h>\n\nint main() {\n    struct rlimit limit;\n    getrlimit(RLIMIT_STACK, &limit);\n    printf(\"Limite de pile : %ld octets\\n\", limit.rlim_cur);\n    return 0;\n}",
                        "explanation": "`getrlimit` récupère les limites de ressources, comme la taille de la pile."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 141,
                    "topic": "organisation_os",
                    "question": "Concevez un gestionnaire d’interruptions pour un OS hypothétique gérant 3 périphériques (clavier, disque, réseau). Implémentez en C.",
                    "solution": {
                        "code": "#include <stdio.h>\n\n#define IRQ_KEYBOARD 1\n#define IRQ_DISK 14\n#define IRQ_NETWORK 11\n\nvoid handle_interrupt(int irq) {\n    switch (irq) {\n        case IRQ_KEYBOARD:\n            printf(\"Interruption clavier\\n\");\n            break;\n        case IRQ_DISK:\n            printf(\"Interruption disque\\n\");\n            break;\n        case IRQ_NETWORK:\n            printf(\"Interruption réseau\\n\");\n            break;\n        default:\n            printf(\"Interruption inconnue\\n\");\n    }\n    outportb(0x20, 0x20); // Fin d'interruption\n}\n\nint main() {\n    int irqs[] = {IRQ_KEYBOARD, IRQ_DISK, IRQ_NETWORK};\n    for (int i = 0; i < 3; i++) {\n        handle_interrupt(irqs[i]);\n    }\n    return 0;\n}",
                        "explanation": "Le gestionnaire identifie l'IRQ et appelle la routine appropriée, simulant le traitement des interruptions."
                    },
                    "level": "advanced"
                },
                {
                    "id": 142,
                    "topic": "organisation_os",
                    "question": "Implémentez un chargeur de modules du noyau en C pour charger un module fictif avec une fonction `init_module`.",
                    "solution": {
                        "code": "#include <stdio.h>\n\ntypedef int (*module_init_t)(void);\n\nstruct Module {\n    char *name;\n    module_init_t init;\n};\n\nint init_module() {\n    printf(\"Module initialisé\\n\");\n    return 0;\n}\n\nint load_module(struct Module *mod) {\n    printf(\"Chargement de %s\\n\", mod->name);\n    return mod->init();\n}\n\nint main() {\n    struct Module mod = {\"test_module\", init_module};\n    if (load_module(&mod) == 0) {\n        printf(\"Module chargé\\n\");\n    } else {\n        printf(\"Échec du chargement\\n\");\n    }\n    return 0;\n}",
                        "explanation": "Le chargeur appelle la fonction `init` du module, simulant le chargement dynamique."
                    },
                    "level": "advanced"
                },
                {
                    "id": 143,
                    "topic": "organisation_os",
                    "question": "Analysez les performances d’un microkernel par rapport à un noyau monolithique pour 1000 appels système, avec un changement de contexte de 0.1 ms pour le microkernel et 0.05 ms pour le monolithique.",
                    "solution": {
                        "correctAnswer": "Microkernel : 100 ms ; Monolithique : 50 ms.",
                        "explanation": "Microkernel : 1000 * 0.1 ms = 100 ms. Monolithique : 1000 * 0.05 ms = 50 ms. Le monolithique est deux fois plus rapide en raison de moins de changements de contexte."
                    },
                    "level": "advanced"
                },
                {
                    "id": 144,
                    "topic": "organisation_os",
                    "question": "Concevez un système de gestion des appels système pour un OS hypothétique. Implémentez en C avec une table d’appels.",
                    "solution": {
                        "code": "#include <stdio.h>\n\ntypedef void (*syscall_t)(void);\n\nvoid sys_fork() { printf(\"Appel fork\\n\"); }\nvoid sys_write() { printf(\"Appel write\\n\"); }\n\nsyscall_t syscall_table[] = {sys_fork, sys_write};\n\nint main() {\n    int syscall_num;\n    printf(\"Entrez numéro d'appel système (0-1) : \");\n    scanf(\"%d\", &syscall_num);\n    if (syscall_num >= 0 && syscall_num < 2) {\n        syscall_table[syscall_num]();\n    } else {\n        printf(\"Appel invalide\\n\");\n    }\n    return 0;\n}",
                        "explanation": "Une table d’appels système mappe les numéros aux fonctions correspondantes, simulant la gestion des appels."
                    },
                    "level": "advanced"
                },
                {
                    "id": 145,
                    "topic": "organisation_os",
                    "question": "Implémentez un simulateur en C pour un OS en couches avec 3 couches (noyau, mémoire, E/S). Chaque couche traite une requête en 1 ms.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\n\nvoid kernel_layer() {\n    printf(\"Noyau traite\\n\");\n    usleep(1000);\n}\n\nvoid memory_layer() {\n    printf(\"Mémoire traite\\n\");\n    usleep(1000);\n    kernel_layer();\n}\n\nvoid io_layer() {\n    printf(\"E/S traite\\n\");\n    usleep(1000);\n    memory_layer();\n}\n\nint main() {\n    io_layer();\n    printf(\"Requête terminée\\n\");\n    return 0;\n}",
                        "explanation": "Chaque couche (E/S, mémoire, noyau) simule un traitement de 1 ms avec `usleep`. La requête passe par toutes les couches dans l'ordre hiérarchique."
                    },
                    "level": "advanced"
                },
                {
                    "id": 146,
                    "topic": "organisation_os",
                    "question": "Concevez un mécanisme de gestion des interruptions imbriquées pour un OS hypothétique. Implémentez en C avec une pile d’interruptions.",
                    "solution": {
                        "code": "#include <stdio.h>\n\n#define MAX_NESTED 10\n\nstruct Interrupt {\n    int irq;\n    int priority;\n};\n\nstruct Interrupt stack[MAX_NESTED];\nint top = -1;\n\nvoid push_interrupt(int irq, int priority) {\n    if (top < MAX_NESTED - 1) {\n        stack[++top] = (struct Interrupt){irq, priority};\n        printf(\"Interruption %d empilée (priorité %d)\\n\", irq, priority);\n    }\n}\n\nvoid handle_interrupt(int irq, int priority) {\n    if (top >= 0 && stack[top].priority > priority) {\n        printf(\"Interruption %d ignorée (priorité inférieure)\\n\", irq);\n        return;\n    }\n    push_interrupt(irq, priority);\n    printf(\"Traitement IRQ %d\\n\", irq);\n    top--;\n}\n\nint main() {\n    handle_interrupt(1, 1); // Clavier\n    handle_interrupt(14, 2); // Disque\n    handle_interrupt(11, 3); // Réseau\n    return 0;\n}",
                        "explanation": "Le système empile les interruptions selon leur priorité. Une interruption de priorité inférieure est ignorée si une de priorité supérieure est en cours."
                    },
                    "level": "advanced"
                },
                {
                    "id": 147,
                    "topic": "organisation_os",
                    "question": "Analysez l’impact de la taille du noyau sur les performances d’un OS. Fournissez une comparaison quantitative pour un microkernel (100 Ko) et un noyau monolithique (1 Mo).",
                    "solution": {
                        "correctAnswer": "Microkernel : temps de chargement 0.1 ms ; Monolithique : 1 ms (hypothèse : 1 Ko = 0.001 ms).",
                        "explanation": "Un microkernel, plus petit, se charge plus rapidement et utilise moins de mémoire, mais peut nécessiter plus de changements de contexte. Le noyau monolithique, plus grand, a un temps de chargement plus long mais moins de surcharges pour les appels système."
                    },
                    "level": "advanced"
                },
                {
                    "id": 148,
                    "topic": "organisation_os",
                    "question": "Implémentez un simulateur en C pour un OS modulaire chargeant 3 modules (pilote disque, pilote réseau, gestionnaire de fichiers) avec des dépendances.",
                    "solution": {
                        "code": "#include <stdio.h>\n\nstruct Module {\n    char *name;\n    int (*init)();\n    int loaded;\n};\n\nint disk_init() { printf(\"Pilote disque chargé\\n\"); return 0; }\nint net_init() { printf(\"Pilote réseau chargé\\n\"); return 0; }\nint fs_init() { printf(\"Gestionnaire de fichiers chargé\\n\"); return 0; }\n\nint load_module(struct Module *mod) {\n    if (mod->loaded) return 0;\n    printf(\"Chargement de %s\\n\", mod->name);\n    mod->loaded = 1;\n    return mod->init();\n}\n\nint main() {\n    struct Module modules[] = {\n        {\"disque\", disk_init, 0},\n        {\"réseau\", net_init, 0},\n        {\"fichiers\", fs_init, 0}\n    };\n    load_module(&modules[0]); // Disque\n    load_module(&modules[1]); // Réseau\n    load_module(&modules[2]); // Fichiers (dépend de disque)\n    return 0;\n}",
                        "explanation": "Le simulateur charge les modules dans l’ordre, vérifiant les dépendances. Chaque module exécute sa fonction `init`."
                    },
                    "level": "advanced"
                },
                {
                    "id": 149,
                    "topic": "organisation_os",
                    "question": "Concevez un système de gestion des appels système avec validation des paramètres pour éviter les erreurs. Implémentez en C.",
                    "solution": {
                        "code": "#include <stdio.h>\n\ntypedef int (*syscall_t)(int);\n\nint sys_write(int fd) {\n    if (fd < 0) {\n        printf(\"Erreur : FD invalide\\n\");\n        return -1;\n    }\n    printf(\"Écriture sur FD %d\\n\", fd);\n    return 0;\n}\n\nint invoke_syscall(syscall_t call, int param) {\n    if (!call) {\n        printf(\"Erreur : appel système invalide\\n\");\n        return -1;\n    }\n    return call(param);\n}\n\nint main() {\n    invoke_syscall(sys_write, 1); // Valide\n    invoke_syscall(sys_write, -1); // Invalide\n    return 0;\n}",
                        "explanation": "Le système valide le pointeur de fonction et le paramètre (ex. FD positif) avant d’exécuter l’appel système."
                    },
                    "level": "advanced"
                },
                {
                    "id": 150,
                    "topic": "organisation_os",
                    "question": "Analysez les performances d’un OS en couches par rapport à un OS modulaire pour 1000 requêtes, avec un temps de traitement par couche de 0.1 ms et un temps de chargement de module de 0.05 ms.",
                    "solution": {
                        "correctAnswer": "OS en couches : 300 ms ; OS modulaire : 50 ms.",
                        "explanation": "OS en couches : 1000 requêtes * 3 couches * 0.1 ms = 300 ms. OS modulaire : 1000 requêtes * 0.05 ms (chargement unique) = 50 ms. L’OS modulaire est plus rapide grâce à moins de passages entre couches."
                    },
                    "level": "advanced"
                },
                {
                    "id": 151,
                    "topic": "introduction_os",
                    "question": "Qu’est-ce qu’un système d’exploitation ?",
                    "solution": {
                        "correctAnswer": "Un logiciel qui gère les ressources matérielles et fournit des services aux applications.",
                        "explanation": "Il agit comme une interface entre le matériel et les utilisateurs."
                    },
                    "level": "basic"
                },
                {
                    "id": 152,
                    "topic": "introduction_os",
                    "question": "Nommez deux rôles principaux d’un système d’exploitation.",
                    "solution": {
                        "correctAnswer": "Gestion des ressources, interface utilisateur.",
                        "explanation": "Il alloue le CPU, la mémoire et les E/S, et permet aux utilisateurs d’interagir via CLI ou GUI."
                    },
                    "level": "basic"
                },
                {
                    "id": 153,
                    "topic": "introduction_os",
                    "question": "Écrivez un programme C qui utilise l’appel système `uname` pour afficher la version de l’OS.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <sys/utsname.h>\n\nint main() {\n    struct utsname info;\n    uname(&info);\n    printf(\"Version OS : %s\\n\", info.release);\n    return 0;\n}",
                        "explanation": "`uname` récupère les informations système, dont la version de l’OS."
                    },
                    "level": "basic"
                },
                {
                    "id": 154,
                    "topic": "introduction_os",
                    "question": "Qu’est-ce qu’un service d’un OS ? Donnez un exemple.",
                    "solution": {
                        "correctAnswer": "Une fonction fournie par l’OS, comme la gestion des fichiers.",
                        "explanation": "Exemple : création de fichiers via `open`."
                    },
                    "level": "basic"
                },
                {
                    "id": 155,
                    "topic": "introduction_os",
                    "question": "Qu’est-ce que l’évolution des systèmes d’exploitation ?",
                    "solution": {
                        "correctAnswer": "Le développement des OS pour répondre aux besoins changeants, comme le multitâche ou les interfaces graphiques.",
                        "explanation": "Exemple : passage de MS-DOS à Windows."
                    },
                    "level": "basic"
                },
                {
                    "id": 156,
                    "topic": "introduction_os",
                    "question": "Nommez trois problèmes courants des systèmes d’exploitation.",
                    "solution": {
                        "correctAnswer": "Sécurité, performance, compatibilité.",
                        "explanation": "Les OS doivent protéger contre les attaques, optimiser les ressources et supporter divers matériels."
                    },
                    "level": "basic"
                },
                {
                    "id": 157,
                    "topic": "introduction_os",
                    "question": "Écrivez un programme C qui utilise l’appel système `gethostname` pour afficher le nom de l’hôte.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    char hostname[256];\n    gethostname(hostname, 256);\n    printf(\"Hôte : %s\\n\", hostname);\n    return 0;\n}",
                        "explanation": "`gethostname` retourne le nom de l’hôte du système."
                    },
                    "level": "basic"
                },
                {
                    "id": 158,
                    "topic": "introduction_os",
                    "question": "Qu’est-ce que le multitâche dans un OS ?",
                    "solution": {
                        "correctAnswer": "La capacité d’exécuter plusieurs processus simultanément.",
                        "explanation": "L’OS alterne entre les processus pour donner l’illusion de parallélisme."
                    },
                    "level": "basic"
                },
                {
                    "id": 159,
                    "topic": "introduction_os",
                    "question": "Quelle est la différence entre un OS temps réel et un OS général ?",
                    "solution": {
                        "correctAnswer": "Un OS temps réel garantit des réponses dans des délais stricts, contrairement à un OS général.",
                        "explanation": "Exemple : RTOS pour les systèmes embarqués."
                    },
                    "level": "basic"
                },
                {
                    "id": 160,
                    "topic": "introduction_os",
                    "question": "Écrivez un programme C qui utilise l’appel système `sysinfo` pour afficher la mémoire totale.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <sys/sysinfo.h>\n\nint main() {\n    struct sysinfo info;\n    sysinfo(&info);\n    printf(\"Mémoire totale : %lu Ko\\n\", info.totalram / 1024);\n    return 0;\n}",
                        "explanation": "`sysinfo` fournit des statistiques système, dont la mémoire totale."
                    },
                    "level": "basic"
                },
                {
                    "id": 161,
                    "topic": "introduction_os",
                    "question": "Qu’est-ce que la gestion des périphériques dans un OS ?",
                    "solution": {
                        "correctAnswer": "Le contrôle des périphériques matériels via des pilotes.",
                        "explanation": "L’OS envoie des commandes aux périphériques via le noyau."
                    },
                    "level": "basic"
                },
                {
                    "id": 162,
                    "topic": "introduction_os",
                    "question": "Qu’est-ce qu’un système de fichiers ?",
                    "solution": {
                        "correctAnswer": "Une structure pour organiser et stocker des données sur un périphérique.",
                        "explanation": "Exemple : FAT32, NTFS."
                    },
                    "level": "basic"
                },
                {
                    "id": 163,
                    "topic": "introduction_os",
                    "question": "Écrivez un programme C qui utilise l’appel système `time` pour afficher la date actuelle.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    time_t t;\n    time(&t);\n    printf(\"Date : %s\", ctime(&t));\n    return 0;\n}",
                        "explanation": "`time` retourne le temps actuel, affiché avec `ctime`."
                    },
                    "level": "basic"
                },
                {
                    "id": 164,
                    "topic": "introduction_os",
                    "question": "Qu’est-ce que la virtualisation dans un OS ?",
                    "solution": {
                        "correctAnswer": "La création d’environnements virtuels pour exécuter plusieurs OS sur un même matériel.",
                        "explanation": "Exemple : VMware, VirtualBox."
                    },
                    "level": "basic"
                },
                {
                    "id": 165,
                    "topic": "introduction_os",
                    "question": "Nommez deux types de systèmes d’exploitation.",
                    "solution": {
                        "correctAnswer": "OS de bureau (ex. Windows), OS mobile (ex. Android).",
                        "explanation": "Ils sont conçus pour différents matériels et usages."
                    },
                    "level": "basic"
                },
                {
                    "id": 166,
                    "topic": "introduction_os",
                    "question": "Qu’est-ce que la compatibilité descendante dans un OS ?",
                    "solution": {
                        "correctAnswer": "La capacité d’exécuter des logiciels conçus pour une version antérieure.",
                        "explanation": "Exemple : Windows 11 exécutant des applications Windows XP."
                    },
                    "level": "basic"
                },
                {
                    "id": 167,
                    "topic": "introduction_os",
                    "question": "Écrivez un programme C qui utilise l’appel système `getpid` pour afficher l’ID du processus.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    printf(\"PID : %d\\n\", getpid());\n    return 0;\n}",
                        "explanation": "`getpid` retourne l’ID du processus courant."
                    },
                    "level": "basic"
                },
                {
                    "id": 168,
                    "topic": "introduction_os",
                    "question": "Qu’est-ce que la gestion de la mémoire dans un OS ?",
                    "solution": {
                        "correctAnswer": "L’allocation et la libération de la mémoire pour les processus.",
                        "explanation": "L’OS utilise des techniques comme la pagination et la segmentation."
                    },
                    "level": "basic"
                },
                {
                    "id": 169,
                    "topic": "introduction_os",
                    "question": "Qu’est-ce qu’un OS open-source ? Donnez un exemple.",
                    "solution": {
                        "correctAnswer": "Un OS dont le code source est librement accessible. Exemple : Linux.",
                        "explanation": "Les utilisateurs peuvent modifier et redistribuer le code."
                    },
                    "level": "basic"
                },
                {
                    "id": 170,
                    "topic": "introduction_os",
                    "question": "Écrivez un programme C qui utilise l’appel système `getuid` pour afficher l’ID de l’utilisateur.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    printf(\"UID : %d\\n\", getuid());\n    return 0;\n}",
                        "explanation": "`getuid` retourne l’ID de l’utilisateur courant."
                    },
                    "level": "basic"
                },
                {
                    "id": 171,
                    "topic": "introduction_os",
                    "question": "Écrivez un programme C qui utilise l’appel système `fork` pour créer un processus enfant affichant un message.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    pid_t pid = fork();\n    if (pid == 0) {\n        printf(\"Enfant : Bonjour\\n\");\n    } else if (pid > 0) {\n        printf(\"Parent\\n\");\n    } else {\n        printf(\"Erreur fork\\n\");\n    }\n    return 0;\n}",
                        "explanation": "`fork` crée un processus enfant qui affiche un message distinct du parent."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 172,
                    "topic": "introduction_os",
                    "question": "Expliquez comment l’évolution des OS a impacté la gestion des ressources.",
                    "solution": {
                        "correctAnswer": "Les OS modernes optimisent mieux le CPU, la mémoire et les E/S grâce à des techniques comme le multitâche préemptif et la virtualisation.",
                        "explanation": "Exemple : passage du monotâche (MS-DOS) au multitâche (Windows NT)."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 173,
                    "topic": "introduction_os",
                    "question": "Calculez le temps moyen d’accès à un fichier si la recherche du répertoire prend 2 ms et la lecture 3 ms.",
                    "solution": {
                        "correctAnswer": "5 ms.",
                        "explanation": "Temps total = recherche (2 ms) + lecture (3 ms) = 5 ms."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 174,
                    "topic": "introduction_os",
                    "question": "Écrivez un programme C qui utilise l’appel système `stat` pour afficher la date de modification d’un fichier.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <sys/stat.h>\n#include <time.h>\n\nint main() {\n    struct stat st;\n    if (stat(\"test.txt\", &st) == 0) {\n        printf(\"Modifié : %s\", ctime(&st.st_mtime));\n    } else {\n        printf(\"Erreur stat\\n\");\n    }\n    return 0;\n}",
                        "explanation": "`stat` récupère les métadonnées, dont la date de modification."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 175,
                    "topic": "introduction_os",
                    "question": "Expliquez pourquoi la sécurité est un problème majeur pour les OS modernes.",
                    "solution": {
                        "correctAnswer": "Les OS sont vulnérables aux attaques en raison de leur complexité et de leur connectivité.",
                        "explanation": "Exemple : exploits de type zero-day exploitant des failles du noyau."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 176,
                    "topic": "introduction_os",
                    "question": "Écrivez un programme C qui utilise l’appel système `access` pour vérifier si un fichier est exécutable.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    if (access(\"test.sh\", X_OK) == 0) {\n        printf(\"Fichier exécutable\\n\");\n    } else {\n        printf(\"Fichier non exécutable\\n\");\n    }\n    return 0;\n}",
                        "explanation": "`access` vérifie si le fichier a la permission d’exécution."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 177,
                    "topic": "introduction_os",
                    "question": "Calculez le débit d’un OS traitant 100 processus en 1 seconde.",
                    "solution": {
                        "correctAnswer": "100 processus/seconde.",
                        "explanation": "100 processus / 1 s = 100 processus par seconde."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 178,
                    "topic": "introduction_os",
                    "question": "Écrivez un programme C qui utilise l’appel système `execvp` pour exécuter une commande saisie par l’utilisateur.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    char cmd[100];\n    printf(\"Commande : \");\n    scanf(\"%s\", cmd);\n    char *args[] = {cmd, NULL};\n    execvp(cmd, args);\n    printf(\"Erreur exec\\n\");\n    return 1;\n}",
                        "explanation": "`execvp` exécute la commande saisie, remplaçant le processus courant."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 179,
                    "topic": "introduction_os",
                    "question": "Expliquez comment les OS gèrent la compatibilité avec les anciens logiciels.",
                    "solution": {
                        "correctAnswer": "Ils utilisent des couches de compatibilité ou des machines virtuelles.",
                        "explanation": "Exemple : mode de compatibilité Windows ou Wine pour Linux."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 180,
                    "topic": "introduction_os",
                    "question": "Écrivez un programme C qui utilise l’appel système `sysconf` pour afficher le nombre maximum de fichiers ouverts.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    long max_files = sysconf(_SC_OPEN_MAX);\n    printf(\"Max fichiers ouverts : %ld\\n\", max_files);\n    return 0;\n}",
                        "explanation": "`sysconf(_SC_OPEN_MAX)` retourne la limite de descripteurs de fichiers."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 181,
                    "topic": "introduction_os",
                    "question": "Pourquoi les OS modernes privilégient le multitâche préemptif ?",
                    "solution": {
                        "correctAnswer": "Il permet une meilleure réactivité et une utilisation équitable du CPU.",
                        "explanation": "Le noyau peut interrompre un processus pour en exécuter un autre."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 182,
                    "topic": "introduction_os",
                    "question": "Écrivez un programme C qui utilise l’appel système `getrusage` pour afficher le temps CPU système.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <sys/resource.h>\n\nint main() {\n    struct rusage usage;\n    getrusage(RUSAGE_SELF, &usage);\n    printf(\"Temps CPU système : %ld.%06ld s\\n\", usage.ru_stime.tv_sec, usage.ru_stime.tv_usec);\n    return 0;\n}",
                        "explanation": "`getrusage` fournit le temps CPU utilisé en mode système."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 183,
                    "topic": "introduction_os",
                    "question": "Calculez la surcharge d’un OS traitant 500 appels système par seconde, chacun prenant 0.2 ms.",
                    "solution": {
                        "correctAnswer": "100 ms/seconde.",
                        "explanation": "500 * 0.2 ms = 100 ms de surcharge par seconde."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 184,
                    "topic": "introduction_os",
                    "question": "Écrivez un programme C qui utilise l’appel système `fork` et `wait` pour exécuter une tâche dans un processus enfant.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    pid_t pid = fork();\n    if (pid == 0) {\n        printf(\"Enfant exécute tâche\\n\");\n    } else {\n        wait(NULL);\n        printf(\"Parent : tâche terminée\\n\");\n    }\n    return 0;\n}",
                        "explanation": "`fork` crée un enfant, et `wait` synchronise le parent."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 185,
                    "topic": "introduction_os",
                    "question": "Expliquez l’impact de la virtualisation sur les performances d’un OS.",
                    "solution": {
                        "correctAnswer": "Elle augmente la surcharge en raison de l’émulation matérielle, mais permet une meilleure isolation.",
                        "explanation": "Exemple : un hyperviseur ajoute une latence pour gérer les machines virtuelles."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 186,
                    "topic": "introduction_os",
                    "question": "Écrivez un programme C qui utilise l’appel système `chmod` pour modifier les permissions d’un fichier.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <sys/stat.h>\n\nint main() {\n    if (chmod(\"test.txt\", S_IRWXU) == 0) {\n        printf(\"Permissions modifiées\\n\");\n    } else {\n        printf(\"Erreur chmod\\n\");\n    }\n    return 0;\n}",
                        "explanation": "`chmod` modifie les permissions du fichier (lecture/écriture/exécution pour l’utilisateur)."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 187,
                    "topic": "introduction_os",
                    "question": "Calculez le temps moyen d’exécution d’un processus si la création prend 1 ms et l’exécution 4 ms.",
                    "solution": {
                        "correctAnswer": "5 ms.",
                        "explanation": "Temps total = création (1 ms) + exécution (4 ms) = 5 ms."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 188,
                    "topic": "introduction_os",
                    "question": "Écrivez un programme C qui utilise l’appel système `signal` pour gérer SIGUSR1.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <signal.h>\n#include <unistd.h>\n\nvoid handler(int sig) {\n    printf(\"SIGUSR1 reçu\\n\");\n}\n\nint main() {\n    signal(SIGUSR1, handler);\n    printf(\"PID : %d\\n\", getpid());\n    while (1) pause();\n    return 0;\n}",
                        "explanation": "`signal` associe un gestionnaire à SIGUSR1, et `pause` attend le signal."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 189,
                    "topic": "introduction_os",
                    "question": "Expliquez pourquoi les OS open-source favorisent l’innovation.",
                    "solution": {
                        "correctAnswer": "Leur code est accessible, permettant aux développeurs de personnaliser et d’améliorer l’OS.",
                        "explanation": "Exemple : contributions communautaires à Linux."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 190,
                    "topic": "introduction_os",
                    "question": "Écrivez un programme C qui utilise l’appel système `getrlimit` pour afficher la limite de mémoire virtuelle.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <sys/resource.h>\n\nint main() {\n    struct rlimit limit;\n    getrlimit(RLIMIT_AS, &limit);\n    printf(\"Limite mémoire virtuelle : %ld octets\\n\", limit.rlim_cur);\n    return 0;\n}",
                        "explanation": "`getrlimit(RLIMIT_AS)` retourne la limite de mémoire virtuelle."
                    },
                    "level": "intermediate"
                },
                {
                    "id": 191,
                    "topic": "introduction_os",
                    "question": "Concevez un simulateur en C pour analyser l’évolution des OS, simulant un OS monotâche et multitâche pour 3 processus (durées : 10 ms, 20 ms, 30 ms).",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\n\nvoid monotask(int durations[], int n) {\n    int total = 0;\n    printf(\"Monotâche : \");\n    for (int i = 0; i < n; i++) {\n        printf(\"P%d \", i + 1);\n        total += durations[i];\n        usleep(durations[i] * 1000);\n    }\n    printf(\"\\nTemps total : %d ms\\n\", total);\n}\n\nvoid multitask(int durations[], int n) {\n    int total = 0, quantum = 10;\n    int remain[3];\n    for (int i = 0; i < n; i++) remain[i] = durations[i];\n    printf(\"Multitâche : \");\n    while (1) {\n        int done = 1;\n        for (int i = 0; i < n; i++) {\n            if (remain[i] > 0) {\n                done = 0;\n                int exec = remain[i] < quantum ? remain[i] : quantum;\n                printf(\"P%d \", i + 1);\n                remain[i] -= exec;\n                total += exec;\n                usleep(exec * 1000);\n            }\n        }\n        if (done) break;\n    }\n    printf(\"\\nTemps total : %d ms\\n\", total);\n}\n\nint main() {\n    int durations[] = {10, 20, 30};\n    monotask(durations, 3);\n    multitask(durations, 3);\n    return 0;\n}",
                        "explanation": "Monotâche : exécute P1, P2, P3 séquentiellement (60 ms). Multitâche : utilise round-ro连忙 with quantum de 10 ms (60 ms, mais meilleure réactivité)."
                    },
                    "level": "advanced"
                },
                {
                    "id": 192,
                    "topic": "introduction_os",
                    "question": "Analysez l’impact de la sécurité sur les performances d’un OS pour 1000 appels système avec validation de sécurité (0.1 ms par appel).",
                    "solution": {
                        "correctAnswer": "Surcharge de sécurité : 100 ms.",
                        "explanation": "1000 appels * 0.1 ms = 100 ms de surcharge. La validation améliore la sécurité mais réduit les performances."
                    },
                    "level": "advanced"
                },
                {
                    "id": 193,
                    "topic": "introduction_os",
                    "question": "Concevez un système de gestion des erreurs pour un OS hypothétique. Implémentez en C pour gérer les erreurs d’appels système.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <errno.h>\n\nint sys_call(int param) {\n    if (param < 0) {\n        errno = EINVAL;\n        return -1;\n    }\n    printf(\"Appel réussi\\n\");\n    return 0;\n}\n\nvoid handle_error() {\n    switch (errno) {\n        case EINVAL:\n            printf(\"Erreur : paramètre invalide\\n\");\n            break;\n        default:\n            printf(\"Erreur inconnue\\n\");\n    }\n}\n\nint main() {\n    if (sys_call(-1) < 0) {\n        handle_error();\n    }\n    if (sys_call(1) < 0) {\n        handle_error();\n    }\n    return 0;\n}",
                        "explanation": "Le système définit `errno` pour les erreurs et utilise un gestionnaire pour afficher des messages spécifiques."
                    },
                    "level": "advanced"
                },
                {
                    "id": 194,
                    "topic": "introduction_os",
                    "question": "Implémentez un simulateur en C pour comparer les performances d’un OS temps réel et d’un OS général pour 5 tâches (durées : 5 ms chacune).",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\n\nvoid realtime(int durations[], int n) {\n    int total = 0;\n    printf(\"Temps réel : \");\n    for (int i = 0; i < n; i++) {\n        printf(\"T%d \", i + 1);\n        total += durations[i];\n        usleep(durations[i] * 1000);\n    }\n    printf(\"\\nTemps total : %d ms\\n\", total);\n}\n\nvoid general(int durations[], int n) {\n    int total = 0, overhead = 1; // Surcharge par tâche\n    printf(\"Général : \");\n    for (int i = 0; i < n; i++) {\n        printf(\"T%d \", i + 1);\n        total += durations[i] + overhead;\n        usleep((durations[i] + overhead) * 1000);\n    }\n    printf(\"\\nTemps total : %d ms\\n\", total);\n}\n\nint main() {\n    int durations[] = {5, 5, 5, 5, 5};\n    realtime(durations, 5);\n    general(durations, 5);\n    return 0;\n}",
                        "explanation": "Temps réel : 25 ms (5 * 5 ms). Général : 30 ms (5 * (5 + 1) ms) en raison de la surcharge de planification."
                    },
                    "level": "advanced"
                },
                {
                    "id": 195,
                    "topic": "introduction_os",
                    "question": "Analysez l’impact de la compatibilité descendante sur les performances d’un OS pour 1000 appels système, avec une surcharge de compatibilité de 0.05 ms par appel.",
                    "solution": {
                        "correctAnswer": "Surcharge de compatibilité : 50 ms.",
                        "explanation": "1000 appels * 0.05 ms = 50 ms. La compatibilité ajoute une latence mais permet d’exécuter des logiciels anciens."
                    },
                    "level": "advanced"
                },
                {
                    "id": 196,
                    "topic": "introduction_os",
                    "question": "Concevez un système de journalisation pour un OS hypothétique. Implémentez en C pour enregistrer les événements système.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <time.h>\n\nvoid log_event(char *event) {\n    time_t t;\n    time(&t);\n    FILE *f = fopen(\"system.log\", \"a\");\n    if (f) {\n        fprintf(f, \"[%s] %s\\n\", ctime(&t), event);\n        fclose(f);\n    }\n}\n\nint main() {\n    log_event(\"Démarrage du système\");\n    log_event(\"Chargement du pilote disque\");\n    printf(\"Événements journalisés\\n\");\n    return 0;\n}",
                        "explanation": "Le système enregistre les événements avec un horodatage dans un fichier journal."
                    },
                    "level": "advanced"
                },
                {
                    "id": 197,
                    "topic": "introduction_os",
                    "question": "Implémentez un simulateur en C pour analyser l’impact de la virtualisation sur 5 processus (durées : 10 ms chacun), avec une surcharge de virtualisation de 2 ms par processus.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\n\nvoid non_virtualized(int durations[], int n) {\n    int total = 0;\n    printf(\"Non virtualisé : \");\n    for (int i = 0; i < n; i++) {\n        printf(\"P%d \", i + 1);\n        total += durations[i];\n        usleep(durations[i] * 1000);\n    }\n    printf(\"\\nTemps total : %d ms\\n\", total);\n}\n\nvoid virtualized(int durations[], int n) {\n    int total = 0, overhead = 2;\n    printf(\"Virtualisé : \");\n    for (int i = 0; i < n; i++) {\n        printf(\"P%d \", i + 1);\n        total += durations[i] + overhead;\n        usleep((durations[i] + overhead) * 1000);\n    }\n    printf(\"\\nTemps total : %d ms\\n\", total);\n}\n\nint main() {\n    int durations[] = {10, 10, 10, 10, 10};\n    non_virtualized(durations, 5);\n    virtualized(durations, 5);\n    return 0;\n}",
                        "explanation": "Non virtualisé : 50 ms. Virtualisé : 60 ms (5 * (10 + 2)). La virtualisation ajoute une surcharge."
                    },
                    "level": "advanced"
                },
                {
                    "id": 198,
                    "topic": "introduction_os",
                    "question": "Analysez les performances d’un OS open-source par rapport à un OS propriétaire pour 1000 appels système, avec une surcharge d’optimisation de 0.01 ms pour l’open-source.",
                    "solution": {
                        "correctAnswer": "Open-source : 10 ms ; Propriétaire : 0 ms (hypothèse sans surcharge).",
                        "explanation": "Open-source : 1000 * 0.01 ms = 10 ms de surcharge due à des optimisations communautaires parfois moins ciblées. Propriétaire : optimisé pour des cas spécifiques, supposé sans surcharge."
                    },
                    "level": "advanced"
                },
                {
                    "id": 199,
                    "topic": "introduction_os",
                    "question": "Concevez un système de surveillance des performances pour un OS hypothétique. Implémentez en C pour mesurer le temps CPU.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <sys/resource.h>\n#include <unistd.h>\n\nvoid monitor_cpu() {\n    struct rusage usage;\n    getrusage(RUSAGE_SELF, &usage);\n    printf(\"Temps CPU utilisateur : %ld.%06ld s\\n\", usage.ru_utime.tv_sec, usage.ru_utime.tv_usec);\n    printf(\"Temps CPU système : %ld.%06ld s\\n\", usage.ru_stime.tv_sec, usage.ru_stime.tv_usec);\n}\n\nint main() {\n    printf(\"Avant tâche\\n\");\n    monitor_cpu();\n    for (int i = 0; i < 1000000; i++); // Tâche fictive\n    printf(\"Après tâche\\n\");\n    monitor_cpu();\n    return 0;\n}",
                        "explanation": "Le système utilise `getrusage` pour mesurer le temps CPU avant et après une tâche."
                    },
                    "level": "advanced"
                },
                {
                    "id": 200,
                    "topic": "introduction_os",
                    "question": "Implémentez un simulateur en C pour comparer un OS distribué et un OS centralisé pour 5 processus (durées : 10 ms chacun), avec une latence réseau de 1 ms pour l’OS distribué.",
                    "solution": {
                        "code": "#include <stdio.h>\n#include <unistd.h>\n\nvoid centralized(int durations[], int n) {\n    int total = 0;\n    printf(\"Centralisé : \");\n    for (int i = 0; i < n; i++) {\n        printf(\"P%d \", i + 1);\n        total += durations[i];\n        usleep(durations[i] * 1000);\n    }\n    printf(\"\\nTemps total : %d ms\\n\", total);\n}\n\nvoid distributed(int durations[], int n) {\n    int total = 0, latency = 1;\n    printf(\"Distribué : \");\n    for (int i = 0; i < n; i++) {\n        printf(\"P%d \", i + 1);\n        total += durations[i] + latency;\n        usleep((durations[i] + latency) * 1000);\n    }\n    printf(\"\\nTemps total : %d ms\\n\", total);\n}\n\nint main() {\n    int durations[] = {10, 10, 10, 10, 10};\n    centralized(durations, 5);\n    distributed(durations, 5);\n    return 0;\n}",
                        "explanation": "Centralisé : 50 ms. Distribué : 55 ms (5 * (10 + 1)). La latence réseau augmente le temps total."
                    },
                    "level": "advanced"
                }
            ]
        }
    }
}